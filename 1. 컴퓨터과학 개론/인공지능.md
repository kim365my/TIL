# 개요
- 인공지능의 정의 : 인지컴퓨팅 시스템,  #AGI 
- 코드 예시는 [[C]]언어로 표현됨

# 인공지능의 개념
## 지능이란 무엇인가?
- 지능의 사전적 정의
	- 새로운 대상이나 상황에 부딪혀 그 의미를 이해하고 합리적인 적응방법을 알아내는 지적 활동의 능력
	- 문제해결 능력, 학습 능력, 지식활용능력, 인지 능력, 다양한 상황에 대한 적응능력 등
	- 주어진 데이터를 분석을 통해 학습하고 그것을 새로운 데이터에 적용하는 것이 지능이다. 
- 사람의 학습방법을 기계학습에 적용
	- 사람의 학습방법
		- 직접적인 지식의 전달
		- 귀납적 지식 형성
		- 외부의 긍정적 반응과 부정적 반응
	- 기계학습 Machine learnig
		- 수집된 정보로부터 문제 풀이에 필요한 지식을 습득함으로써 시스템 스스로 행동을 향상시키는 과정
### 컴퓨터가 생각을 할 수 있을까?
#### 튜링 테스트  Turing Test
- 앨런 튜링이 컴퓨터가 생각을 할 수 있는 가를 입증하기 위한 방법으로 제안한 방법으로, 평가자가 가려진 사람과 대화를 하는 과정에서 사람과 컴퓨터를 구분하는 검사방법 
#### 알파고와의 바둑 대결
- 트리탐색, 심층학습을 이용한 기계 학습 기술 적용
	- 다수의 CPU와 GPU를 이용한 대단위 병렬 컴퓨터 이용

#### 지능적 시스템에 요구되는 능력
- 지식을 바탕으로 동작할 수 있는 능력
- 데이터를 분석하여 예측할 수 있는 능력
- 학습할 수 있는 능력
- 사물을 인지할 수 있는 능력
- 자연어를 이해하고 구사할 수 있는 능력
- 창조할 수 있는 능력
- 감성지능

### 인공지능의 분류
- 약한 인공지능 weak AI(좁은 인공지능 narrow AI)
	- 특정 작업 영역에 활용할 수 있도록 설계된 지능적 시스템
- 강한 인공지능 strong AI(인공 일반지능, artificial general intelligence #AGI)
	- 사람이 할 수 있는 어떠한 지적인 작업이든 사람만큼, 혹은 사람보다 더 잘 해낼 수 있는 지능적인 기계



## 인공지능의 역사
### 인공지능의 태동
- 다트머스 회의 Dartmouth workshop
	- 1956년 Dartmouth 대학의 마빈 민스키, 존 메카시, 너대니얼, 로체스터, 클로드 새넌 등의 제안으로 개최된 학술회의
- 'Artificial Intelligence'라는 이름이 사용되기 시작 #AGI 
- 자동적 컴퓨터, 컴퓨터가 언어를 사용하게 하는 방법, 가상 신경세포의 개념 형성, 계산의 규모에 대한 이론, 자기 개선, 추상화, 무작위성과 창의성 등의 인공지능 관련 주제에 대해 브레인스토임
	- 기호처리 기법, 제한된 영역에 집중한 시스템(초기 전문가 시스템), 연역 시스템과 귀납 시스템 등에 관심


## 인공지능의 사용분야
- 기계학습 : 딥러닝, 데이터 마이닝
- 자연어처리 : 번역, 정보 추출
- 컴퓨터 시각 : 영상인식, 의학영상진단
- 음성처리
- 로봇, 자동차 : 공장자동화, 자율주행
- 예술 : 회화, 음악

## 지능형 에이전트
- 대상 환경을 인지하고 이에 대한 행동을 결정하여 실행함으로써 환경을 변화시킨다. 이때 현재 환경의 상태와 더불어 내부모델, 지식, 목표, 유용성 등을 바탕으로 실행할 행동을 결정

### 에이전트 프로그램의 기본 골격
>[!example]
> ```python
> function Agent 
> 	Environment e; // 환경
> 	RuleSet r; // 규칙의 집합
> 	while (true) do // 지속적인 동작
> 		state = senseEnviroment(e); // 환경의 감지
> 		a = chooseAction(state, r); // 행동의 결정
> 		a.applyAction(e); // 결정한 행동을 실행
> 	end-while; 
> end-function.
> ```
- 환경의 감지와 행동의 결정을 계속 반복


# 컴퓨터로 표현하는 문제풀이
- 문제 풀이
	- 직관적으로 단순하게 해결할 수 없는 문제에 대해 문제를 파악하고 문제의 해에 이르는 방법을 찾아내는 일련의 과정
- 문제풀이에 사용될 수 있는 전략
	- 알고리즘  
	- 시행착오

## 문제표현의 요소
1. 상태묘사 : 풀이하고자 하는 문제의 상태를 컴퓨터로 처리하기 위한 적절한 ==자료구조로 표현==한 것
	1. 초기상태 : 풀고자하는 문제
	2. 목표상태 : 문제의 해답
	3. 상태 사이의 관계표현 : 방향성 그래프를 이용해 부모상태와 후계상태의 관계를 표현, 이러한 표현을 상태공간이라고 함
		1. 부모상태 : 연산자를 통해 바뀌기 이전의 상태
		2. 후계상태 : 연산자를 통해 바뀌기 이후의 상태
2. [[오퍼레이션|연산자]] : 문제의 어느 한 상태로부터 변화할 수 있는 다른 상태로 변환하는 역할
	- 변환 테이블이나 변환함수로 구현 #이해부족
	- 코드 예시
		```c
		int opMyBlnkUp(PuzzleState* s){
			if(s->blankY > 0){
				s->board[s->blankX][s->blankY] = s->board[s->blankY][s->blankY-1];
				s->board[s->blankY][--s->blankY] = '';
				return 1; 
			} else{
				return 0;
			}
		}
		```
3. 상태공간 : 정의된 연산자 집합을 이용해 초기 상태로부터 얻을 수 있는 모든 상태의 집합으로, 그래프 형태로 표현할 수 있다.
	    ![[Pasted image 20230410032325.png|325]]


- 상태공간에서 문제풀이를 위한 문제의 표현
	1. 상태묘사 및 초기상태의 정의
		- 묘사를 어떤 자료구조를 이용해서 할 것인지도 포함됨
	2. 연산자 정의
	3. 목표상태의 정의 
- 상태공간 탐색에 의한 문제풀이
	- 초기상태에서 목표상태에 도달하는 일련의 연산자를 찾기 위해 시행착오 방식으로 그래프 탐색을 함


## 상태공간 탐색에 의한 문제풀이
-  초기상태에서 목표상태에 도달하는 일련의 연산자를 찾기 위해 시행착오 방식으로 그래프 탐색을 함
- 방대한 경우의 수가 있는 상태공간에서 효율적으로 목표상태에 도달하는 경로를 찾기 위한 것
	- 시행착오를 거치며 목표상태에 도달하는 탐색과정
	- 탐색에 유용한 지식을 사용함으로써 방대한 상태공간에서 탐색 범위를 좁히려고 함
### 탐색과정
- 정해진 기준에 따라 노드를 선택
- **노드의 확장** : 선택된 노드(상태)에 적용할 수 있는 모든 연산자를 가하여 모든 후계노드(후계상태)를 생성
- 후계노드에는 부모노드를 가리키는 포인터를 첨부
	- 탐색에 성공한 후에 풀이 경로를 알 수 있게 하기 위해서
- 목표노드가 있는지 검사
	- 원하는 목표를 찾지 못했다면 정해진 기준에 따라 다음 노드를 선택하여 탐색과정을 반복


- 수업에서는 알고리즘으로 구현하기 위해서 2개의 리스트로 정의
	   ![[Pasted image 20230410034751.png|150]]
	- OPEN : 앞으로 확장할 노드를 저장하는 리스트
	- CLOSED : 이미 확장한 노드를 저장하는 리스트
	- 코드예시 (뒤에 있는 것은 부모 노드에 대한 포인터)
		```C
		OPEN : {(b, a), (d, a), (e, a),(f, c),(h, g), (i, g), (j, g)}
		CLOSED : {(a, NULL), (c, a),(g, c)}
		```
		- 탐색 알고리즘에 따라 정해진 순서로 OPEN에서 확장할 노드를 꺼내 CLOSED로 옮김
		- 확장 결과 생성된 노드를 OPEN의 적절한 위치에 저장

### 탐색의 종류
|             |               임의 경로 탐색                |     최적 경로 탐색     |
|:-----------:|:-------------------------------------------:|:----------------------:|
| 맹목적 탐색 |        깊이우선 탐색, 너비우선 탐색         |      균일비용탐색      |
| 경험적 탐색 | 언덕오르기 탐색, 최적우선 탐색, 모의 담금질 | A* 알고리즘 |

#### 맹목적 탐색 blind search
- 목표 노드의 위치와 무관한 순서로 노드 확장
- 매우 소모적인 탐색을 할 가능성이 높음
##### 깊이 우선 탐색 depth-first search
- 정의 : 탐색 진행방향(깊이 방향)으로 계속 전진하여 목표를 탐색
	- 다음 확장할 노드를 선택하는 기준  :  가장 최근에 생성된 노드를 먼저 확장
	- OPEN : [[데이터 구조와 알고리즘#스택|스택]]구조가 유용
- 단점 : 목표에 도달할 수 없는 경로를 계속 탐색하게 될 수 있음
- 깊이제한 depth bound
	- 목표에 도달할 수 없는 경로를 제한해서 무한정 진행하는 것을 방지
	- 깊이 제한에 도달하거나 더 이상 진행할 경로가 없을 경우 이전 상태 중 다른 경로를 선택할 수 있는 위치로 복귀하여 탐색을 계속함
>[!example]- 예시 
> - 탐색트리는 깊이 방향으로 계속 확장된다. 따라서 A-> B, C, D -> E -> I, J 식으로 확장되며, 깊이제한에 도달하면 이전 상태 중에서 다른 경로를 선택할 수 있는 위치로 복귀![[Pasted image 20230410025157.png|400]]

##### 너비 우선 탐색 breadth-first search
- 정의 :  먼저 생성된 노드를 먼저 확장하여 목표를 탐색 
	- 다음 확장할 노드를 선택하는 기준  : 가장 먼저 생성된 노드를 먼저 확장
	- OPEN : [[데이터 구조와 알고리즘#큐|큐]] 구조가 유용
	- 예시 
		- 탐색트리는 레벨 순서에 따라 확장된다. 따라서 A-> B, C, D -> E -> C -> F, G, H -> D식으로 확장된다. 목표노드 검사는 노드를 확장하여 생성된 후계노드들에 대해 수행하므로, 노드의 확장은 L의 부모노드인 G까지만 하게 된다. ![[Pasted image 20230410025157.png]]
- 만약 해가 존재하면 출발노드에서 목표노드까지 도달하는 최단길이 경로를 찾는 것을 보장
- 단점 : 너무 많은 노드가 생성되어서 비용이 많이 나감

##### 균일 비용 탐색
- 정의 : 한 상태에서 다른 상태로 이동하기 위해 필요한 비용을 기준으로 확장하여 목표를 탐색하므로 최소 비용 경로를 탐색할 수 있는 방법, 탐색 비용이 모두 동일하다면 너비 우선 탐색으로 작동
	- 다음 확장할 노드를 선택하는 기준  : 경로비용이 가장 적은 노드를 선택
	- 예시 
		- 출발노드 a로부터 노드 c, d, e, f, i, j, h까지 도달하는 경로의 비용은 각각 11, 13, 10, 13, 11, 9, 11이다. 균일비용 탐색에서는 그 노드까지의 경로비용이 가장 작은 노드를 확장하므로 다음 확장할 노드는 경로비용이 가장 작은(9) j이다.![[Pasted image 20230410025216.png]]

#### 경험적 탐색 heuristic search
- 문제 영역에서 사용할 수 있는 목표노드의 위치와 관련된 경험적 정보를 사용
- 경험적 정보 : 항상 옳은 것은 아니지만, 개연성이 있어 많은 경우 잘 맞는 정보
- 경험적 지식을 평가함수에 반영

- 경험적 탐색에서는 이미 거쳐온 비용(g)과 앞으로 거쳐갈 예측 비용($\hat{h}$)을 어떻게 사용하는 가에 따라서 알고리즘이 차이가 남 
- 연관 : [[인공지능#최적화 문제]]

##### 언덕오르기 탐색
- 가장 높은 평가함수나 가장 낮은 평가함수를 목표로 정해놓고 그곳을 향해 탐색을 하는 것을 언덕오르기  탐색이라고 함, 깊이 우선 탐색과 비슷한 순서로 탐색을 시작하지만, 후계노드의 평가함수를 계산해서 비용이 가장 적은 노드를 다음 확장할 노드로 선택함. 
  주의) 균일 비용탐색처럼 기존에 거쳐온 비용은 신경쓰지 않고 앞으로 예측한 비용만 고려

- 정의 : 임의의 상태에서 시작하여 가장 목표에 근접한 후계상태로 이동하는 탐색 알고리즘
	- 다음 확장할 노드를 선택하는 기준 : 후계노드의 평가함수를 계산하여 비용이 가장 적은 노드를 다음 확장할 노드로 선택함
	- 평가함수
		- 후계노드로부터 목표노드에 도달할 비용을 예측한 값
		- 후계노드까지 도달하는데 사용된 비용은 고려하지 않음
	- 가장 효율적인 경로라고 말하기는 어려움
- 예제 : 8-퍼즐 문제의 풀이
	  ![[Pasted image 20230410070148.png|300]]
	- 어떠한 상태의 비용 : 목표상태의 퍼즐과 비교했을 때 지정된 위치에 존재하지 않는 조각의 수
	- 그림을 보면 제 위치에 있지 않는 조각의 개수는 4개이므로 초기상태의 비용은 4이다. 이런 방식만 도입하지 않아도 되고, 알맞은 방법을 생각해서 평가함수에 도입하면 됨
	- 초기상태에서 노드를 확장하기
		  ![[Pasted image 20230410071757.png|400]]
		- 현재 확장한 값의 후계노드만 선택
		- 부모 노드와 동일한 값은 제외
		- 2번째 노드에서 2개의 노드가 앞으로의 평가비용이 동일하므로 임의로 정해서 진행하게 된다. 이 2개의 노드 중에서 오른쪽 노드가 더 빠른 평가비용을 갖지만 왼쪽 노드를 선택하여 진행하게 될 경우 언덕오르기 탐색은 이전 노드로 돌아가지 않기 때문에 효율적인 경로를 갖는 것이 어려움

##### 최적우선 탐색
- 정의 : 
	- 다음 확장할 노드를 선택하는 기준 : 
##### 모의 담금질 simulated annealing
- [[인공지능#최적화 문제|최적화 문제]]를 개선하기 위해서 제시된 방법
- 영어용어 해설
	- annealing(풀림) : 금속이나 유리를 일정한 온도로 가열한 다음에 천천히 식혀 내부 조직을 고르게 하고 응력(應力)을 제거하는 열처리 조작
- 정의 : 평가함수의 값이 전역 최소치(또는 전역최대치)에 해당되는 해를 구하기 위한 확률적 접근 방법으로 아래의 그림과 같이 지역최소치에 빠졌을 경우 그 상태에서 벗어나도록 도와주는 것을 말함 
	![[Pasted image 20230410074754.png|300]]![[Pasted image 20230410075008.png|300]]
	- 다음 확장할 노드를 선택하는 기준 : 
- 예시코드
```C
// temperature(t) : 시간 t에 따른 온도를 나타내며, t에 따라 서서히 감소하도록 함
// h(s) : 상태 s에 대한 평가함수
현재상태 <- 문제의 초기상태;
for t = 1 to do
	T = temperature(t);
	if T == 0 then
		return 현재상태;
	end-if
	차기상태 = 현재상태의 후계노드 중에서 임의로 선택;
	
```
![[Pasted image 20230410075755.png]]


##### A* 알고리즘
- 정의 : 다음 확장할 노드를 결정할 때 그 노드까지 도달하는 경로비용과 그 노드로부터 목표노드에 도달하기 위한 경로비용 예측치의 합이 최소인 노드를 선택하여 탐색하는 방법 
	- 다음 확장할 노드를 선택하는 기준 : open  리스트에서 $\hat{f}$(n)이 가장 작은 값
	- **평가함수** : 어떤 상태가 주어졌을 때 그 상태를 거쳐가는 것이 목표상태로 가는 데 얼마나 바람직한가를 나타내는 함수
		- 해를 향해가는데 필요한 비용, 해로 향하는 경로상에 존재할 가능성 등
	- **평가함수의 구성요소**
		   ![[Pasted image 20230410054629.png|150]]
		  출발노드 S에서 출발하여 노드 n까지 도착하였을 때, 노드 n의 평가함수의 정의에 포함될 수 있는 비용
		- g(n) : 출발노드 S로부터 현재 상태를 나타내는 노드 n까지 도달하는 데 소비한 경로비용
		- h(n) : 노드 n으로부터 목표노드 G까지 도달하는데 필요한 경로비용
		- $\hat{h}(n)$ : 경험적 지식을 이용하여 h(n)을 예측한 비용
			- 미래의 경로를 정확히 알지 못하기 때문에 나온 개념
		- 검색해봤더니 [[플랑크 상수]]라는 내용이 나오는데 이건 뭐지? #이해부족 
### 최적화 문제
- 예제 : 등산 문제의 풀이
	- 상태 : 등산사의 좌표 및 고도
	- 연산자 : 동서남북 방향으로 정해진 거리만큼 이동
	- 목표상태 : 모든 후계상태의 고도가 현재상태보다 낮은 상태
	- 최급 상승법을 적용하면 경사가 높아지는 곳으로 향하는 것을 말하고, 최급 하강법은 그의 반대를 말함
- 최급상승법 steepest ascent method 
	  ![[Pasted image 20230410072832.png]]
	- 최급상승법의 난제
		- 지역최대치의 문제(지엽최대치의 문제) : 지엽적으로 존재하는 최대치가 있을 때 그 부분에서 빠져나오지 못하는 문제로, 전체에서 가장 큰 최대치의 값을 구하지 못함
		- 고원 문제 : 주변의 모든 것이 평평하여 어디로 가야할지 갈피를 잡지 못하는 문제
		- 능선문제 : 연산자의 해상도 문제로 인해여 놓치는 부분이 있을 경우의 문제
- 최급 하강법 steepest disascent method :  비용이 가장 적게 드는 방법을 찾고 싶을 경우 

# 연관문서