# SQL 응용 / 활용
## 1. 데이터베이스 설계 ⭐⭐
>[!summary] p.298

1. 데이터베이스 설계 시 고려사항
	- 무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장
2. 데이터베이스 설계 순서 ⭐⭐ __ 20년 1, 2회 기출문제
	- | --- | --- |
	- #요개논물구

## 2. 데이터 모델 ⭐⭐
>[!summary] p.302, 3-59

1. 데이터 모델의 구성 요소 #개속관
	- 개체(Entity): 데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
	- **속**성(Attribute): 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
	- **관**계(Relationship): 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미
2. 개념적 데이터 모델
	- 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
		- 산출물 : E-R(Entity-Relation) 모델
3. 논리적 데이터 모델 __ 3-62
	- 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
	- 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미
		- 산출물 : 관계 모델, 계층 모델, 네트워크 모델
4. 데이터 모델에 표시할 요소 ⭐ #구연제
	- 구조(Structure): 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현
	- **연**산(Operation): 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구
	- **제**약 조건(Constraint): DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

## 3. 개체(Entity) ⭐
>[!summary] p.305

1. 개체의 정의 및 특징
	- 실세계에 독립적으로 존재하는 유형, 무형의 정보로 서로 연관된 몇 개의 속성으로 구성됨
	- 데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
	- 독립적으로 존재하거나 그 자체로서도 구별 가능
	- 유일한 식별자(Unique Identifier)에 의해 식별 가능
	- 다른 개체와 하나 이상의 관계(Relationship)가 있음
2. 개체 선정 방법
	- 실제 업무를 담당하고 있는 담당자와 인터뷰를 함
	- 실제 업무에 사용되고 있는 장부와 전표를 이용
	- 자료 흐름도(DFD; Data Flow Diagram)를 통해 업무 분석을 수행했을 경우 자료 흐름도의 자료 저장소(Data Store)를 이용함
	- BPR(Business Process Reengineering, 업무 프로세스 재설계)에 의해 업무를 재정의한 경우 관련 개체를 찾음
3. 개체명 지정 방법
	- 일반적으로 해당 업무에서 사용하는 용어로 지정
	- 약어 사용은 되도록 제한
	- 가능하면 단수 명사 사용
	- 모든 개체명은 유일해야 함
	- 가능하면 개체가 생성되는 의미에 따라 이름 부여 
	  ex) 교수, 고객, 주문, 도시 등

## 4. 속성(Attribute) ⭐
>[!summary] p.307

1. 속성의 정의 및 특징
	- 데이터베이스를 구성하는 가장 작은 논리적 단위
	- 파일 구조상의 데이터 항목 또는 데이터 필드
	- 개체를 구성하는 항목 및 개체의 특성을 기술
	- **속성의 수**를 디그리(Degree) 또는 차수라고 함 ⭐
	- cf) **튜플(Tuple)의 수**는 카디널리티(Cardinality) ⭐
2. 속성의 특성에 따른 분류
	- | --- | --- | #기설파
3. 개체 구성 방식에 따른 분류
	- | --- | --- |
4. 속성명 지정 원칙
	- 해당 업무에서 사용하는 용어 지정
	- 서술형으로 지정하지 않음
	- 가급적 약어의 사용은 제한
	- 개체명은 속성명으로 사용할 수 없음
	- 개체에서 유일하게 식별 가능하도록 지정
## 5. 관계(Relationship) ⭐
>[!summary] p.310

1. 관계의 형태
	- 일 대 일(1:1): 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계
	- 일 대 다(1:N): 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고 있지만, 개체 집합 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계
	- 다 대 다(N:M): 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고, 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계
2. 관계의 종류 #종중재배
	- 종속(Dependant) 관계
	- 중복(Redundant) 관계
	- 재귀(Recursive) 관계
	- 배타(Exclusive) 관계

## 6. 식별자(Identifier) ⭐
>[!summary] p.313

- 하나의 개체 내에서 각각의 인스턴스를 유일(Unique)하게 구분할 수 있는 구분자
- 모든 개체는 한 개 이상의 식별자를 반드시 가져야 함
	- | --- | --- | --- |

## E-R(개체-관계) 모델 ⭐⭐
>[!summary] p.319, 3-60

1. 개요
	- 개념적 데이터 모델의 가장 대표적인 것
	- 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적인 구성 요소가 정립됨
	- 데이터를 **개**체(Entity), **속**성(AttributE), **관**계(Relationship)으로 묘사
	- 특정 DBMS를 고려한 것은 아님
	- E-R 다이어그램으로 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타냄
2. 피터 첸 표기법 ⭐ __ 20년 1, 2회 기출문제
   ![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%203%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%86%E1%85%AE%E1%84%85%201a1c1c31c4dc405dad9b50753588a4bc/image2.png|400](99.%20기타/정보처리기사/정보처리기사%20필기,%203과목%20데이터베이스%20구축%20무ᄅ%201a1c1c31c4dc405dad9b50753588a4bc/image2.png)
	- 이중 타원 다중 값 속성(복합속성)
3. 정보 공학 표기법(Information Engineering Notation, 크로우즈 핏)
	- 1981년 클리프 핀켈쉬타인(Clive Finkelstein)과 제임스 마틴(James Maritn)이 공동 개발
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%203%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%86%E1%85%AE%E1%84%85%201a1c1c31c4dc405dad9b50753588a4bc/image3.jpeg](image3.jpeg)
| --- | --- |
- 실선은 1개를 의미, 까마귀 발은 N개를 의미함

- 원형 표시는 선택적 의미를 지니는데 관계가 있을 수도, 없을 수도 있다는 것
4. 바커 표기법(Barker Notation)
- 영국 컨설팅 회사 CACI에서 개발, 리차드 바커(Richard Barker)에 의해 정립


![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%203%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%86%E1%85%AE%E1%84%85%201a1c1c31c4dc405dad9b50753588a4bc/image4.jpeg](image4.jpeg)

| --- | --- |
# 논리 / 물리 데이터베이스 설계
## 1. 관계형 데이터 모델 ⭐⭐
>[!summary] p.322, 3-28

1. 개요 ⭐
	- 2차원적인 표(Table)를 이용해 데이터 상호 관계를 정의하는 DB 구조
	- 기본 키(Primary Key)와 이를 참조하는 외래 키(Foreign Key)로 데이터 간의 관계를 표현
	- 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
	- 관계형 모델의 대표적인 언어는 SQL이고 1:1, 1:N, N:M 관계를 자유롭게 표현
2. 관계형 데이터 모델(Relational Data Model)의 구성
	- <고객> 테이블에 있는 ‘고객번호’와 <주문서>테이블에 있는 ‘주문번호’는 “기본 키”
	- <주문> 테이블에 있는 ‘고객번호’, ‘주문번호’는 기본 키를 참조하고 있는 “외래 키”
	- <고객> 테이블과 <주문> 테이블의 관계는 1:N
		- 산출물 : 즉 한 명의 고객은 여러 개의 주문을 신청할 수 있음
	- <주문서> 테이블과 <주문> 테이블의 관계는 1:1
		- 산출물 : 즉 주문서는 주문번호 1개에 대한 정보만을 가짐

## 2. 관계형 데이터베이스의 구조 ⭐⭐
>[!summary] p.325, 3-51

1. 관계형 데이터베이스의 Relation 구조 ⭐⭐
	- 1970년 IBM에 근무하던 코드(E. F. Codd)에 의해 처음 제안됨
	- 튜플(Tuple), 행(Row), 레코드(Record)
		- 속성의 모임으로 구성됨
		- 파일 구조상 레코드(실제 데이터)와 같은 의미
		- **튜플의 수** = 카디널리티(Cardinality) 또는 기수, 대응수 ⭐
	- 속성(Attribute), 열(Column), 필드(Field)
		- 데이터베이스를 구성하는 가장 작은 논리적 단위
		- 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
		- 개체의 특성을 기술
		- **속성의 수** = 디그리(Degree) 또는 차수 ⭐
	- 도메인(Domain) ⭐ __ 20년 1, 2, 3회 기출문제
		- 하나의 속성(Attribute, 애트리뷰트)이 가질 수 있는 같은 타입 원자(Atomic)값들의 집합ex) 성별 속성(Attribute)의 도메인은 ‘남’, ‘여’로 그 외의 값은 입력될 수 없음(일반적)
2. 릴레이션의 특징 ⭐ __ 20년 3회 기출문제
	- 한 릴레이션(테이블)에 포함된 튜플(행)들은 모두 상이함, 즉 서로 다른 값을 갖음
	- 한 릴레이션(테이블)에 포함된 튜플(행) 사이에는 순서가 없음
	- 릴레이션 스키마를 구성하는 애트리뷰트(열) 간의 순서는 중요하지 않음
	- 각 애트리뷰트는 식별을 위해 릴레이션 내에서 유일한 이름을 가짐, 그러나 그에 해당하는 도메인(애트리뷰트를 구성하는 값)에는 동일한 값이 있을 수 있음
		- ex) ‘학년’ 속성에는 1, 2, 3, 4 값이 중복될 수 있음
		- 애트리뷰트는 논리적으로 더 이상 쪼갤 수 없는 원자 값으로 저장함
- **정리**
	1. **튜플**은 서로 상이한 값을 갖고, 순서가 없음
	2. **애트리뷰트**는 원자 값을 가지고, 순서가 중요하지 않으며, 유일한 이름을 가짐

## 3. 키(Key) ⭐⭐
>[!summary] p.328

- 데이터베이스에서 튜플들을 서로 구분할 수 있는 기준이 되는 속성(Attribute)
1. 후보키(Candidate Key) ⭐ __ 20년 1, 2회 기출문제
	- 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들, 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재
	- 릴레이션에 있는 모든 튜플에 대해 **유일성**과 **최소성**을 만족시켜야 함 ⭐
	- **유일성**(Unique): 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함
	- **최소성**(Minimality): 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야 함
2. 기본키(Primary Key)
	- 후보키 중에서 특별히 선정된 주키(Main Key)로, 중복된 값과 NULL값을 가질 수 없음
	- 후보키의 성질인 유일성과 최소성을 가지며 튜플을 식별하기 위해 반드시 필요한 키
3. 대체키(Alternate Key)
	- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미
4. 슈퍼키(Super Key) ⭐
	- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
	- 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함
5. 외래키(Foreign Key) ⭐ __ 20년 1, 2회 기출문제
	- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

- 참조되는 릴레이션의 기본키와 대응돼 릴레이션 간의 참조 관계를 표현
## 4. 무결성(Integrity) ⭐⭐
>[!summary] p.331, 3-94

- 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성을 의미
1. 개체 무결성(Entity Integrity, 실체 무결성) ⭐ __ 20년 1, 2, 3회 기출문제
- 테이블의 기본키를 구성하는 어떤 속성(Attribute)도 널(NULL)값이나 중복 값을 가질 수 없음

- 기본키의 속성 값이 널(NULL)값이 아닌 원자 값을 갖는 성질
2. 도메인 무결성(Domain Integrity, 영역 무결성)
- 릴레이션 내의 튜플들이 각 속성(Attribute)의 도메인에 지정된 값 만을 가져야 함

3. 참조 무결성(Referential Integrity) ⭐
- 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함

- 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
4. 사용자 정의 무결성(User-Defined Integrity)
- 속성 값들이 사용자가 정의한 제약 조건에 만족해야 함

5. 데이터 무결성 강화
- 애플리케이션: 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가

- 데이터베이스 트리거: 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가
- 제약 조건: 데이터베이스에 제약 조건을 설정해 무결성을 유지
## 5. 관계대수 및 관계해석 ⭐⭐⭐
>[!summary] p.334, 3-52

1. 관계대수 ⭐⭐ __ 20년 1, 2, 3회 기출문제
- 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게(How) 유도하는가를 기술하는 절차적인 언어


- 순수관계 연산자

| --- | --- | --- |
#셀프조디


- 일반집합 연산자

| --- | --- | --- |
#합교차카

2. 관계해석(Relational Calculus) __ 3-54
- 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안

- 원하는 정보가 무엇(What)이라는 것만 정의하는 비절차적 특성
- 튜플 관계해석, 도메인 관계해석
- 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력면에서 동등
- 관계대수로 표현한 식은 관계해석으로 표현할 수 있음
| --- | --- | --- | --- |
3. 관계대수와 관계해석 비교 ⭐
| --- | --- | --- |
## 6. 정규화(Normalization), 반정규화(Denormalization) ⭐⭐
>[!summary] p.341, 3-63, 3-100

- 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정
- 데이터베이스의 논리적 설계 단계에서 수행
1. 정규화의 목적 ⭐ __ 20년 3회 기출문제
- 데이터 구조의 안정성 및 무결성을 유지
- 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만듦
- 효과적인 검색 알고리즘 생성 가능
- 데이터 중복을 배제해 **이상(Anomaly)**의 발생 방지 및 자료 저장 공간의 최소화
- 개체와 속성의 누락 여부 확인 가능
- 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임
2. 이상(Anomaly)의 개념 및 종류 ⭐ __ 20년 3회 기출문제
- 정규화를 거치지 않아 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못하게 발생하는 곤란한 현상


- **삽**입 이상(Insertion Anomaly): 릴레이션에 데이터를 삽입할 때 의도와 상관없이 원하지 않은 값들도 함께 삽입되는 현상

- **삭**제 이상(Deletion Anomaly): 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상

- **갱**신 이상(Update Anomaly): 릴레이션에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상

#삽삭갱

3. 정규화의 원칙
- 정보의 무손실, 분리의 원칙, 데이터의 중복성 감소

4. 정규화 과정 ⭐⭐ __ 20년 1, 2, 3회 기출문제
| --- | --- |
#원부이결다조

5. 반정규화 개념 ⭐
- 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위 ⭐⭐

- 그러나 데이터의 일관성 및 정합성이 저하될 수 있음
6. 반정규화 방법 __ 20년 1, 2회 기출문제
- 테이블 통합: 1:1 관계 | 1:N 관계 | 슈퍼타입/서브타입 {테이블 통합}

- 테이블 분할: 수평 분할, 수직 분할 → 기본키의 유일성 관리가 어려워짐
- 중복 테이블 추가: **집**계 테이블 | **진**행 테이블 | **특**정 부분만을 포함하는 테이블 {추가}
#집진특⭐
- 중복 속성 추가: 자주 사용하는 속성을 하나 더 추가하는 것
## 7. 시스템 카탈로그(System Catalog) ⭐⭐
>[!summary] p.346, 3-32, 3-54

1. 시스템 카탈로그의 의미 ⭐
	- 사용자를 포함해 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
	- 좁은 의미로는 카탈로그를 데이터 사전(Data Dictionary)이라고도 함
	- 시스템 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 함
2. 카탈로그의 특징
	- 일반 이용자도 SQL을 이용해 내용을 검색할 수 있음
	- INSERT, DELETE, UPDATE문으로 카탈로그를 갱신할 수 없음 ⭐
	- DBMS에 따라 상이한 구조를 갖음
	- 카탈로그는 DBMS가 스스로 생성하고 유지함
	- 사용자가 SQL문을 실행시켜 변화를 주면 시스템이 자동으로 갱신함
3. 데이터 디렉터리(Data Directory, 사전 관리기)
	- 데이터 사전(Data Dictionary)에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템
	- 시스템만 접근할 수 있음
		- cf) 시스템 카탈로그(데이터 사전): 사용자와 시스템 모두 접근할 수 있음

## 8. 데이터베이스 저장 공간 설계 ⭐
>[!summary] p.366

1. 테이블(Table) __ 3-31
	- 데이터베이스의 가장 기본적인 객체로 행(Row, 튜플), 열(Column, 컬럼)로 구성
	- 논리 설계 단계의 개체(Entity)에 대응하는 객체
2. 클러스터드 인덱스 테이블(Clustered Index Table)
	- 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블
	- 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축됨
3. 파티셔닝 테이블(Partitioning Table) __ 20년 3회 기출문제
	- 대용량의 테이블을 작은 논리적 단위인 파티션으로 나는 테이블
	- 파티션 키를 잘못 구성하면 성능 저하 등의 역효과 초래
		- | --- | --- |
		- #레해리컴
	- 파티션의 장점
		- 성능 향상, 가용성 향상, 백업 가능, 경합 감소 #성가백합
4. 외부 테이블(External Table)
	- 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일
		- 산출물 : 데이터 웨어하우스(Data Warehouse), ETL(Extraction, Transformation, Loading)
5. 임시 테이블(Temporary Table)
	- 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
	- 임시테이블에 저장된 데이터는 트랜잭션이 종료되면 삭제됨
	- 절차적인 처리를 위해 임시로 사용하는 테이블
6. 컬럼(Column, 열)
	- 가변 길이 데이터 타입: 예상되는 최대 길이로 정의
	- 고정 길이 데이터 타입: 최소 길이로 지정
	- 소수점 이하 자릿수: 소수점 이하 자릿수는 반올림되어 저장
	- 고정 길이 컬럼이고 NOT NULL인 컬럼: 앞 쪽
	- 가변 길이 컬럼, NULL값이 많을 것으로 예상되는 컬럼: 뒤 쪽
7. 테이블스페이스(Tablespace)
	- 테이블이 저장되는 논리적인 영역
	- 테이블을 저장하면 논리적으로는 테이블스페이스에 저장되고, 물리적으로는 해당 테이블스페이스와 연관된 데이터 파일(Data File)에 저장됨
	- 테이블스페이스 설계 시 고려사항
		- 업무별로 구분해 지정하고, 테이블과 인덱스는 분리해 저장함
		- 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장함
		- LOB(Large Object) 타입의 데이터는 독립적인 공간으로 지정함

## 9. 트랜잭션(Transaction) ⭐⭐⭐
>[!summary] p.371, 3-29

1. 트랜잭션의 정의 ⭐ __ 20년 3회 기출문제
	- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
	- 한꺼번에 모두 수행되어야 할 일련의 연산들
	- **COMMIT**: 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어
	- **ROLLBACK**: 트랜잭션 처리가 비정상으로 종료되어 DB의 일관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산
	- SAVEPOINT(=CHECKPOINT): 트랜잭션 내에서 ROLLBACK할 위치인 저장점을 지정하는 명령어, 여러 개의 SAVEPOINT 지정 가능
	- COMMIT과 ROLLBACK 명령어에 의해 보장 받는 트랜잭션 특징 = **원자성 ⭐**
2. 트랜잭션의 특성 ⭐⭐ __ 20년 1, 2회 기출문제
	- | --- | --- |
	- #ACID
3. CRUD 매트릭스 __ 3-104
	- Create, Read, Update, Delete, ‘C > D > U > R’의 우선순위 적용
	- 테이블, 프로세스에 C, R, U, D가 모두 없는 경우
	- 테이블에 C 또는 R이 없는 경우 (프로세스는 하나만 있어도 돌아감)

## 10. 인덱스(Index) ⭐
>[!summary] p.375, 2-15, 3-38

1. 인덱스의 개념 및 선정기준, 고려사항
	- 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터>쌍으로 구성된 데이터 구조
	- 인덱스 컬럼 선정 ⭐
		- 인덱스 컬럼의 분포도(Selectivity)가 10~15% 이내인 “컬럼”
		- 가능한 한 수정이 빈번하지 않는 “컬럼”
		- ORDER BY, GROUP BY, UNION이 빈번한 “컬럼”
		- 분포도가 좋은 컬럼은 단독 인덱스로 생성
		- 인덱스들이 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성
	- 설계 시 고려사항 ⭐
		- 새로 추가되는 인덱스는 기존 엑세스 경로에 영향을 미칠 수 있음
		- 지나치게 많은 인덱스는 오버헤드(Overhead) 발생
		- 넓은 범위 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킴
		- 인덱스만의 추가적인 저장 공간이 필요
		- 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계
2. 인덱스 종류
	- 클러스터드 인덱스(Clustered Index) / 넌클러스터드 인덱스(Non-Clustered Index)
	- **트리 기반 인덱스**: 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
	- **비트맵 인덱스**: 인덱스 컬럼의 데이터를 Bit 값인 0, 1로 변환해 인덱스 키 사용
	- **함수 기반 인덱스**: 컬럼에 특정 함수나 수식을 적용해 산출된 값을 사용하는 것
	- **비트맵 조인 인덱스**: 다수의 조인된 객체로 구성된 인덱스
	- **도메인 인덱스**: 개발자가 필요한 인덱스를 직접 만들어 사용하는 것 (확장형 인덱스)

## 11. 뷰(View) ⭐⭐
>[!summary] p.380, 2-16, 3-36, 3-55

1. 뷰의 개요 및 특징
	- 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블로 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같음
	- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않지만 사용자에게 있는 것처럼 간주됨 → 저장장치 내에 논리적으로 존재
	- 정의된 뷰로 다른 뷰를 정의할 수 있음
	- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨
	- | --- | --- |
2. 뷰의 장, 단점 ⭐ __ 20년 1, 2, 3회 기출문제
	- 장점
		- 논리적 데이터 독립성 제공
		- 접근 제어를 통한 자동 보안 제공
		- 사용자 데이터 관리 용이
	- 단점
		- 독립적인 인덱스를 가질 수 없음
		- 뷰의 정의를 ALTER로 변경할 수 없음 → DROP하고 새로 CREATE해야 함
		- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름

## 12. 클러스터(Cluster) ⭐
>[!summary] p.383, 2-16, 3-87

1. 클러스터의 개요 및 특징 ⭐
	- 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법
	- 인덱스의 단점을 해결한 기법 → 분포도(Selectivity)가 넓을수록 오히려 유리함
	- 분포도가 넓은 “테이블”의 클러스터링은 저장 공간의 절약이 가능
	- 대량의 범위를 자주 액세스(조회)하는 경우 적용
	- 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용
2. 클러스터의 선정기준 및 고려사항
	- 클러스터 테이블 선정
		- 수정이 빈번하지 않는 “테이블”
		- ORDER BY, GROUP BY, UNION이 빈번한 “테이블”
		- 처리 범위가 넓어 문제가 발생하는 경우 단일 테이블 클러스터링 사용
		- 조인이 많아 문제가 발생되는 경우는 다중 테이블 클러스터링 사용
	- 설계 시 고려사항
		- 클러스터링 된 테이블은 조회 속도를 향상시켜주지만 입력, 수정, 삭제 시 성능이 저하됨(부하가 증가)
		- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋음
		- 클러스터링 된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상됨

## 13. 분산 데이터베이스 설계 ⭐⭐
>[!summary] p.390, 3-77

1. 분산 데이터베이스 정의
- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site)에 분산돼 있는 데이터베이스

2. 분산 데이터베이스의 구성 요소
| --- | --- |
3. 분산 데이터베이스의 목표 ⭐⭐ __ 20년 1, 2, 3회 기출문제
| --- | --- |
#위복병분장

4. 분산 데이터베이스의 장, 단점
| --- | --- |
5. 분산 데이터베이스 설계
- 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적


- 분산 설계 방법

- 테이블 위치 분산: 테이블을 각기 다른 서버에 분산시켜 배치하는 방법
- **분할**(Fragmentation): 테이블의 데이터를 분할하여 분산시키는 것
- **할당**(Allocation): 동일한 분할을 여러 개의 서버에 생성하는 방법
	- 산출물 : 중복이 없는 할당, 중복이 있는 할당
## 14. 데이터베이스 이중화 / 서버 클러스터링 ⭐
>[!summary] p.394, 3-78

1. 데이터베이스 이중화(Database Replication)
- 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제해 관리하는 것

2. 데이터베이스 이중화의 분류
| --- | --- |
3. 데이터베이스 이중화 구성 방법
| --- | --- |
4. 서버 클러스터링(Server Clustering)
- 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
**▶** **고가용성 클러스터링**: 하나의 서버에 장애 발생 → 다른 서버가 대신 처리
**▶** **병렬 처리 클러스터링**: 하나의 작업을 여러 개의 서버에 분산해 처리
## 15. 데이터베이스 보안 / 스토리지 ⭐⭐
>[!summary] p.397~407, 3-79

1. 데이터베이스 보안의 개요
- 데이터베이스 일부분 또는 전체에 대해서 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술

- 데이터베이스 사용자들은 일반적으로 서로 다른 객체에 대해 다른 접근 권리 또는 권한을 가짐
2. 암호화(Encryption)
- 암호화(Encryption) 과정
- 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정
	- 산출물 : 개인키 암호 방식(대칭키), 공개키 암호 방식(비대칭키)
- 복호화(Decryption) 과정
- 암호문을 원래의 평문으로 바꾸는 과정
3. 암호화 방식
| --- | --- | --- |
4. 접근통제 __ 5-86
- 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것

- 접근통제 3요소: 접근통제 **정**책, 접근통제 **보**안모델, 접근통제 메**커**니즘
#정보커
- 임의 접근통제(DAC; Discretionary Access Control)
-데이터에 접근하는 사용자의 신원에 따라 접근 권한 부여
	- 산출물 : 접근통제 권한=주체

- 강제 접근통제(MAC; Mandatory Access Control)
-주체와 객체의 등급을 비교해 접근 권한 부여
	- 산출물 : 접근통제 권한=제3자

5. 접근통제 정책
| --- | --- |
6. 접근통제 메커니즘 ⭐
- 접근통제 목록(ACL; Access Control List): 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지를 기록한 목록


- 능력 리스트(**CL**; Capability List): 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록

- 보안 등급(Security Label), 패스워드, 암호화

7. 접근통제 보안 모델
- 기밀성 모델: 군사적인 목적으로 개발된 최초의 수학적 모델, 기밀성 보장 최우선
	- 산출물 : 벨라파듈라 모델: No Read UP(기밀성), No Write Down

- 무결성 모델: 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델
	- 산출물 : 비바 모델: No Read Down, No Write Up(무결성)
- 접근통제 모델: 접근통제 메커니즘을 보안 모델로 발전시킨 것
	- 산출물 : 접근통제 행렬(Access Control Matrix): 행=주체, 열=객체
8. 데이터베이스 백업 종류 __ 3-88, 5-51
| --- | --- | --- |
- **로그 파일**: 데이터베이스의 상태 변화를 시간의 흐름에 따라 모두 기록한 파일
9. 스토리지(Storage) __ 3-75, 5-49
| --- | --- | --- | --- |
#다나쓰
## 16. 논리 데이터 모델의 물리 데이터 모델 변환 및 품질 검토 ⭐
>[!summary] p.410~418, 2-13

1. 일반적인 변환 절차
- 단위 개체를 테이블로 변환 → 속성을 컬럼으로 변환 → UID(Unique Identifier)를 기본 키(Primary Key)로 변환 → 관계를 외래 키(Foreign Key)로 변환 → 컬럼 유형(Type)과 길이(Length) 정의 → 반정규화(De-normalization) 수행

2. 슈퍼타입/서브타입을 테이블로 변환
-슈퍼타입 기준 테이블 변환: 서브타입을 슈퍼타입에 통합해 하나의 테이블로 만드는 것

- 서브타입 기준 테이블 변환: 슈퍼타입 속성들을 각각의 서브타입에 추가해 서브타입들을 개별적인 테이블로 만드는 것
- 개별타입 기준 테이블 변환: 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것
3. 물리 데이터 모델 품질 기준 (=논리 데이터 모델 품질 기준) __ 3-70, 3-102
| --- | --- |
#정완준_최일활
SQL 응용 ⭐⭐⭐
>[!summary] p.426~4, 3-8


- 1974년 IBM 연구소에서 개발한 SEQUEL에서 유래함
- 관계대수와 관계해석을 기초로 한 혼합 데이터 언어
1. SQL(Structured Query Language)의 분류 ⭐⭐ __ 20년 1, 2회 기출문제
- DDL(Data Define Language, 데이터 정의어) __ 3-26

- DOMAIN(**도**메인), SCHEMA(**스**키마), TABLE(**테**이블), VIEW(**뷰**), INDEX(**인**덱스)를 **정의**하거나 **변경** 또는 **삭제**할 때 사용하는 언어

#도스테뷰인

| --- | --- |
- DML(Data Manipulation Language, 데이터 조작어) ⭐ __ 3-13, 1, 2회 기출문제

- 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 처리하는 데 사용하는 언어
| --- | --- |
- DCL(Data Control Language, 데이터 제어어) __ 3-15, 20년 1, 2, 3회 기출문제

- 데이터의 무결성, 보안, 회복, 병행수행 제어 ⭐ 등을 정의하는 데 사용되는 언어
- 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용
| --- | --- |
ex) GRANT UPDATE ON 고객(테이블) TO 홍길동 WITH GRANT OPTION;
ex) REVOKE GRANT OPTION FOR UPDATE ON 고객(테이블) FROM 홍길동 CASCADE;
2. SELECT __ p.444~453 ⭐ __ 20년 1, 2, 3회 기출문제
- **WHERE**절: 검색할 조건을 기술
- ORDER BY절: 특정 속성을 기준으로 정렬해 검색할 때 사용
	- 산출물 : ASC(오름차순), DESC(내림차순) – 따로 설정이 없을 때는 기본적으로 ASC 사용


- **GROUP BY**절: 특정 속성을 기준으로 그룹화해 검색할 때 사용, 일반적으로 그룹 함수와 함께 사용

- **HAVING**절: GROUP BY와 함께 사용되며, 그룹에 대한 조건 지정

- **DISTINCT**: 중복 튜플 제거 ⭐

- **집계/그룹함수**: GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술함

| --- | --- |
- 윈도우 함수: GROUP BY절을 이용하지 않고 속성의 값을 집계할 함수를 기술함

- 함수의 인수로 지정한 속성이 대상 레코드의 범위가 되는데, 이를 WINDOW라 함

	- 산출물 : PARTITION BY: 윈도우 함수가 적용될 범위로 사용할 속성 지정
→ WINDOW 함수 OVER (PARTITION BY 속성 ORDER BY 속성) [AS 바꾸고 싶은 이름]

| --- | --- |
3. 조인(JOIN) __ p.461, 3-43
- 결합을 의미하며, 관계형 데이터베이스에서의 조인은 교집합 결과를 가지는 결합 방법을 의미

- 두 릴레이션으로부터 연관된 튜플들을 결합해, 하나의 새로운 릴레이션을 반환

- 논리적 조인

| --- | --- | --- |
#동자교


- 물리적 조인

| --- | --- |
#네소해

SQL 활용 ⭐⭐
>[!summary] p.476~484

1. 절차형 SQL
- C, JAVA 등의 프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL

- 일반적인 프로그래밍 언어에 비해 효율이 떨어지지만, 연속적인 작업 처리 적합
- BEGIN ~ END 형식으로 작성되는 블록(Block) 구조로 기능별 모듈화 가능
2. 프로시저(Procedure) #디비컨SET
- 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업 수행, 처리 결과는 한 개 이상의 값 혹은 반환을 아예 하지 않음

- 시스템의 일일 마감 작업, 일괄(Batch) 작업 등에 주로 사용됨

**DECLARE**(필수): 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 **선**언부

**BEGIN**(필수): 프로시저의 시작을 의미, **실**행부

**CON**TROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨

**S**QL: DML, DCL이 삽입되어 데이터 관리를 위한 작업 수행 ⭐

**E**XCEPTION: BEGIN ~ END 안의 구문 실행 시 **예**외가 발생하면 이를 처리

**T**RANSACTION: 수행된 데이터 작업들을 DB에 적용할지 말지 결정하는 처리부

**END**(필수): 프로시저의 종료를 의미, BEGIN/END는 함께 다님

→ **CREATE** [OR REPLACE] **PROCEDURE** 프로시저명([[파라미터]]) [지역변수 선언]

BEGIN
프로시저 BODY;

**END**;
* OR REPLACE: 선택적인 예약어, 동일한 프로시저 이름이 이미 존재하는 경우 기존의 프로시저를 대체할 수 있음


- **EXECUTE, EXEC, CALL** 프로시저명; / **DROP** PROCEDURE 프로시저명;

3. 트리거(Trigger) __ 3-2, 20년 1, 2회 기출문제 #디이비컨SE
- 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관력 작업을 자동 수행 ⭐
- 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용됨

- DCL(데이터 제어어)을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류 발생
- 트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향을 미치므로 트리거를 생성할 때 세심한 주의가 필요

**DECLARE**(필수): 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의하는 **선**언부

**EVENT**(필수): 트리거가 실행되는 조건을 명시

**BEGIN**(필수): 트리거의 시작을 의미, **실**행부

**CON**TROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨

**S**QL: DML문이 삽입되어 데이터 관리를 위한 작업 수행 ⭐

**E**XCEPTION: BEGIN ~ END 안의 구문 실행 시 **예**외가 발생하면 이를 처리

**END**(필수): 트리거의 종료를 의미, BEGIN/END는 함께 다님

→ **CREATE** [OR REPLACE] **TRIGGER** 트리거명 [동작시기 옵션][동작 옵션] ON 테이블명

**REFERENCING**[NEW | OLD] AS 테이블명

**FOR EACH ROW** [WHEN 조건식]

BEGIN
트리거 BODY;


**END**;

- 동작시기 옵션: AFTER(테이블이 변경된 후 트리거 실행), BEFORE(변경되기 전 실행)
- NEW | OLD: NEW(추가되거나 수정에 참여할 테이블), OLD(수정되거나 삭제 전 테이블)
- FOR EACH ROW: 각 튜플마다 트리거 적용
- DROP TRIGGER 트리거명;

3. 사용자 정의 함수 __ 3-5 #디비컨SER
- 프로시저와 유사하게 SQL을 사용해 일련의 작업을 연속적으로 처리

- 종료 시 예약어 RETURN을 사용해 처리 결과를 단일값으로 반환
- DML문(SELECT, INSERT, DELETE, UPDATE)의 호출에 의해 실행됨
- RETURN을 통해 값을 반환해, 출력(OUT) [[파라미터]]가 없음
- INSERT, DELETE, UPDATE로 테이블 조작은 할 수 없고, SELECT로 조회만 할 수 있음
- 프로시저를 호출해 사용할 수 없음 ⭐
| --- | --- | --- |
DECLARE(필수): 사용자 정의 함수의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부


**BEGIN**(필수): 사용자 정의 함수의 시작을 의미, **실**행부

**CON**TROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨

**S**QL: SELECT문이 삽입되어 데이터 관리를 위한 작업 수행 ⭐

**E**XCEPTION: BEGIN ~ END 안의 구문 실행 시 **예**외가 발생하면 이를 처리

**RETURN**(필수): 호출 프로그램에 반활할 값이나 변수를 정의 ⭐

**END**(필수): 사용자 정의 함수의 종료를 의미, BEGIN/END는 함께 다님

→ **CREATE** [OR REPLACE] **FUNCTION** 사용자 정의 함수명([[파라미터]]) [지역변수 선언]

BEGIN
사용자 정의 함수 BODY;


**RETURN** 반환값;

**END**;

DMBS 접속 기술 ⭐
>[!summary] p.489

1. 웹 응용 시스템의 구조
- 사용자 ←→ 웹 서버 ←→ WAS ←→ DBMS


	- 산출물 : 사용자는 웹 서버에 접속해 데이터를 주고 받고, 웹 서버는 WAS에게 해당 요청을 전달함, 그 다음 WAS는 수신한 요청을 트랜잭션 언어로 변환한 후 DBMS에 전달해 데이터를 받으면, 이 데이터를 다시 웹 서버로 전달해 사용자에게 도달하게 함

2. DBMS 접속 기술
- JDBC(Java Database Connectivity)

- 1997년 썬 마이크로시스템에서 출시, JAVA 언어로 다양한 종류의 데이터베이스에 접속하고 SQL문을 수행할 때 사용되는 표준 API
- 접속하려는 DBMS에 대한 드라이버가 필요

- ODBC(Open Database Connectivity)

- 1992년 마이크로소프트에서 출시, 데이터베이스에 접근하기 위한 표준 개방형 API로 개발 언어에 관계없이 사용 가능
- ODBC도 접속하려는 DMBS에 맞는 드라이버가 필요하지만, 접속하려는 DBMS의 인터페이스를 알지 못하더라도 ODBC 문장을 사용해 SQL을 작성하면 ODBC에 포함된 드라이버 관리자가 해당 DBMS의 인터페이스에 맞게 연결해줌

→ DBMS의 종류를 몰라도 됨

3. 정적 SQL vs 동적 SQL
| --- | --- | --- |
ORM(Object-Relational Mapping) ⭐
>[!summary] p.496

1. ORM의 개요
- 객체(Object)와 관계형데이터베이스(RDB)의 데이터를 연결(Mapping)하는 기술 ⭐

- ORM으로 생성된 가상의 객체지향 데이터베이스는 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수 용이
- 직관적이고 간단하게 데이터 조작 가능
2. ORM 프레임워크
| --- | --- |
3. ORM의 한계
- 프레임워크가 자동으로 SQL을 작성하기 때문에 의도대로 작성되었는지 확인해야 함
- 객체지향적인 사용 고려와 프로젝트가 크고 복잡해질수록 적용하기 어려워짐
- 기존의 기업들은 ORM을 고려하지 않은 데이터베이스를 사용하고 있기 때문에, ORM에 적합하게 변환하려면 많은 시간과 노력 필요

## 17. 쿼리 성능 최적화 ⭐
>[!summary] p.498, 3-107

- 데이터 입, 출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화하는 것
- 쿼리 성능 최적화하기 전, 성능 측정 도구인 APM(Application Performance Management)을 사용해 최적화 할 쿼리를 선정해야 함
- 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획(Execution Plan)을 EXPLAIN 명령어를 통해 검토하고, SQL 코드와 인덱스 재구성
	*옵티마이저(Optimizer): 작성된 SQL이 가장 효율적으로 수행되도록 최적의 경로를 찾아 주는 모듈

1. RBO(Rule Based Optimizer) vs CBO(Cost Based Optimizer)
	- | --- | --- | --- |
2. SQL 코드 및 인덱스 재구성
	- **SQL 코드 재구성**
		- 서브 쿼리에 특정 데이터가 존재하는지 확인 할 때는 IN보다 EXISTS 활용
		- 실행 계획이 잘못되었다고 판단되는 경우 힌트(Hint)를 활용해 변경
	- **인덱스 재구성**
		- 인덱스의 추가 및 변경은 해당 테이블을 참조하는 다른 SQL문에도 영향을 줄 수 있으므로 신중히 결정
		- 단일 인덱스로 쓰기나 수정 없이 일기로만 사용되는 테이블의 경우 IOT(Index-Organized Table) 구성 고려

# 데이터 전환 ⭐
>[!summary] p.508, 3-109

1. 데이터 전환의 정의
	- 운영 중인 기존 정보 시스템에 축적되어 있는 데이터를 추출(Extraction)하여 새로 개발할 정보 시스템에서 운영 가능하도록 변환(Transformation) 후, 적재(Loading)하는 일련의 과정
		- 산출물 : ETL(Extraction, Transformation, Loading): 추출, 변환, 적재 과정
		- 산출물 : **데이터 이행**(Data Migration), 데이터 이관이라고도 함
2. 데이터 전환 계획서
| --- | --- |
**추가 정리, 수제비 및 기출문제** ⭐⭐⭐
1. WHERE 조건 ⭐ __ 3-8, 20년 3회 기출문제
| --- | --- | --- |
2. LIKE와 같이 사용하는 와일드 문자 ⭐ __ 3-9
| --- | --- | --- |
3. 주석 처리 __ 3-9
| --- | --- |
4. 힌트의 사용 __ 3-9
- SQL 문에 사전 정보를 줘서, SQL문 실행에 빠른 결과를 가져오는 효과를 만드는 문법
| --- | --- |
5. 집합 연산자 __ 3-41
- 테이블을 집합 개념으로 보고, 두 테이블 연산에 집합 연산자를 사용하는 방식

- 여러 질의 결과를 연결해 하나로 결합하는 방식을 사용
| --- | --- |
6. 서브쿼리(Sub-Query) __ 3-46
- SQL문 안에 포함된 또 다른 SQL문

| --- | --- |
7. 데이터 지역화(Data Locality) ⭐ __ 3-91
- 데이터베이스의 저장 데이터를 효율적으로 이용할 수 있도록 저장하는 방법

- **구역성(Locality)**라고도 함

- 데이터 지역화의 종류

| --- | --- | --- |
#시공순


- 데이터 지역화를 활용한 관리 기법

| --- | --- |
8. 병행제어의 로킹(Locking) 단위 ⭐⭐ __ 개정 전 / 20_1, 2, 3회 / 21년 1회 기출문제
- 한번에 한 명만 사용할 수 있게 잠그는(Locking) 단위
- 로킹의 대상이 되는 객체의 크기를 로킹 단위라고 함
- 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
- 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
- **로킹 단위가 작으면 小**
- 로킹 오버헤드가 증가함
- 데이터베이스 공유도가 증가함 (= 병행성 수준이 높아짐)
- **로킹 단위가 크면 大**
- 로킹 오버헤드가 감소함
- 데이터베이스 공유도가 감소함 (= 병행성 수준이 낮아짐)
9. 데이터베이스 로그(log)를 필요로 하는 회복기법 __ 20년 3회 기출문제
#지RE 즉UN
- **지연 갱신 기법(Deferred Update)**
-트랜잭션이 부분 완료 상태에 이르기까지 발생한 모든 변경 내용을 로그 파일에만 저장하고, 데이터베이스에는 COMMIT이 발생할 때까지 저장을 지연하는 기법

- 트랜잭션이 실패할 경우 UNDO없이 로그 단순 폐기

	- 산출물 : REDO

- **즉시 갱신 기법(Immediate Update)**
-트랜잭션 수행 도중 데이터를 변경하면 변경 정보를 로그 파일에 저장하고, 부분 완료되기 전이라도 모든 변경 내용을 즉시 데이터베이스에 반영하는 기법

- 로그 파일을 참조해 **미완료된 변경**에 대해 **UNDO를 우선 실행**한 후, 완료된 변경에 대해 REDO 실행 (UNDO는 **COMMIT된 지점이 없음**)

	- 산출물 : UNDO

- **정보처리기사 실기, REDO/UNDO 기출문제**

![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%203%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%86%E1%85%AE%E1%84%85%201a1c1c31c4dc405dad9b50753588a4bc/image7.png](image7.png)
>