# 서버프로그램 구현
## 1. 개발 환경 구축 ⭐⭐
> p.534, 4-2
1) 개발 환경 구축의 개요
- 응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 하드웨어 및 소프트웨어 장비를 구축하는 것

- 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등의 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축함
2) 하드웨어 환경 ⭐
- 사용자와의 인터페이스 역할을 하는 클라이언트(Client)와 클라이언트와 통신하여 서비스를 제공하는 서버(Server)로 구성됨

- **클라이언트**: PC, 스마트폰 등
- **서버**: 웹 서버, 웹 애플리케이션 서버(WAS), 데이터베이스 서버, 파일 서버 등

-** **웹 서버**(Web Server) **__ 4-96

- 클라이언트로부터 직접 요청을 받아 처리하는 서버로, 저용량의 정적 파일들을 제공

	- 산출물 : Apache HTTP Server, Microsoft Internet Service, Google Web Server 등

-** 웹 애플리케이션 서버(**WAS**; Web Application Server) **⭐

- 정적인 콘텐츠를 처리하는 웹 서버(Web Server)와 반대됨
- 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어(=소프트웨어)
- 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공

	- 산출물 : Apache Tomcat, IBM WebSphere, Oracle WebLogic, JEUS, JBoss, Jetty, Resin 등등

-** **데이터베이스 서버**(Database Server) __ **4-98

- 데이터베이스와 이를 관리하는 DBMS를 운영하는 서버
	- 산출물 : MySQL Server, IBM WebSphere, Oracle WebLogic 등

**▶** **파일 서버**(File Server)

- 데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버

	- 산출물 : AWS S3 등

3) 웹 서버(Web Server)의 기능 __ 4-97
| --- | --- |
4) 소프트웨어 환경
- 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성됨

- **시스템 소프트웨어**: 운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS
- **개발 소프트웨어**: **요**구사항 관리 도구, **설**계/모델링 도구, **빌**드 도구, **구**현 도구, **테**스트 도구, **형**상 관리 도구 등

#요설_빌구테형

-** **요**구사항 관리 도구 **⭐

- 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어

	- 산출물 : JIRA, IMB DOORS, inteGREAT, Reqtify, Trello 등

**▶** **설**계/모델링 도구

- [[UML]]을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어

	- 산출물 : DB Designer, PlantUML, ArgoUML 등

-** **빌**드 도구 **⭐

- 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어

	- 산출물 : Ant, Maven, Gradle, Jenkins 등

-** **구**현 도구 **⭐

- 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어

	- 산출물 : Eclipse, IntelliJ IDEA, Visual Studio, Node.js 등

**▶** **테**스트 도구

- 모듈들이 요구사항에 적합하게 구현됐는지 테스트하는 소프트웨어

	- 산출물 : CppUnit, JUnit, HttpUnit, NUnit, SprintTest 등

-** **형**상 관리 도구 **⭐

- 산출물들을 버전별로 관리하여 품질 향상을 지원하는 스프트웨어

	- 산출물 : CVS, SVN(Subversion), GIT 등

5) 개발 언어의 선정 기준 ⭐⭐
| --- | --- |
#적효이친범

## 2. 서버 개발 ⭐
> p.537, 4-6
1) 서버 개발의 개요
- 웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 애플리케이션 서버(WAS)에 탑재하는 것을 의미함

- 서버 개발에 사용되는 프로그래밍 언어
	- 산출물 : JAVA, JavaScript, Python, PHP, Ruby등
2) 서버 개발 프레임워크 ⭐
* 프레임워크(Framework): ‘뼈대’, ‘골조’를 의미하는데, 소프트웨어에서는 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모아둔 집합체를 뜻함

- 대부분 MVC(Model, View, Controller) 패턴을 기반으로 개발됨
| --- | --- |
3) 서버 프로그램 구현(효과적인 모듈 설계) __ 4-9, 20년 3회 기출문제
- 응용 소프트웨어와 동일하게 모듈 및 공통 모듈을 개발한 후, 모듈들을 통합하는 방식으로 구현, 유지보수가 용이해야 함

- 모듈의 독립성을 높이려면 모듈의 결합도(Coupling)를 약하게 하고,
응집도(Cohesion)를 강하게 하며 모듈의 크기를 작게 만들어야 함 **⭐⭐**
- 복잡도와 중복성을 줄이고 일관성 유지
- 공통 모듈은 여러 프로그램에서 재사용(Reuse) 할 수 있는 모듈을 의미함
→ 함수와 객체 재사용, 컴포넌트 재사용, 애플리케이션 재사용
- **재사용 프로그래밍 기법**
- **객**체지향 프로그래밍, **제**네릭 프로그래밍, **자**동 프로그래밍, **메**타 프로그래밍
#객제자메
4) 프레임워크의 특성 ⭐⭐
| --- | --- |
#모재확역

\
5) 프레임워크의 구성요소 __ 4-7
- **개**발환경, **실**행환경, **운**영환경, **관**리환경
#개실운관

## 3. 보안 및 API ⭐⭐
> p.540, 4-16
1) 소프트웨어 개발 보안의 개요
- 소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여 보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 일련의 보안 활동을 의미


	- 산출물 : 시큐어 코딩(Secure Coding) **⭐**

- **기**밀성(Confidentiality), **무**결성(Integrity), **가**용성(Availability) 유지하는 것을 목표

#기무가⭐

- 정부에서 제공하는 소프트웨어 개발 보안 가이드를 참고하여 소프트웨어 개발 과정에서 점검해야 할 보안 항목들을 점검
2) 소프트웨어 개발 보안 점검 항목
| --- | --- |
#세입보시 에코캡아

**3) API(Application Programming Interface)** ⭐ __ 4-18
- 응용 프로그램 개발 시 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 함으로써 효율적인 소프트웨어 구현을 도와주는 인터페이스

- 개발에 필요한 여러 도구를 제공
- 누구나 무료로 사용할 수 있게 공개된 API를 Open API라고 함

	- 산출물 : Windows API, 단일 유닉스 규격(SUS), Java API, 웹 API 등

## 4. 배치 프로그램 ⭐⭐
> p.542, 4-21
1) 배치 프로그램(Batch Program)의 개요 ⭐ __ 20년 3회 기출문제
- 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것

| --- | --- |
#이온정

| --- | --- |
#대자견안성
2) 배치 스케줄러(Batch Scheduler), 잡 스케줄러(Job Scheduler)
- 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구
- **스프링 배치(Spring Batch)**: Spring 프레임워크의 특성을 그대로 가져와 스프링이 가지고 있는 다양한 기능들을 모두 사용할 수 있는 오픈 소스 프레임워크
	- 산출물 : 주요 구성 요소: Job, Job Launcher, Job Repository, Step
- **쿼츠(Quartz)**: Spring 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리
	- 산출물 : 주요 구성 요소: Job, Job Detail, Trigger, Scheduler
## 5. 패키지 소프트웨어 ⭐
> p.544, 4-101
1) 패키지 소프트웨어(Package Software)의 개요
- 기업에서 일반적으로 사용하는 여러 기능들을 통합하여 제공하는 소프트웨어

- 기업에서 패키지 소프트웨어를 구입해 기업 환경에 적합하게 커스터마이징 후 사용
- 기능 요구사항을 70% 이상 충족시키는 패키지 소프트웨어 사용
2) 패키지 소프트웨어 vs 전용 개발 소프트웨어
| --- | --- | --- |
# 프로그래밍 언어 활용
## 1. 데이터 타입 ⭐⭐
> p.552, 4-24, 20년 3회 기출문제
- 변수(Variable)에 저장될 데이터의 형식을 나타내는 것으로, 변수에 값을 저장하기 전에 문자형, 정수형, 실수형 등 어떤 형식의 값으로 저장할지 선언하는 것
| --- | --- | --- |
#불문열_정소배
- **C/C++의 데이터 타입 크기**
| --- | --- | --- |
## 2. 변수 ⭐⭐⭐
> p.555, 4-25
1) 변수(Variable)의 개요
- 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간으로, 변할 수 있는 값을 의미

2) 변수명 작성 규칙 ⭐ __ 20년 3회 기출문제
- 영문자, 숫자, _(under bar) 사용 가능 ⭐ → ex) a, A, a1, _, _korea (O) / text-color (X)

- 첫 글자는 영문자(대, 소문자), _(under bar)로 시작할 수 있으나, 숫자는 올 수 없음 **⭐**
- 글자 수에 제한이 없고, 대, 소문자 구분 → Kim, kim (O)
- 공백이나 *, +, -, / 등의 특수문자를 사용할 수 없음 **⭐** → ex) my student, $a, <a (X)
- 예약어를 변수명으로 사용할 수 없음 **⭐** → if, for, while (X)
- 변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 함
| --- | --- |
3) 예약어 – C언어
| --- | --- | --- |
4) 기억 클래스
- 변수 선언 시 메모리 내에 변수의 값을 저장하기 위한 기억영역이 할당되는데, 할당 되는 기억영역에 따라 사용 범위에 제한이 있다. 이러한 기억영역을 결정하는 작업을 기억 클래스(Storage Class)라 함

| --- | --- | --- | --- | --- |
#자레정외

5) 변수의 선언
| --- | --- |
## 3. 연산자 ⭐⭐⭐
> p.560, 4-26
#산시관비논
1) 산술 연산자 ⭐
| --- | --- |
ex) ++a, --a (연산 전 ↑, ↓)
ex) a++, a-- (연산 후 ↑, ↓)
2) 시프트 연산자
| --- | --- | --- |
3) 관계 연산자 ⭐
| --- | --- |
4) 비트 연산자 ⭐ __ 20년 1, 2회 기출문제
- 비트별(0, 1)로 연산해 결과를 얻는 연산자
| --- | --- | --- |
5) 논리 연산자 ⭐
- 두 개의 논리 값을 연산하여 참(true, 1) 또는 거짓(false, 0)을 결과로 얻는 연산자
| --- | --- | --- |
#조대순
6) 조건 연산자(삼항 연산자) __ 20년 3회 기출문제
- 조건에 따라 서로 다른 수식 수행 / **if(?),** **else(:)**
	- 산출물 : 조건 수식 **?** 수식1 **:** 수식2;
→ ‘조건 수식’이 **참**(true, 1)이면 ‘**수식1**’ 수행, **거짓**(false, 0)이면 ‘**수식2**’ 수행
7) 대입 연산자
| --- | --- | --- |
8) 기타 연산자
| --- | --- |
9) 연산자 우선순위 ⭐
| --- | --- | --- | --- | --- |
#산시관비논 조대순

## 4. 제어문, 반복문 ⭐⭐
> p.572~579, 4-27
1) 제어문의 개념
- 컴퓨터 프로그램은 명령어가 서술된 순서에 따라 무조건 위에서 아래로 실행되는데, 조건을 지정해서 진행 순서를 변경할 수 있다. 이렇게 프로그램의 순서를 변경할 때 사용하는 명령문을 제어문이라고 함

2) 단순 if문
- 형식 1: 조건이 참일 때만 실행

- 조건이 참일 때 실행할 문장이 하나인 경우

if(조건)

실행할 문장;

- 조건이 참일 때 실행할 문장이 두 문장 이상인 경우

if(조건)

{

실행할 문장1; // 실행할 문장이 두 문장 이상이면 { } 중괄호로 감싸기

실행할 문장2;

…

}
- 형식 2: 조건이 참일 때와 거짓일 때 실행할 문장이 다름


if(조건)

실행할 문장1; // 조건이 **참**일 경우 실행

else

실행할 문장2; // 조건이 **거짓**일 경우 실행

3) 다중 if문 ⭐
- 형식 1: 조건이 여러 개일 때 사용


if(조건1)

실행할 문장1; // 조건1이 참일 경우 실행

else if(조건2)

실행할 문장2; // 조건2가 참일 경우 실행

else if(조건3)

실행할 문장3; // 조건3이 참일 경우 실행

…

else

실행할 문장4; // 앞의 조건이 모두 거짓일 경우 실행

- 형식 2: if문 안에 if문이 포함됨

if(조건1)

{ // 조건1이 참일 경우 실행

if(조건2)

실행할 문장1; // 조건2가 참일 경우 실행

else(조건2)

실행할 문장2; // 조건2가 거짓일 경우 실행

}

else

실행할 문장3; // 조건1이 거짓일 경우 실행

4) switch문 ⭐⭐
- 조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리할 수 있는 제어문


switch(수식)

{

case 레이블1:

실행할 문장1; // 수식의 결과가 레이블 1과 일치할 때 실행

break; // switch문 종료함

case 레이블 2:

실행할 문장2; // 수식의 결과가 레이블 2와 일치할 때 실행

break; // switch문 종료함

…

default: // 수식의 결과가 레이블 1~2와 일치하지 않을 때,
실행할 문장3; 혹은 break가 없을 땐 무조건 default 실행


}

ex)
switch(2)


{ case 3: printf(“1”); // 수식의 결과(2)가 레이블 1(3)과 일치하지 않음

break;

case 2: printf(“2”); // 수식의 결과(2)가 레이블 2(2)와 일치함 → printf(“2”); 실행

break; // switch문 종료함

case 1: printf(“3”); // 수식의 결과(2)가 레이블 3(1)과 일치하지 않음
break;


} → 결과 2 표시됨

5) 반복문의 개념
- 제어문의 한 종류로 일정한 횟수를 반복하는 명령문을 말한다. 보통 변수의 값을 일정하게 증가시키면서 정해진 수가 될 때까지 명령이나 명령 그룹을 반복 수행함

6) for문
- 초기값, 최종값, 증가값을 지정하는 수식을 이용해 정해진 횟수를 반복하는 제어문
- 초기값을 정한 다음 최종값에 대한 조건이 참이면 실행할 문장을 실행한 후 초기값을 증가값 만큼 증가시키면서 최종값에 대한 조건이 참인 동안 실행할 문장을 반복 수행함


- 형식

for(초기값; 최종값; 증가값)

실행할 문장; // 최종값이 참인 동안 실행, 두 문장 이상 → { } 입력

7) while문
- 조건이 참인 동안 실행할 문장을 반복 수행하는 제어문
- 조건이 참인 동안 실행할 문장을 반복 수행하다가 조건이 거짓이면 while문을 끝낸 후 다음 코드를 실행

- 조건이 처음부터 거짓이면 한 번도 실행하지 않음 **⭐**

- 형식

while(조건)

실행할 문장; // 조건이 참인 동안 실행, 두 문장 이상 → { } 입력

8) do ~ while문 ⭐
- 조건이 참인 동안 정해진 문장을 반복 수행하다가 조건이 거짓이면 반복문을 벗어나는 while문과 같은 동작을 함

- 그러나 조건이 처음부터 거짓이어도 실행할 문장을 무조건 한 번 실행함**,** 그리고 다음 조건을 판단하여 탈출 여부를 결정함

- 형식

do

실행할 문장; // 조건이 참인 동안 실행, 두 문장 이상 → { } 입력

while(조건);

9) break, continue
- switch문이나 반복문의 실행을 제어하기 위해 사용되는 예약어
- break **⭐**
- switch문이나 반복문 안에서 break가 나오면 블록을 벗어남
- continue
- continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮김
- 반복문에서만 사용됨
## 5. 배열과 문자열 ⭐⭐
> p.585
1) 배열의 개념
- 동일한 데이터 유형을 여러 개 사용해야 할 경우 이를 손쉽게 처리하기 위해 여러 개의 변수들을 조합해서 하나의 이름으로 정의해 사용하는 것

- 개별적인 요소들의 위치는 첨자를 이용하여 지정
- 변수명 뒤에 대괄호 [ ]를 붙이고 그 안에 사용할 개수를 지정
- C언어에서 배열의 위치는 0부터 시작됨
2) 1차원 배열
- 1차원 배열은 변수들을 일직선상의 개념으로 조합한 배열

| --- | --- |
첫 번째 두 번째 세 번째 네 번째 다섯 번째
| --- | --- | --- | --- | --- |
	- 산출물 : a[3]: a는 배열의 이름이고, 3은 첨자로 배열 a에서의 위치를 나타냄
a[3]에 4를 저장시키려면 ‘a[3]=4’와 같이 작성
3) 2차원 배열 ⭐
- 2차원 배열은 변수들을 평면, 즉 행과 열로 조합한 배열

| --- | --- |
첫 번째 두 번째 세 번째 네 번째 다섯 번째
| --- | --- | --- | --- | --- |
	- 산출물 : b[0][2]: b는 배열의 이름이고, 0은 행 첨자, 2는 열 첨자로서 배열 b의 위치를 나타냄
4) 배열의 초기화
- 배열 선언 시 초기값을 정할 수 있음


- 1차원 배열 초기화

char a[3] = {‘A’, ‘B’, ‘C’} / char a[ ] = {‘A’, ‘B’, ‘C’}

| --- | --- | --- |
a[0] a[1] a[2]


- 2차원 배열 초기화

int a[2][4] = { {10, 20, 30, 40}, {50, 60, 70, 80} }; / = { 10, 20, 30, 40, 50, 60, 70, 80};

a[0][0] a[0][1] a[0][2] a[0][3]

| --- | --- | --- | --- |
a[1][0] a[1][1] a[1][2] a[1][3]

5) 배열 형태의 문자열 변수
→ char 배열이름[크기] = “문자열”


ex) char a[5] = “love”

| --- | --- | --- | --- | --- |
*문자열의 끝을 알리기 위한 널 문자(‘\0’)이 자동 삽입됨

## 6. 포인터 ⭐
> p.594
1) 포인터와 포인터 변수
- 포인터는 변수의 주소를 말하며, C언어에서는 주소를 제어할 수 있는 기능을 제공함

- C언어에서 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라고 함
- 포인터 변수는 필요에 의해 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수임

- 포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 간접 연산자 *를 붙임 → int *a;

- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 &를 붙임 → a = &b;

- 실행문에서 포인터 변수에 간접 연산자 *를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말함 → c = *a;

2) 포인터와 배열
- 배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근할 수 있음

- 배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 & 연산자를 사용

ex) int a[5], *b;

b = a → 배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주소를 b에 저장함

b = &a[0] → a 배열의 첫 번째 요소인 a[0]의 주소(&)를 b에 저장함

## 7. 절차적 프로그래밍 언어 ⭐⭐
> p.600, 4-29
1) 절차적 프로그래밍 언어의 개요
- 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해나가는 언어

- 프로그램이 실행되는 절차(Procedure)를 중요시 함
2) 절차적 프로그래밍 언어의 장, 단점
- 컴퓨터의 처리 구조와 유사하여 실행 속도가 빠름

- 같은 코드를 복사하지 않고 다른 위치에서 호출하여 사용할 수 있음(이식성)
- 모듈 구성이 용이하며, 구조적인 프로그래밍이 가능함
- 프로그램을 분석하기 어렵고, 유지 보수나 코드의 수정이 어려움
3) 절차적 프로그래밍 언어의 종류 ⭐
| --- | --- |
## 8. 객체지향 프로그래밍 언어 ⭐⭐
> p.602, 4-30
1) 객체지향 프로그래밍 언어의 개요
- 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 프로그램을 작성할 수 있도록 한 프로그래밍 기법

2) 객체지향 프로그래밍 언어의 장, 단점
- 상속을 통한 재사용과 시스템의 확장이 용이하고, 코드의 재활용성이 높음

- 사용자와 개발자 사이의 이해를 쉽게 해주고, 대형 프로그램의 작성이 용이함
- 프로그래밍 구현을 지원해 주는 정형화된 분석 및 설계 방법이 없음
- 구현 시 처리 시간이 지연됨 → 실행 속도가 느림
3) 객체지향 프로그래밍 언어의 종류 ⭐
| --- | --- |
4) 객체지향 프로그래밍 언어의 구성 요소 ⭐
- 객체(Object)
- 독립적으로 식별 가능한 이름을 갖고 있음

- 객체가 가질 수 있는 조건인 상태(State)는 일반적으로 시간에 따라 변함
- 객체와 객체는 상호 연관성에 의한 관계가 형성됨
- 객체가 반응할 수 있는 메시지의 집합을 행위(연산, Method)라고 하며, 객체는 행위의 특징을 나타냄
- 객체는 일정한 기억장소를 갖고 있음
- 클래스(Class)
- 공통된 속성과 연산(행위)를 갖는 객체의 집합

- 객체지향 프로그램에서 데이터를 추상화하는 단위 ⭐
- 각각의 객체들이 갖는 속성과 연산(Method)을 정의하고 있는 틀
- 슈퍼 클래스(Super Class)는 특정 클래스의 상위(부모) 클래스
- 서브 클래스(Sub Class)는 특정 클래스의 하위(자식) 클래스
- 인스턴스(Instance)
- 클래스에 속한 각각의 객체

- 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 함
- 메서드(Method)
- 클래스로부터 생성된 객체를 사용하는 방법
- 전통적 시스템의 함수(Function) 또는 프로시저(Procedure)에 해당하는 연산
- 메시지(Message)
- 객체에게 어떤 행위를 하도록 지시하기 위한 방법
5) 객체지향 프로그래밍 언어의 특징 ⭐⭐
| --- | --- |
#캡상다추정
## 9. 스크립트 언어 ⭐⭐
> p.605, 4-31, 20년 1, 2회 기출문제
1) 스크립트 언어의 개요
- HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 것으로, 기계어로 컴파일 되지 않고 별도의 번역기가 소스를 분석하여 동작하게 하는 언어

- 클라이언트의 웹 브라우저에서 해석되어 실행되는 클라이언트용 언어와, 서버에서 해석되어 실행된 후 결과만 클라이언트로 보내는 서버용 스크립트 언어

	- 산출물 : **클라이언트용 언어**: JavaScript / **서버용 스크립트 언어**: ASP, JSP, PHP, Python

2) 스크립트 언어의 장, 단점
- 컴파일 없이 바로 실행하므로 결과를 바로 확인할 수 있음 ⭐

- 개발 시간이 짧고, 소스 코드를 쉽고 빠르게 수정할 수 있음
- 코드를 읽고 해석해야 하므로 실행 속도가 느리고, 런타임 오류가 많이 발생함
3) 스크립트 언어의 종류 ⭐
| --- | --- |
## 10. 선언형 언어 ⭐
> p.607, 4-32
1) 선언형 언어의 개요
- 명령형 언어가 문제를 해결하기 위한 방법을 기술한다면, 선언형 언어는 프로그램이 수행해야 하는 문제를 기술하는 언어

- 함수형 언어(적용형 언어)와 논리형 언어(선언적 언어)가 있음
- 목표를 명시하고 알고리즘은 명시하지 않음

cf) **명령형 언어**(절차적 언어, 객체지향 언어)

- 알고리즘을 명시하고 목표는 명시하지 않음
- 폰노이만 구조에 개념적인 기초를 두고 있음
- 특정 구문의 연산을 이용하여 상태를 변경시키고 프로그램을 동작시킴
2) 선언형 언어의 장, 단점
- 가독성이나 재사용성이 좋고, 오류가 적음

- 프로그램 동작을 변경하지 않고도 관련 값을 대체할 수 있음
3) 선언형 언어의 종류
| --- | --- |
## 11. 라이브러리 ⭐
> p.609, 4-10, 4-36
1) 라이브러리(Library)의 개념
- 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체로 필요할 때 언제든지 호출하여 사용할 수 있음


- **표준 라이브러리**: 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리

- **외부 라이브러리**: 개발자들이 필요한 기능을 만들어 인터넷 등에 공유해 놓을 것으로, 다운받아 설치한 후 사용함

2) C언어의 대표적인 표준 라이브러리
| --- | --- |
3) JAVA의 대표적인 표준 라이브러리
- JAVA에서 패키지를 사용하려면 ‘import java.util’과 같이 import문을 이용해 선언한 후 사용해야 함

| --- | --- |
# 응용 SW 기초기술 활용
## 1. 데이터 입, 출력 ⭐⭐
> p.611, 4-37
1) scanf( ) 함수
- C언어의 표준 입력 함수, 키보드로 입력받아 변수에 저장하는 함수

| --- | --- |
ex) scanf(“%3d”, &a); → %: 서식 문자 / 3: 입력 자릿수 / d: 10진수 / &a: 변수 a의 주소
	- 산출물 : 서식 문자열과 변수의 자료형은 일치해야 함, 한 번에 여러 개의 데이터 입력 가능
- **서식 문자열**
| --- | --- |
2) printf( ) 함수
- C언어의 표준 출력 함수, 인수로 주어진 값을 화면에 출력하는 함수

| --- | --- |
ex) printf(“%-8.2f”, 200.2); → 200.20VV(V는 빈 칸을 의미함)
%: 서식 문자 / -: 왼쪽부터 출력 / 8: 출력 자릿수 / 2: 소수점 이하 자리 / f: 실수 출력
- **주요 제어문자**
| --- | --- | --- |
3) 기타 표준 입, 출력 함수 ⭐
| --- | --- | --- |
## 2. 운영체제의 개념 ⭐⭐⭐
> p.632~637, 4-40
1) 운영체제(OS; Operating System)의 정의
- 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임


	- 산출물 : 사용자 > 응용 프로그램 > 유틸리티 > **운영체제(OS)** > 하드웨어

2) 운영체제의 목적 ⭐
| --- | --- |
#처반사신
3) 운영체제의 기능 ⭐ __ 20년 3회 기출문제
- CPU, 메모리 공간, 프로세서(처리기, Processor), 기억장치(주기억장치, 보조 기억장치), 입, 출력 장치, 파일 및 정보 등의 자원 관리

- 다중 사용자와 다중 응용프로그램 환경 하에서 현재 상태를 파악하고 자원을 효율적으로 분배 및 관리하기 위해 스케줄링 기능 제공
- 사용자와 시스템 간의 편리한 인터페이스 제공, 입출력 장치와 사용자 프로그램 제어
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
- 시스템의 오류 검사 및 복구, 자원 보호 기능 제공
- 입, 출력에 대한 보조 기능 제공 → 가상 계산기 기능 제공
4) 운영체제의 주요 자원 관리
| --- | --- |
5) 운영체제의 종류 ⭐
| --- | --- | --- |
6) Windows의 주요 특징 ⭐
- **GUI**(Graphic User Interface, 그래픽 사용자 인터페이스)
-키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식


→ 초보자도 쉽게 사용할 수 있게 GUI 채용

- **선점형 멀티태스킹**(Preemptive Mulit-Tasking)
-동시에 여러 개의 프로그램을 실행하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식


→ 하나의 응용 프로그램이 CPU를 독점하는 것을 방지할 수 있어 시스템 다운 현상없이 더욱 안정적인 작업을 할 수 있음

- **PnP**(Plug and Play, 자동 감지 기능)
-컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 OS가 자동으로 구성해주는 기능


→ 운영체제가 하드웨어의 규격을 자동으로 인식하여 동작하게 해주므로 PC 주변장치를 연결할 때 사용자가 직접 환경을 설정하지 않아도 됌,

PnP기능을 활용하기 위해서는 하드웨어와 소프트웨어 모두 PnP를 지원해야 함

- **OLE**(Object Linking and Embedding)
-다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체(Objects)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding)하여 편집할 수 있게 하는 기능


→ OLE로 연결된 이미지를 원본 프로그램에서 수정하거나 편집하면 그 내용이 그대로 해당 문서에 반영됨

- 255자의 긴 파일명
-VFAT(Virtual File Allocation Table)를 이용해 최대 255자까지 파일 이름 지정 가능


→ 파일 이름으로는 \ / : * ? “ < > |를 제외한 모든 문자 및 공백을 사용할 수 있으며, 한글의 경우 127자까지 저장 가능

- 개인 사용자(Single-User) 시스템
- 컴퓨터 한 대를 한 사람만이 독점해서 사용
6) UNIX의 개요 및 특징 ⭐⭐
- 소스가 공개된 개방형 시스템(Open System)
- 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제

- **다**중 작업(Multi-Tasking, 멀티 태스킹) 지원
- 다중 **사**용자(Multi-User) 지원
- 대부분 C언어로 작성되어 있어 **이**식성이 높으며 장치, 프로세스 간의 호환성이 높음
- **계**층 구조(트리 구조)의 파일 시스템
#대다사이계
→ 하드웨어 > **커널(Kernel)** > **쉘(Shell)** > 유틸리티(Utility) > 사용자(User)
- **커널(Kernel)** **⭐**
- UNIX의 가장 핵심적인 부분
- 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행됨
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당
- 프로세스 관리, 기억장치 관리, 파일 관리, 입, 출력 관리 등 여러 가지 기능 수행
- 쉘(Shell)** **⭐ __ 20년 1, 2회 기출문제
- 사용자의 명령어를 인식하여 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
-주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능

- 시스템과 사용자 간의 인터페이스 역할을 담당
- 파이프라인 기능 지원 및 입, 출력 재지정을 통해 입, 출력의 방향 변경 가능
- 여러 종류의 쉘이 있음
- DOS의 COMMAND.COM과 같은 기능 수행
7) UNIX에서의 프로세스 간 통신
- 각 프로세스는 시스템 호출을 통해 커널의 기능을 사용하며, 프로세스 간 통신은 시그널(Signal), 파이프(Pipe), 소켓(Socket) 사용

- **시그널**(Signal): 간단한 메시지를 이용하여 통신하는 것, 초기 UNIX 시스템에서 사용
- 파이프(Pipe): 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식

- **소켓**(Socket): 프로세스 사이의 대화를 가능하게 하는 쌍방향 통신 방식
8) LINUX의 개요 및 특징
- 1991년 리누스 토발즈(Linus Torvalds)가 UNIX를 기반으로 개발한 운영체제
- 대부분의 특징이 UNIX와 동일하며 UNIX와 완벽하게 호환됨
- 프로그램 소스 코드가 무료로 공개되어 있음
9) MacOS의 개요 및 특징
- 1980년대 Apple사가 UNIX를 기반으로 개발한 운영체제
- 아이맥(iMAC)과 맥북(MacBook) 등 애플 사에서 생산하는 제품에서만 사용 가능
- 드라이버 설치 및 install과 uninstall의 과정이 단순
## 3. 기억장치 관리 ⭐⭐⭐
> p.640, 4-43
1) 기억장치의 관리 전략의 개요 ⭐
- 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기(When), 적재 위치(Where) 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위함


	- 산출물 : **반**입(Fetch), **배**치(Placement), **할**당(Allocation), **교**체(Replacemnet)

#반배할교

2) 반입(Fetch) 전략
- 보조기억장치에 보관중인 프로그램이나 데이터를 언제(When) 주기억장치로 적재할 것인지를 결정하는 전략


- 요구 반입(Demand Fetch): 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법

- 예상 반입(Anticipatory Fetch): 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법

3) 배치(Placement) 전략 __ 20년 3회 기출문제
- 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에(Where) 위치시킬 것인지를 결정하는 전략


- **최**초 적합(First Fit): 빈 영역 중에서 첫 번째 분할 영역에 배치

- 최**적** 적합(Best Fit): 빈 영역 중에서 단편화를 가정 작게 남기는 분할 영역에 배치

- 최**악** 적합(Worst Fit): 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치

#최적악

4) 교체(Replacement) 전략 __ 4-46
- 이미 사용되고 있는 영역 중에서 어느(Who) 영역을 교체할지 결정하는 전략


	- 산출물 : FIFO, LRU, LFU, NUR, OPT, SCR

5) 주기억장치 할당(Allocation)의 개념 ⭐
- 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게(How) 할당할지 정함


- **연**속 할당 기법: 프로그램을 주기억장치에 연속으로 할당하는 기법
	- 산출물 : **단**일 분할 할당 기법: 오버레이, 스와핑

	- 산출물 : **다**중 분할 할당 기법: 고정(정적) 분할 할당 기법, 가변(동적) 분할 할당 기법

- **분**산 할당 기법: 프로그램을 특정 단위의 조각으로 나누어 할당하는 기법
	- 산출물 : **페**이징(Paging) 기법 / **세**그먼테이션(Segmentation) 기법

#연단다_분페세

6) 가상기억장치의 개요 ⭐
- 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법

- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용
- 주기억장치의 이용률과 다중 프로그래밍 효율을 높일 수 있음
- 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업 필요
- 블록 단위로 나누어 사용하므로 연속 할당 방식의 단편화 해결 가능
7) 페이징(Paging) 기법 ⭐
- 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법

- 일정한 크기로 나눈 단위를 페이지(Page)라 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라 함
- 외부 단편화는 발생하지 않으나, **내부 단편화 발생 __ 4-48**
- 주소 변환을 위해 페이지의 위치 정보를 갖고 있는 페이지 맵 테이블(Page Map Table) 필요 → 페이지 맵 테이블 사용으로 비용 증가, 처리 속도 감소
8) 세그먼테이션(Segmentation) 기법 ⭐
- 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 기억공간을 절약하기 위해서 사용하는 실행시키는 방법

- 논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 가짐
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 갖고 있는 세그먼트 맵 테이블(Segment Map Table) 필요
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키(Storage Protection Key)가 필요
- 내부 단편화는 발생하지 않으나, **외부 단편화 발생 __ 4-48**
8) 페이지 교체 알고리즘 ⭐
- FIFO(First In First Out) = FCFS(First Come First Serve)

- 각 페이지가 주기억장치에 적재될 떄마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법

- **LRU**(Least Recently Used)

- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
- 가장 오래 전에 사용된 페이지 교체

- **LFU**(Least Frequently Used)

- 사용 빈도가 가장 적은 페이지를 교체하는 기법

- **OPT**(OPTimal replacement, 최적 교체)

- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
- 벨레이디(Belady)가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘

- **NUR**(Not Used Recently)

- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
- 각 페이지마다 두 개의 비트, 즉 참조 비트와 변형 비트 사용
| --- | --- | --- | --- | --- |
- SCR(Second Chance Replacement, 2차 기회 교체)

- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법
9) 페이지 크기 ⭐⭐
- **페이지 크기가 작을 경우**
- 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
- 불필요한 내용이 주기억장치에 적재될 확률이 적으므료 효율적인 워킹 셋 유지 가능
- Locality에 더 일치할 수 있기 때문에 기억장치 효율 높아짐
- 페이지 정보를 갖는 페이지 맵(사상) 테이블의 크기가 커지고, 매핑 속도가 늦어짐
- 디스크 접근 횟수가 많아져서 전체적인 입, 출력 시간은 늘어남
- **페이지 크기가 클 경우**
- 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남
- 불필요한 내용까지도 주기억장치에 적재될 수 있음
- 페이지 정보를 갖는 페이지 맵(사상) 테이블의 크기가 작아지고, 매핑 속도가 빨라짐
- 디스크 접근 횟수가 줄어들어 전체적인 입, 출력 효율성이 증가됨
10) Locality(지역성, 구역성) ⭐⭐
- 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론

- 스래싱(Thrashing)을 방지하기 위한 워킹 셋 이론의 기반
- 데닝(Denning) 교수에 의해 구역성의 개념이 증명됐으며, 캐시 메모리 시스템의 이론적 근거
| --- | --- |
11) 워킹 셋(Working Set) ⭐ __ 4-50
- 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
- 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정됨

- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경됨
12) 페이지 부재 빈도(PFF; Page Fault Frequency) 방식 __ 4-50
- 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식

- 페이지 부재(Page Fault)는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상이며, 페이지 부재 빈도는 페이지 부재가 일어나는 횟수를 의미함
13) 프리페이징(Prepaging)
- 처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 미리 한꺼번에 페이지 프레임에 적재하는 기법


→ 기억장치에 들어온 페이지들 중에서 사용되지 않는 페이지가 많을 수도 있음

14) 스래싱(Thrashing) ⭐ __ 4-49
- 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
→ 전체 시스템 성능 저하
- 다중 프로그래밍(멀티 태스킹)의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소됨

- **스래싱 현상 방지 방법**
- 다중 프로그래밍의 정도를 적정 수준으로 유지 **⭐**
- 페이지 부재 빈도(Page Fault Frequency)를 조절해 사용
- 워킹 셋(Working Set)을 유지함
- 부족한 자원을 증설하고, 일부 프로세스를 중단시킴
## 4. 프로세스 및 스케줄링 ⭐⭐
> p.657~661, 4-51
1) 프로세스(Process)의 정의
- 일반적으로 프로세서(처리기, Processor), 즉 CPU에 의해 처리되는 사용자 프로그램, 시스템 프로그램인 실행중인 프로그램을 의미하며 작업(Job), 태스크(Task)라고도 함

- 프로세서(Processor) → 프로세스(Process) → 프로시저(Procedure, 절차)

- 프로세스의 정의 **⭐**

- 프로시저가 활동중인 것
- 비동기적 행위를 일으키는 주체 **⭐⭐**
- 운영체제가 관리하는 실행 단위
- 실행중인 프로그램
- PCB(Process Control Block)을 가진 프로그램
- 실기억장치에 저장된 프로그램
- 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
2) PCB(Process Control Block, 프로세스 제어 블록) ⭐
| --- | --- |
#식상카레_스계입메
3) 프로세스 상태 전이 ⭐ __ 20년 1, 2회 기출문제
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image1.png](99.%20기타/정보처리기사/정보처리기사%20필기,%204과목%20프로그래밍%20언어%20활ᄋ%20d17101021a174d90a1e18a14fc38b60c/image1.png)
4) 프로세스 상태 전이 관련 용어
| --- | --- |
5) 스레드(Thread) ⭐ __ 20년 1, 2회 기출문제
- 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 단위


- **단일 스레드**: 하나의 프로세스에 하나의 스레드가 존재하는 경우

- **다중 스레드**: 하나의 프로세스에 하나 이상의 스레드가 존재하는 경우 **⭐**

- 프로세스의 일부 특성을 갖고 있기 떄문에 경량 프로세스라고도 함
- 동일 프로세스 환경에서 서로 독립적인 다중 수행 가능

→ 하나의 프로세스를 여러 개의 스레드로 생성해 병행성 증진 및 성능과 처리율 향상

프로그램 응답 시간 단축과 기억장소의 낭비가 줄어들고 통신이 향상됨 **⭐**

6) 스케줄링(Scheduling)의 개요
- 프로세스가 생성되어 실행될 떄 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업

| --- | --- |
	- 산출물 : 문맥 교환(Context Switching): 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것 ⭐

7) 스케줄링의 목적
- 공정성: 모든 프로세스에 공정하게 할당

- 처리량 증가: 단위 시간당 프로세스 처리량 증가
- CPU 이용률 증가: CPU 낭비 시간 줄이고, 사용되는 시간 비율 증가
- 우선순위 제도: 우선순위가 높은 프로세스 먼저 실행
- 오버헤드 최소화: 오버헤드 최소화
- 응답시간(Response Time, 반응 시간) 최소화: 작업 지시 및 반응 시작 시간 최소화
- 반환 시간(Turn Around Time) 최소화: 제출한 시간부터 실행 완료 시간 최소화
- 대기 시간 최소화: 준비상태 큐에서 대기하는 시간 최소화
- 균형 있는 자원의 사용: 메모리, 입, 출력장치 등의 자원을 균형 있게 사용
- 무한 연기 회피: 자원을 사용하기 위해 무한정 연기되는 상태 회피

→ CPU이용률, 처리율, 반환 시간, 대기 시간, 응답 시간 **⭐**

8) 프로세스 스케줄링의 기법 ⭐ __ 4-54
- 선점(Preemptive) 스케줄링: 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 선점할 수 있는 기법

- 우선순위가 높은 프로세스 빠르게 처리 가능
- 빠른 응답 시간을 요구하는 대화식 시분할 시스템(Time Sharing System)에 사용됨
- 많은 오버헤드 발생
- 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록 필요

	- 산출물 : **R**ound Robin, SR**T**(Shortest Remaining Time), **M**LQ(Multi-Level Queue), M**F**Q

#RTMF

- 비선점(Non-Preemptive) 스케줄링: 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 선점할 수 없는 기법

- CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU 사용
- 모든 프로세스에 대한 요구를 공정하게 처리 가능
- 프로세스 응답 시간의 예측 용이
- 일괄 처리 방식에 적합
- 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우 발생

→ 가뭄 현상

	- 산출물 : 우선순위(**P**riority), 기한부(**D**eadline), **F**CFS(FIFO), S**J**F(Shortest Job First), **H**RN

#PDF_JH

- **HRN(Highest Response-ratio Next) __ 20년 1, 2, 3회 기출문제**

SJF 기법의 가뭄 현상을 보완하기 위한 방식으로, 대기 시간이 긴 프로세스일 경우 우선순위가 높아지고, 우선순위 계산식의 수치가 **가장 높은 것부터 낮은 순으로 우선순위를 부여**해 긴 작업과 짧은 작업 간의 지나친 불평등을 해소함

→ **HRN 우선순위 계산식**: (대기시간 + 서비스시간) / 서비스시간 **⭐**

## 5. 인터넷 및 OSI 참조 모델 ⭐⭐⭐
> p.669~672, 4-70
1) IP 주소(Internet Protocol Address) __ 4-78
- 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소

- 숫자로 8비트씩 4부분, 총 32비트로 구성됨
| --- | --- |
2) 서브네팅(Subnetting)
- 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것
- 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라 하며, 이를 변경해 네트워크 주소를 여러 개로 분할해 사용

3) IPv6(Internet Protocol version 6) ⭐ __ 20년 1, 2, 3회 기출문제
- 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발됨
- 128비트의 긴 주소를 사용하고, IPv4에 비해 자료 전송 속도가 빠름
- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 해결 가능
- IPv4와 호환성이 뛰어나고, IPv6 확장 헤더로 네트워크 기능 확장이 용이함
- Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장(QoS; Quality of Service)이 용이

	- 산출물 : **유**니캐스트(Unicast), **멀**티캐스트(Multicast), **애**니캐스트(Anycast)
#유멀애⭐
cf) IPv4: **유**니캐스트, **멀**티캐스트, **브**로드캐스트(Broadcast) #유멀브
4) 도메인 네임(Domain Name)
- 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것

- 호스트 컴퓨터 이름(www), 소속 기관 이름(hankook), 소속 기관의 종류(co), 소속 국가명(kr) → www.hankook.co.kr
- 문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)라고 하며, 이런 역할을 하는 서버를 DNS 서버라 함 **⭐**
5) OSI(Open System Interconnection) 참조 모델 ⭐⭐ __ 4-73, 20년 1, 2, 3회 기출문제
| --- | --- | --- |
#아(A)파(P)서(S)_티(T)내(Ne)다(Da)_피(Phy)나다!
## 6. 네트워크 관련 장비 및 프로토콜 ⭐⭐
> p.676~679
1) 네트워크 관련 장비
| --- | --- |
#게라스_브리허
2) 프로토콜(Protocol)의 정의 __ 4-72
- 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약

3) 프로토콜의 기본 요소 ⭐⭐
| --- | --- |
#구의타
TCP/IP ⭐⭐⭐
> p.681
1) TCP/IP(Transmission Control Protocol/Internet Protocol)의 개요 __ 3회 기출문제
- 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜

| --- | --- |
2) TCP/IP의 구조 ⭐
| --- | --- | --- |
3) 응용 계층의 주요 프로토콜 ⭐
| --- | --- |
4) 전송 계층의 주요 프로토콜 ⭐
| --- | --- |
5) 인터넷 계층의 주요 프로토콜 ⭐ __ 20년 1, 2회 기출문제
| --- | --- |
6) 네트워크 액세스 계층의 주요 프로토콜 ⭐
| --- | --- |
**추가 정리, 수제비 및 기출문제** ⭐⭐⭐
1) 형상 관리 절차 __ 4-5
- 형상 식별: 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업


- 형상 **통**제(변경 관리): 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(베이스 라인, Base line)이 잘 반영될 수 있도록 조정하는 작업

- 형상 **감**사: 기준선(베이스 라인)의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업

- 형상 **기**록(상태 보고): 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

#식통감기

2) 모듈화 __ 4-11
| --- | --- |
#정분추독

3) 예외 처리 구성 __ 4-38
| --- | --- |
4) 프로토타입(Prototype) __ 4-39
- 속성과 메서드를 다른 클래스의 인스턴스 또는 빈 객체에 복제, 생성하는 작업을 덜 수 있는 프로그래밍 스타일

- 객체지향 프로그래밍과 달리 클래스를 명확히 정의하지 않아도 됨
5) 라우팅 프로토콜(Network, 3계층) ⭐ __ 4-85
| --- | --- |
6) 은행가 알고리즘(Banker’s Algorithm) __ 개정 전 기출문제, 20년 1, 2회 기출문제
- 교착상태의 해결 방법 중 Avoidance(회피) 사용
7) 교착 상태 발생의 필요 충분 조건 __ 개정 전 기출문제, 20년 1, 2회 기출문제
- 상호 배제(Mutual Exclusion), 점유와 대기(Hold and Wait), 환형 대기(Circular Wait), 비선점(Non-Preemption)

#상점환비
8) IEEE 802.11e __ 개정 전 기출문제, 20년 1, 2회 기출문제
- IEEE 802.11 워킹 그룹의 무선 LAN 표준화 현황 중 QoS(Quality of Service) 강화를 위해 MAC 지원 기능을 채택한 것

9) JAVA 언어의 접근제한자 ⭐⭐ __ 개정 전 기출문제, 20년 1, 2회 기출문제
| --- | --- |
→ **public > protected > default > private**
10) 배열의 초기화 __ p.589, 기출문제
78. C 언어에서 배열 b[5]의 값은? (2020년 제1, 2회차 필기시험, B형)


static int b[9]={1, 2, 3};

| --- | --- | --- | --- | --- | --- | --- | --- | --- |
b[0] b[1] b[2] b[3] b[4] b[5] b[6] b[7] b[8]


→ **b[5] = 0;**

11) 페이지 결함(Page Fault) 횟수 __ 19년 2회 기출문제, 20년 1, 2회 기출문제
46. 4개의 프레임을 수용할 수 있는 주 기억장치가있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우 페이지 결함의 발생 횟수는?

![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image2.gif](image2.gif)
① 4회 ② 5회 **③ 6회** ④ 7회
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image3.png](99.%20기타/정보처리기사/정보처리기사%20필기,%204과목%20프로그래밍%20언어%20활ᄋ%20d17101021a174d90a1e18a14fc38b60c/image3.png)
12) UNIX 명령어 __ p. 667, 20년 3회, 21년 1회 기출문제
| --- | --- |
13) 서브넷(Subnet) __ 17년 2회 기출문제, 20년 3회 기출문제
89. 200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 subnet으로 나누고 ip subnet -zero를 적용했다. 이때 서브네팅된 네트워크 중 10번째 네트워크의 broadcast IP 주소는?

**① 200.1.1.159** ② 201.1.5.175
③ 202.1.11.191 ④ 203.1.255.245
→ “**10**”개의 subnet으로 나눠야 함으로 2^3=”**8**”로는 부족하고, 2^4=”**16**”으로 나눔
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image4.png](image4.png)
200.1.1.0.0~200.1.1.0.15 (0~15)
200.1.1.16.0~200.1.1.0.31 (16~31)
200.1.1.32.0~200.1.1.0.47 (32~47)
200.1.1.48.0~200.1.1.0.63 (48~63)
200.1.1.64.0~200.1.1.0.79 (64~79)
200.1.1.80.0~200.1.1.0.95 (80~95)
200.1.1.96.0~200.1.1.0.111 (96~111)
200.1.1.112.0~200.1.1.0.127 (112~127)
200.1.1.128.0~200.1.1.0.143 (128~143)
200.1.1.144.0~200.1.1.0.159 (144~159) - 10번째

14) 소프트웨어 취약점 __ 20년 3회 기출문제
- 메모리를 다루는 데 오류가 발생하여 잘못된 동작을 하는 프로그램 취약점
→ **버퍼 오버플로**
15) Python List [ ] __ 20년 3회 기출문제
74. 다음은 사용자로부터 입력받은 문자열에서 처리음과 끝의 3글자를 추출한 후 합쳐서 출력하는 파이썬 코드에서 ⓐ에 들어갈 내용은?

![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image5.png](99.%20기타/정보처리기사/정보처리기사%20필기,%204과목%20프로그래밍%20언어%20활ᄋ%20d17101021a174d90a1e18a14fc38b60c/image5.png)
① string[1:3] + string[-3:] ② string[:3] + string[-3:-1]

**③ string[0:3] + string[-3:]** ④ string[0:] + string[:-1]
① 최종 출력: elrld → [1, 2] + [-3, -2, -1]
② 최종 출력: Helrl → [0, 1, 2] + [-3, -2]
③ 최종 출력: Helrld → [0, 1, 2] + [-3, -2, -1]
④ 최종 출력: Hello WorldHello Worl → [0 ~ 10] + [-11 ~ -2]
*정리: string[ ] 안에서 :을 기준으로 앞에 값은 시작, 뒤의 값은 해당하는 값의 전까지 list를 출력함

16) Java 출력함수 __ 20년 4회 기출문제
| --- | --- |
17) C언어 데이터 처리 – 열거체, 구조체, 공용체 __ 20년 4회 기출문제
| --- | --- |
18) PHP 연산자 __ 20년 4회 기출문제
| --- | --- |