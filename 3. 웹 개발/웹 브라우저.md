---
aliases: 거대한 괴물 인터프린터, 서버에 요청/응답을 받는 클라이언트
---
# 개요
>거대한 괴물 인터 프린터 
>서버에 요청/응답을 받는 클라이언트

>[!cite]- 참고 문서 
> - [MDN – DOM 소개](https://developer.mozilla.org/ko/docs/Gecko_DOM_Reference/%EC%86%8C%EA%B0%9C)
> - [NAVER D2 – 브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)

# 웹 브라우저란?
 - 웹 상의 자원을 요청하고 [[HTML]]과 같은 표준언어로 구성된 문서를 가독성이 높은 문서의 형태로 변환하는 소프트웨어 ( [[웹 브라우저#웹 브라우저 랜더링]])
 - 변환하는 과정을 랜더링이라고 함
	 ![[웹 브라우저.png|300]]
- 서버에서는 클라이언트/View라고 부름
- 브라우저는 자동 업데이트 ❌ → ‘브라우저 버전의 파편화’
- 해당 브라우저 버전에서 3대장을 쓸 수 있는지 사이트 : [Can I use... Support tables for HTML5, CSS3, etc](https://caniuse.com/)

## 브라우저를 평가하는 기준이란?
- 브라우저 엔진을 통해 브라우저를 평가
- 좋은 브라우저란 새로운 spec를 바로 업데이트하고 실행시켜주는 것을 의미함

# 검색 엔진이란? 
- 인터넷 상에서 방대한 분량으로 분산된 자료에서 원하는 정보를 쉽게 검색이 가능하도록 도와주는 소프트웨어
- 많은 데이터를 처리하는 컴퓨터 환경에서 검색 기능의 활용은 일반적
- 수많은 정보를 봇, 크롤러를 통해 정리하고, 사용자가 검색할 때 정리한 결과를 보여줌
- [[HTML]]에서 검색엔진이 노출시켜주는 것은 `<h2></h2>` 제목태그를 사용한 코드
	- 따라서 [[seo]]를 위해서 해당 제목 태그를 사용하는 것이 좋음


## 1. 검색 엔진의 구조
### 1.1. 검색엔진 모듈 : 검색과 관련된 일련의 작업을 처리 
![[검색엔진모듈.png|400]]
1.  **웹 크롤러(수집기)** : 웹 상의 문서를 자동으로 탐색하여 검색엔진이 보유한 문서 저장소를 최신 상태로 유지
2.  **색인기(index)** : 문서 저장소에 저장된 웹문서들을 분석한 후 색인에 필요한 정보를 추출하여 인덱스 저장소에 저장
   ![[인덱스 저장소.png|400]]
    - **색인어** : 각 웹 문서의 내용을 나타낼 수 있는 핵심어(대표어)
    - **인덱스** : 각 웹 문서가 담고 있는 요약된 형태의 색인어 정보
3. **검색처리기(실질적으로 검색을 수행)** : 사용자가 입력한 검색어를 검색 모델에서의 표현법으로 변환하여 검색을 수행![[검색처리기.png|400]]
4. **사용자 인터페이스** : 사용자에게 검색어를 받아 검색결과를 보여주는 모듈

### 1.2. 저장소 : 문서나 메타 데이터를 보관하는 저장소
저장소에 모든 웹 문서를 저장하는 것이 아님, 웹 문서에 대한 함축적인 요약만이 저장소에 담김
1.  문서 저장소
2.  인덱스 저장소

## 2. 검색 엔진 모델
각 문서를 간단하고 수학적으로 표현하고 문서 간의 유사성을 수치화할 수 있는 모델
- 유사도 : 검색어와 문서 또는 문서와 문서 간의 내용이 서로 비슷한 정도를 나타내는 정량적인 수치![[검색모델.png]]
### 2.1. 불리언 모델 : 웹 문서를 지정한 색인어 집합으로 표현
- 문서와 검색어와의 관련성을 Yes또는 No 이분법적으로 판단하는 모델
- 단점 : 문서를 이분법적으로 구분, 검색결과에 복수개의 문서가 포함 될 경우 문서간 중요도 판단 불가능
1.  **검색어 표현** : 색인어 포함 여부 ex) 검색$\wedge$(and)모델 또는 검색 $\vee$(or)모델
2.  **유사성 판단** : 문서가 검색어를 만족하면 1, 아니면 0
	- 인덱스
	- ![[검색엔진_인덱스.png|400]]
	- 역인덱스 : 각 문서가 특정 색인어를 포함하는지에 대한 빠른 탐색을 위해 관리하는 인덱스(색인어를 기준으로 나열)![[검색엔진_역인덱스.png|400]]
### 2.2. 벡터 공간의 모델 : 문서와 검색어를 벡터 공간의 한 점으로 표현
1.  유사성 판단
	- 문서 간의 거리 : 문서 간의 거리가 0에 가까울 수록 서로 유사
	    불리언 모델이 가지고 있는 문제점들을 극복할 수 있었지만 벡터 공간도 문제가 있다. 바로 검색한 내용은 같지만 검색어의 문장구조가 다르다면 문서y와 문서x로 검색한 내용이 완전히 다르게 나오기에 이런 문제점을 개선하기 위해 문서간의 거리가 아닌 문서간의 기울기로 유사성을 판단하게 되었다.
	- 코사인 유사도 : 두 벡터 사이의 각도가 0에 가까울수록 서로 유사 
		- ![[코사인 유사도.png|400]]

## 3. 검색 엔진의 활용
### 3.1. 구글의 페이지 순위 시스템
- [!] 더 많은 문서가 참조 할 수록 더 중요한 문서이다.
	- 구글에서 도입한 '연관성' 점수 부여방식


### 3.2. 코퍼스
전체 인터넷 사이트에서 검색 인터넷 사이트의 효과성과 효율성을 공정하게 평가하기 위해 만들어 놓은 일부 문서 집합으로 전문가 집단이 웹 문서의 목록을 결정
1.  **효과성** : 주어진 검색어와 관련된 문서를 얼마나 정확히 찾아 냈는지 판단하는 척도
    1.  **정확률과 재현율** : 정확률과 재현율은 기술이나 제품의 효과성 입증에 사용되는 개념![[정확률과 재현율.png]]
	- **정확률** : 검색엔진이 찾은 문서 중 관련있는 문서와의 교집합으로 위의 그림의 정확률은 2/3이다.
	- **재현율** : 관련있는 문서 집합에서 검색엔진이 찾은 문서와의 교집합으로 위의 그림의 재현율을 2/5이다.
2. **효율성** : 투입된 자원 대비해서 얼마나 빠르게 나오는 가.(얼마만큼 빨리, 얼마만큼 덜 중복된 내용을 찾아냈는가)![[검색엔진_효율성.png]]
## 4. 앞으로의 검색 트렌드
1.  음성검색
2.  이미지 검색
3.  QR코드 검색
4.  음악검색
5.  트렌드검색
6.  상품검색
7.  온라인견적
8.  개인화검색(개인 맞춤 검색)
9.  시맨틱검색(독립기념일 검색하면 독립기념일은 몇년 몇월 몇일이라고 알려주는 검색)

# 웹 브라우저의 저장방식

|      | 저장기간                        | 용량제한 | 서버전송여부 |
| ---- | ------------------------------- | -------- | ------------ |
| 쿠키 | 브라우저 데이터를 지울시 삭제됨 |          |              |
| 세션 | 브라우저 종료시 데이터지움      |          |              |
| Web Storage |브라우저 종료해도 데이터 보관 |          |              |

- 토큰과 쿠키 : 웹 app과 웹 브라우저, 각각 서버에 요청하는 방식

## 쿠키 Cookies
- 쿠키의 등장
	- 기존에 서버에 저장하는 방식은 주로 DB에서 서블릿/JSP를 통해서 가져옴 #비지니스_로직 
	- 따라서 동시 사용자가 많아지면 DB에 부하가 걸리고 서버 다운 등 웹 서비스에 문자가 생기기에 사용 데이터의 종류에 따라 클라이언트 PC나 서버의 메모리 등에 저장하여 빠르게 웹 어플리케이션을 실행할 수 있음
- 쿠키란?
	- 클라이언트의 PC에 쿠키 파일에 정보를 저장
	- 보안에 취약 (로컬에 슬쩍 저장하니까)
	- 웹 프로그램에서 사용하는 데이터 
	- 클라이언트의 PC에 쿠키 파일에 정보를 저장한 후 웹 페이지들끼리 공유
	- 최초 접속시 서버에 전송하고 그 이후 변동사항만 전송

### 쿠키 이용 웹 페이지 연동
- 웹 페이지들끼리 공유 정보를 클라이언트 PC에 저장
- 필요할 때 여러 웹페이지들이 공유, 사용할 수 있게 매개 역할을 하는 것
	- 정보가 클라이언트 PC에 저장됨
	- 저장용량은 제한적임
	- 보안에 취약
	- 클라이언트의 브라우저가 사용 유무 결정
	- 웹 사이트 당 하나의 쿠키가 만들어짐(도메인당 한개씩)
		- 예시) 팝업창 더이상 보이지 않기 -> 주로 보안과 무관한 적은 용량 저장시 사용

### 쿠키 종류
1. Persistance 쿠키
	- 생성위치 : 클라이언트 PC에 파일로 저장
	- 종료시간 : 쿠키를 직접 삭제 | 쿠키 설정값이 종료된 경우
	- 최초접속시 서버에 전송
	- 용도 : 로그인 유무 또는 팝업창 제한
2. Session 쿠키
	- 생성위치 : 브라우저 메모리 생성
	- 종료시간 : 브라우저가 종료된 경우
	- 최초 접속시 서버에 전송되지 않음
	-  용도 : 사이트 접속시 세션 인증정보

## 세션 Session
- 세션도 쿠키의 한 종류


## Web Storage



# 웹 브라우저 랜더링
>[!cite]- 참고 문서
> - [Blink엔진에서 transform 속성은 Reflow와 Repaint가 발생하지 않는다](https://ssocoit.tistory.com/258)
> - [Object Model 구성에 대해](https://web.dev/critical-rendering-path-constructing-the-object-model/)
> - [Critical Rendering Path](https://bitsofco.de/understanding-the-critical-rendering-path/)
> - [내가 작성한 css속성 값이 좋은지 안 좋은지 확인할 수 있는 사이트](https://csstriggers.com/)
> 	- [사용법](https://csstriggers.com/)

## 랜더링 엔진이란
- 랜더링 엔진이란 브라우저에서 그래픽 형태로 요소를 출력할 때 사용됨
- 웹 브라우저 별 랜더링 엔진
	- 크로미움 브라우저 : Blink
	- 파이어폭스 : Gecko
	- 사파리 : WebKit
	- 예전 엣지  랜더링엔진 : EdgeHTML(지금은 크로미움을 사용하기에 Blink) / IE는 Trident 
- **랜더링 프로세스** ![[Pasted image 20221019094140.png]]
	- 크로미움은 성능통계를 통해 각 랜더링 프로세스의 실행 단계를 볼 수 있음
	- DOM / CSSOM
		- HTML과 CSS를 파싱하여 Object Model 형태로 만듬
			- 상속규칙 적용됨, 따라서 HTML 요소와 모든 하위요소에 해당 속성이 존재
		- 위에 그림을 HTML과 CSS를 로드하고 파싱(Parse)하는 과정을 생략하고 보여줌
	- 랜더 트리 Render Tree는 DOM과 CSSOM에서 실제로 표시되는 요소만 트리 형태로 구성
		- 픽셀 영역을 차지하지 않는 요소는 포함시키지 않음
	- **레이아웃 Layout** : 랜더 트리에 정의된 것들을 실제로 배치하는 단계
		- ex ) width, height, 박스모델 요소, 포지션, 폰트 관련 속성, float, overflow 등
	- **Paint** : 스타일 및 geometry 정보를 모두 결합해서 실제 화면을 그릴 준비를 마치는 단계
		- ex ) color, border-style 요소, visibility, 백그라운드, 아웃라인, text-decoration 등
	- **Composite** 
		- Blink의 랜더링 프로세스의 가장 마지막 단계, 준비한 내용을 합성해서 실제 브라우저에 노드를 그리는 단계로 GPU가 작업하게 됨
		- 그래픽 레이어를 GPU가 작업하게 됨(다중연산이 되니까 하드웨어 가속 사용가능)
			- GPU 사용의 장점 
				- CPU가 일을 덜함
				- 이미지를 빠르게 합성할 수 있음
				- 서브픽셀 보정이라는 애니메이션 보정기능을 가짐
			- GPU 사용의 단점 
				- 많은 준비 작업 동반
				- 데이터 손실 가능성
				- 메모리 과도사용할 수 있음
			- ==GPU를 사용하는 경우== <!--ID: 1684538923324-->
				- video나 canvas 태그를 사용하는 경우
				- 하드웨어 가속 플러그인을 사용하는 경우
				- 3d transform 속성이 존재하는 경우
				- backface-visibility attribute가 hidden인 경우 
				- transition, animation 속성이 있는 경우
				- will-change를 설정한 경우 (opacity, transform, top, left 등..)
- **reflow와 repaint에 대해**
	- 위의 레이아웃과 paint를 다시 한다고 생각하면 됨
	- **reflow** : 크기나 위치같은 것들이 변경된 경우
		- 생성된 dom 노드의 레이아웃 변경시 영향 받는 모든 노드(자식, 부모)의 수치를 다시 계산하여 랜더 트리를 재생산하는 작업을 말함
	- **repaint** : reflow랑 상관없는 것들
		- reflow 과정 이후에 재생성된 랜더 트리를 다시 그리는 과정. 
		- 수치와 상관 없는 background-color, visibility, outline 등의 스타일만 변경시 reflow를 생략
	- **Composite**
		- (Blink에서) transform과 opacity가 reflow와 repaint을 일으키지 않는 속성임
			- 물론 랜더링 엔진마다 다름
			- transform뿐만아니라 다른 reflow나 repaint를 일으키는 레이어가 들어가면 당연히 발생됨


## 웹 브라우저의 랜더링 과정(CRP)

^2c579d

- 웹 브라우저의 랜더링 과정은 매우 복잡함
- 크게 두 단계로 나눌 수 있음![[3. Resouce/99. 기타/img/Untitled.png]]
1. 읽어들인 문서를 파싱하여 최종적으로 어떤 내용을 페이지에 랜더링 할 것인지 결정
	- 이 과정에서 렌더 트리가 생성됨, 렌더 트리 생성을 위해 두 모델이 필요
		- [[웹 브라우저]](Document Object Model) – [[HTML]] 요소들의 구조화된 표현
		- [[CSSOM]](Cascading Style Sheets Object Model) – 요소들과 연관된 스타일 정보의 구조화된 표현
1. 브라우저는 해당 렌더링을 수행


### 랜더링 과정 자세하게
![[Pasted image 20221019094140.png]]
- DOM 트리![[Pasted image 20221019094158.png]]
- CSSOM 트리 : 랜더링 차단 리소스? ![[Pasted image 20221019094216.png]]


## 웹 브라우저 객체 모델 (BOM)
- [[JS#^559642|JS에서 BOM을 사용하는 방식]]

- 과거엔 브라우저마다 달랐음
- HTML5에서 다루고 있으며, 표준화 되어가고 있다.

- 5.2 The Window object
- 5.5 Session history and navigation
- 6.3 Dynamic markup insertion
- 등등

Q: ECMA에서는 BOM을 다루지 않는가?


## DOM의 특징
1. DOM은 노드 #트리구조 로 표현됨
    - DOM의 처리
		- DOM 파스 트리를 기계어로 컴파일 할 일은 없다. 대신 깊이 우선 순회(depth-frist traversal)를 하면서 트리를 해석함  ![[Pasted image 20221017195603.png|400]]       
2. DOM은 HTML이 아님
        작성된 HTML이 유효하지 않을 때, HTML 코드를 유효하게 교정
        자바스크립트에 의해 DOM이 수정될 때,
3. DOM은 브라우저에서 보이는 것이 아님
        뷰포트에서 보이는 건 DOM & CSSOM의 조합 따라서 시각적으로 보이지 않는 요소는 제외됨
        ex) display : none; 했을경우 DOM에 포함하지만 렌더 트리에서는 포함 ❌
4. DOM은 개발도구에서 보이는 것이 아님
    1. DOM과 가장 가까운 근사치를 제공 but 개발도구의 요소 검사기는 DOM에 없는 추가적인 정보를 포함
    2. 가장 좋은 예는 CSS의 가상 요소
        생성된 가상 요소는 CSSOM과 렌더 트리의 일부를 구성 , 하지만, 기술적으로 DOM의 일부는 아님. DOM은 오직 원본 HTML 문서로부터 빌드 되고, 요소에 적용되는 스타일을 포함하지 않기 때문
        가상 요소가 DOM의 일부가 아님에도 불구하고, 요소 검사기에서는 아래와 같이 확인됨![[웹브라우저_콘솔.png]]
## 요약정리
- DOM은 HTML 문서에 대한 인터페이스
	1. 뷰 포트에 무엇을 렌더링 할지 결정하기 위해 사용
   2. 페이지의 콘텐츠 및 구조, 그리고 스타일이 자바스크립트 프로그램에 의해 수정되기 위해 사용
- DOM은 원본 HTML 문서 형태와 비슷하지만 몇 가지 차이점이 있습니다.
    - 항상 유효한 HTML 형식입니다.
    - 자바스크립트에 수정될 수 있는 동적 모델이어야 합니다.
    - 가상 요소를 포함하지 않습니다. (Ex. `::after`)
    - 보이지 않는 요소를 포함합니다. (Ex. `display: none`)


# 웹 브라우저 모바일에서의 활용
## 웹 애플리케이션의 종류

| 종류                  | 설명                                                                                |
| --------------------- | ----------------------------------------------------------------------------------- |
| 네이티브 애플리케이션 | 원래 정해놓은 언어를 사용해 운영체제의 자체 기능을 사용하는 app (네이티브 = 원주민) |
| 하이브리드 애플리케이션                      | 웹과 애플리케이션이 혼합된 app (카톡, 네이버 등)                                                                                    |



# 용어해설
- ISP(Internet Service Provider) : 인터넷 서비스  제공자






# 연관문서