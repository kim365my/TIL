---
tag : 자격증
aliases : 
---

# 개요
>[!info]- 1년에 3번인가 시험있음
> - **필기시험**
> 	- 1. 소프트웨어 설계
> 		- 요구사항 확인
> 		- 화면설계
> 		- 애플리케이션 설계
> 		- 인터페이스 설계
> 	- 2. 소프트웨어 개발
> 		- 데이터 입출력 구현
> 		- 통합 구현
> 		- 제품소프트웨어 패키징
> 		- 애플리케이션 테스트 관리
> 		- 인터페이스 구현
> 	- 3. 데이터베이스 구축
> 		- SQL 응용 \ 활용
> 		- 논리 데이터베이스 설계
> 		- 물리 데이터 베이스 설계
> 		- 데이터 전환
> 	- 4. 프로그래밍 언어 활용
> 		- 서버프로그램 구현
> 		- 프로그래밍 언어 활용
> 		- 응용 SW 기초기술 활용
> 	- 5. 정보시스템 구축 관리
> 		- 소프트웨어 개발 방법론 활용
> 		- IT프로젝트 정보시스템 구축관리
> 		- 소프트웨어 개발보안 구축
> 		- 시스템 보안 구축
> - **실기시험**
> 	- 요구사항 확인
> 	- 데이터 입출력 구현
> 	- 통합구현
> 	- 제품 소프트웨어 패키징
> 	- 서버 프로그램 구현
> 	- 인터페이스 구현
> 	- 프로그래밍 언어 활용
> 	- 응용 SW기초 기술 확용
> 	- 화면 설계
> 	- 애플리케이션 테스트 관리
> 	- SQL 응용
> 	- 소프트웨어 개발 보안 구축

| 필기시험 목차             | 설명 |
|----------------|----|
| [[#1. 소프트웨어 설계]]    |    |
| [[#2. 소프트웨어 개발]]    |    |
| [[#3. 데이터베이스 구축]]   |    |
| [[#4. 프로그래밍 언어 활용]] |    |
| [[#5. 정보시스템 구축 관리]]  | |


# 필기시험
## 1. 소프트웨어 설계
### 요구사항 확인
#### 1. 소프트웨어 생명 주기, SDLC(Software Development Life Cycle) ⭐⭐
>[!summary] p.22, 5-3, 20년 1, 2, 3, 4회 기출문제

1. 폭포수 모형(Waterfall Model) ⭐
- 가장 오래되고 가장 폭넓게 사용된 고전적 생명 주기 모형

- 한 단계가 끝나야만 다음 단계로 넘어가는 선형 순차적 모형
- 단계별 정의 및 산출물이 명확
- 개발 중간에 요구사항의 변경이 용이하지 않음
- 타당성검토 → 계획 → 요구 **분**석 → **설**계 → **구**현(코딩) → **테**스트(검사) → **유**지보수

#분설구테유

2. 프로토타입 모형(Prototype Model, 원형 모형) ⭐
- 견본(시제)품을 만들어 최종 결과물을 예측하는 모형

- 인터페이스 중점을 두어 개발
- 개발 중간에 요구사항의 변경이 용이
3. 나선형 모형(Spiral Model, 점진적 모형) ⭐ __ 20년 1, 2, 3회 기출문제
- 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형

- 점진적 개발 과정 반복으로 요구사항 추가 가능
- 정밀하고 유지보수 과정 필요 없음
- **계**획 및 정의 → **위**험 분석 → 공학적 **개**발 → **고**객 평가

#계위개고

4. 애자일 모형(Agile Model) ⭐⭐ __ 20년 1, 2, 3, 4회 기출문제
- 애자일은 민첩함, 기민함 의미

- 변화에 유연하게 대응
- 일정한 주기(Iteration, Sprint)를 반복하면서 개발과정 진행
- 절차와 도구보다 고객(개인)과의 소통에 초점을 맞춤

ex) **X**P(eXtreme Programming), **스**크럼(Scrum), **칸**반(Kanban), **크**리스탈(Crystal), **린**(LEAN)

#엑스칸크린

+ **기능중심 개발**
#### 2. 스크럼(Scrum) 기법 ⭐
>[!summary] p.26, 1-14

- 팀원 스스로가 스크럼 팀 구성
- 개발 작업에 관한 모든 것을 스스로 해결해야 함
- 스프린트는 2 ~ 4주 정도의 기간으로 진행
1. 제품 책임자(PO; Product Owner) ⭐
- 요구사항이 담긴 백로그(Backlog)를 작성하는 주체

- 백로그에 대한 우선순위를 지정, 이해관계자들의 의견을 종합
2. 스크럼 마스터(SM; Scrum Master)
- 일일 스크럼 회의 주관

- 팀원들을 통제하는 것이 목표가 아님
3. 개발팀(DT; Development Team)
- 제품 책임자와 스크럼 마스터를 제외한 모든 팀원

- 최대 인원 7~8명
4. 스크럼 개발 프로세스
- 스프린트 계획 회의 → 스프린트 → 일일 스크럼 → 스크럼 검토 회의 → 스프린트 회고


#계스일검회

#### 3. XP(eXtreme Programming) 기법 ⭐⭐
>[!summary] p.31, 1-14

1. XP(eXtreme Programming)의 핵심 가치 ⭐
- 용기(Courage), 단순성(Simplicity), 의사소통(Communication), 피드백(Feedback), 존중(Respect)


#용단의피존

2. XP의 기본원리 __ 20년 4회 기출문제
- Whole Team(전체 팀), Small Releases(소규모 릴리즈)


Test-Driven Development(**테**스트 주도 개발), Continuous Integration(**계**속적인 통합)

Collective Ownership(**공**동 소유권), Pair Programming(**짝** 프로그래밍)

Design Improvement(**디**자인 개선) 또는Refactoring(리팩토링)

#전소테_계공짝디

#### 4. 개발 기술 환경 파악 ⭐
>[!summary] p.37, 1-3

1. 운영체제(OS; Operating System)
- 하드웨어가 아닌 소프트웨어
	- 산출물 : Windows, UNIX, Linux, Mac OS | iOS, Android 등등

- **가**용성, **성**능 | **기**술 지원, **구**축 비용, **주**변 기기 (고려사항)
#가성기구주
2. 미들웨어(Middleware)
- 운영체제와 응용 프로그램 사이에서 추가적인 서비스를 제공하는 소프트웨어
3. 데이터베이스 관리 시스템(DBMS; Database Management System)
- 사용자와 데이터베이스(DB) 사이에서 정보를 생성하고 DB를 관리하는 소프트웨어
- 데이터베이스(DB)의 구성, 접근 방법, 유지관리에 대한 모든 책임을 짐
- JDBC(Java Database Connectivity, 자바), ODBC(Open Database Connectivity, 응용 프로그램)

- Oracle, MySQL, SQLite, MongoDB, Redis 등등
- **가**용성, **성**능 | **기**술 지원, **구**축 비용, 상호 **호**환성 (고려사항) **⭐ __ 1, 2회 기출문제**
#가성기구호
4. 웹 어플리케이션 서버(WAS; Web Application Server) ⭐
- 정적인 콘텐츠를 처리하는 웹 서버(Web Server)와 반대됨

- 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어(=소프트웨어)
- 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공
- Tomcat, JEUS, WebLogic, JBoss, Jetty, Resin 등등
- **가**용성, **성**능 | **기**술 지원, **구**축 비용 (고려사항)

#가성기구

5. 오픈 소스(Open Source)
- 누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 무료로 사용할 수 있게 공개한 것

- **라**이선스의 종류, **사**용자 수, 기술의 **지**속 가능성 (고려사항)

#라사지

#### 5. 요구사항 정의 / 분석 ⭐
>[!summary] p.41, 1-11

1. 기능 요구사항
- 기능, 입력, 출력, 저장, 수행 등등
2. 비기능 요구사항
- 성능, 품질, 제약사항, 호환성, 보안 등등

3. 요구사항 개발 프로세스 ⭐ __ 5-5
- 도출(Elicitation)/추출 → 분석(Analysis) → 명세(Specification) → 확인(Validation)/검증(Valification)


#도분명확 #추분명검

4. 요구사항 분석 기법 ⭐
- 요구사항 분류, 개념 모델링([[UML]]), 요구사항 할당, 요구사항 협상, 정형 분석


#분개할협정

5. 요구사항 확인 기법 ⭐⭐ __ 20년 1, 2, 3회 기출문제
- 요구사항 검토, 프로토타이핑, 모델 검증, 인수 테스트(알파 테스트, 베타 테스트)


#검프모인

#### 6. [[UML]](Unified Modeling Language) ⭐⭐⭐
>[!summary] p.51, 20년 1, 2, 3회 기출문제

1. UML(Unified Modeling Language)의 구성 요소 ⭐
- 사물, 관계, 다이어그램


#사관다

2. 사물(Things)
- 구조, 행동, 그룹, 주해 {사물}




#구행그주

3. 관계(Relationships) ⭐⭐ __ 20년 3회 기출문제
- 연관(ㅡ), 집합(◇), 포함(◆), 일반화(ㅡ▷), 의존(-->), 실체화(--▷) {관계}




#연집포_일의실

4. 구조적, 정적 다이어그램(Diagram) ⭐⭐ __ 20년 1, 2, 3회 기출문제
- 클래스(Class), 객체(Object), 컴포넌트(Component), 배치(Deployment),


**복**합체 구조(Composite Structure), **패**키지(Package) {다이어그램(Diagram)}



- **컴**포넌트, **배**치 다이어그램은 구현 단계에서 사용되는 다이어그램임 ⭐

#클객컴_배복패

5. 행위, 동적 다이어그램(Diagram) ⭐⭐ __ 20년 1, 2, 3회 기출문제
- 유스케이스(Use Case, 사용사례), 시퀀스(Sequence, 순차),


**커**뮤니케이션(Communication, 협업), **상**태(State), **활**동(Activity),

상**호**작용 개요(Interaction Overview), **타**이밍(Timing) {다이어그램(Diagram)}



#유시커_상활호타

### 화면설계
#### 1. 사용자 인터페이스(UI; User Interface) ⭐
>[!summary] p. 62, 1-23

1. UI의 구분 ⭐
- CLI(Command Line Interface): 텍스트 형태로 이뤄진 인터페이스

- GUI(Graphical User Interface): 마우스로 선택해 작업을 하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface): 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
- VUI(Voice User Interface): 사람의 음성으로 기기를 조작하는 인터페이스
- OUI(Organic User Interface): 모든 사물과 사용자 간의 상호작용을 위한 인터페이스
2. UI의 기본 원칙 ⭐⭐ __ 20년 1, 2회 기출문제
- 직관성: 누구나 쉽게 이해하고 사용할 수 있어야함

- **유**효성: 사용자의 목적을 정확하고 완벽하게 달성해야 함
- **학**습성: 누구나 쉽게 배우고 익힐 수 있어야함
- 유**연**성: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함

#직유학연

3. 웹의 3요소
- 웹 표준(Web Standards), 웹 접근성(Web Accessibility), 웹 호환성(Cross Browsing)


#표접호

4. UI 설계 도구 ⭐
- 와이어프레임(Wireframe): 레이아웃을 협의하거나 공유하기 위해 사용

- **스**토리보드(Story Board): 최종적으로 참고하는 작업 지침서, 작업 산출물 (디스크립션)
- **프**로토타입(Prototype): 인터랙션을 적용해 실제 구현된 것처럼 테스트가 가능한 동적인 모형
- **목**업(Mockup): 실제 화면과 유사한 정적인 모형
- **유**스케이스(Use Case): 사용자 측면 요구사항을 다이어그램 형식으로 묘사 (유스케이스 명세서)

#와스프목유

5. UI 프로토타입
- 장점: 사용자를 설득하고 이해시키기 쉬움 | 개발 시간을 줄일 수 있음 | 사전 오류 발견 가능


- **단점**: 반복적인 개선 및 보완 작업으로 인한 작업 시간 증가 및 자원 소모 | 부분적인 프로토타이핑으로 인한 중요한 작업 생략 가능성

	- 산출물 : 페이퍼 프로토타입, 디지털 프로토타입, HTML/CSS

6. UI 시나리오 문서 요건
- 이해성(Understandable): 누가나 쉽게 이해할 수 있도록 설명

- **완**전성(Complete): 최대한 상세하게 기술
- **일**관성(Consistent): 일관성 유지
- **가**독성(Readable): 표준화된 템플릿 등을 활용하여 문서를 쉽게 읽을 수 있도록 해야함
- **수**정 용이성(Modifiable): 수정 및 개선이 쉬워야 함
- **추**적 용이성(Traceable): 변경사항에 대해서 쉽게 추적할 수 있어야 함

#이완일_가수추

7. 기타
- HCI(Human Cumputer Interaction or Interface): {사람}과 {컴퓨터}의 {상호작용}을 연구해서 사람이 컴퓨터를 편리하게 사용하도록 만드는 학문



- **UX**(**U**ser **E**xperience): 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하는 총체적인 경험
	- 산출물 : 주관성(Subjecctivity), 정황성(Contextuality), 총체성(Holistic)
- 감성공학: 1류; 인간의 감성 / 2류; 심리적 기능 / 3류; 공학적 및 수학적 모델, 객관적
#### 2. 품질 요구사항 ⭐
>[!summary] p.76, 2-60, 20년 3회 기출문제

1. 국제 제품 품질 표준 (수제비) ⭐
- ISO/IEC 9126

- ISO/IEC **12119**
- ISO/IEC **14598**
- ISO/IEC **25000**: SW 품질 평가 통합 모델, SQuaRE로도 불리며 위 3개 표준을 통합
품질 **관**리(2500n), 품질 **모**델(2501n), 품질 **측**정(2502n), 품질 **요**구(2503n), 품질 **평**가(2504n)
#관모측요평
2. ISO/IEC 9126 ⭐⭐ __ 20년 1, 2, 3회 기출문제
- 기능성(Functionality): 요구사항을 정확하게 만족하는 기능을 제공하는가?
	- 산출물 : 적절성(적합성), 정확성, 상호 운용성, 보안성, 호환성

- **신**뢰성(Reliability): 요구된 기능을 정확하고 일관되게 오류 없이 수행하는가?
	- 산출물 : 성숙성, 결함 허용성, 회복성
- **사**용성(Usability): 사용자가 정확하게 이해하고 사용하는가?
	- 산출물 : 이해성, 학습성, 운용성, 친밀성
- **효**율성(Efficiency): 할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리하는가?
	- 산출물 : 시간 효율성, 자원 효율성
- **유**지 보수성(Maintainability): 환경의 변화에 소프트웨어를 쉽게 개선, 확장, 수정할 수 있는가?
	- 산출물 : 분석성, 변경성, 안정성, 시험성
- **이**식성(Portability): 소프트웨어를 다른 환경에서도 쉽게 적용할 수 있는가?
	- 산출물 : 적용성, 설치성, 대체성, 공존성

#기신사_효유이

3. ISO/IEC 14598 (수제비)
- 반복성(Repeatability), 재현성(Reproducibility), 공정성(Impartiality), 객관성(Objectivity)


#반재공객

4. 국제 프로세스 품질 표준
- ISO/IEC 9001

- ISO/IEC **12207**: **기**본 프로세스, **조**직 프로세스, **지**원 프로세스
#기조지
- ISO/IEC **15504(SPICE)**: **불**완전 → **수**행 → **관**리 → **확**립 → **예**측 → **최**적화
#불수관_확예최
- **CMMI**(Capability Maturity Model Integration): 조직차원의 성숙도를 평가하는 단계별 표현과 프로세스 영역별 능력도를 평가하는 연속적 표현이 있음

### 애플리케이션 설계
#### 1. 소프트웨어 아키텍처 ⭐
>[!summary] p.98

- 사용자의 비기능적 요구사항으로 나타난 제약 반영
- 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
#모추단정
1. 모듈화(Modularity)
- 시스템 기능들을 모듈 단위로 나눠 소프트웨어의 성능 및 재사용성을 향상시키는 것

- 모듈의 크기 多: 모듈 개수 적음 | 모듈 간 통합 비용 적음 | 모듈 하나의 개발 비용 큼
- 모듈의 크기 小: 모듈 개수 많음 | 모듈 간 통합 비용 큼
2. 추상화(Abstraction)
- 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시키는 것

- **과**정 추상화: 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악
- **데**이터 추상화: 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표하는 표현으로 대체
- **제**어 추상화: 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표하는 표현으로 대체

#과데제

3. 단계적 분해(Stepwise Refinement)
- Niklaus Wirth에 의해 제안된 하향식 설계 전략

- 추상화의 반복에 의해 세분화
- 소프트웨어 기능에서부터 시작해 절차적으로 구체화
- 상세한 내역은 가능한 한 뒤로 미루어 진행
4. 정보 은닉(Information Hiding)
- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

- 정보 은닉을 통한 독립적 모듈 수행 가능
- 모듈 변경 시 영향을 받지 않아 수정, 시험, 유지보수 용이
#### 2. 아키텍처 패턴 ⭐
>[!summary] p.102

1. 레이어 패턴(Layers Pattern)
- 시스템을 계층(Layer)으로 구분하여 구성하는 고전적 방법
	- 산출물 : OSI 참조 모델 ⭐

2. 클라이언트-서버 패턴(Client-Server Pattern)
- 하나의 서버 컴포넌트와 다수 클라이언트 컴포넌트로 구성되는 패턴

- 클라이언트나 서버는 요청과 응답을 받기 위해 동기화 되는 경우를 제외하고는 서로 독립적
- 컴포넌트(Component): 독립적인 업무 또는 기능을 수행하는 실행코드 기반으로 작성된 모듈
3. 파이프-필터 패턴(Pipe-Filter Pattern) ⭐
- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화해 파이프를 통해 데이터를 전송하는 패턴

- 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장 용이
- 필터 컴포넌트들을 재배치하여 다양한 파이프라인 구축 가능

	- 산출물 : UNIX의 쉘(Shell)

4. 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern) ⭐⭐
- 서브시스템을 3개의 부분으로 구조화하는 패턴

- 모델(**M**odel): 서브시스템의 핵심 기능과 데이터를 보관
- 뷰(**V**iew): 사용자에게 정보를 표시
- 컨트롤러(**C**ontroller): 사용자로부터 받은 입력 처리 / 뷰 제어 / UI 담당
- 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업 수행
- 한 개의 모델에 대해 여러 개의 뷰를 만들 수 있으므로 대화형 애플리케이션에 적합
5. 마스터-슬레이브 패턴(Master-Slave Pattern)
- 마스터 컴포넌트에서 슬레이브 컴포넌트로 분할한 후, 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴


	- 산출물 : 장애 허용 시스템(Fault Tolerance System), 병렬 컴퓨팅 시스템 ⭐

6. 브로커 패턴(Broker Pattern)
- 컴포넌트와 사용자를 연결해주는 패턴


	- 산출물 : 분산 환경 시스템

7. 피어-투-피어 패턴(Peer-To-Peer Pattern)
- 피어를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴


	- 산출물 : 멀티스레딩(Multi Threading) 방식 사용

8. 이벤트-버스 패턴(Event-Bus Pattern)
- 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식

- 이벤트를 생성하는 **소**스(Source), 이벤트를 수행하는 **리**스너(Listener), 이벤트의 통로인 **채**널(Channel), 채널들을 관리하는 **버**스(Bus)

#소리채버

9. 블랙보드 패턴(Blackboard Pattern)
- 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴


	- 산출물 : 음성인식, 차량 식별, 신호 해석 ⭐

10) 인터프리터 패턴(Interpreter Pattern)
- 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용됨
#### 3. 객체지향(Object-Oriented) ⭐⭐
>[!summary] p.106, 1-58

1. 객체(Object)
- 독립적으로 식별 가능한 이름을 갖고 있음

- 객체가 가질 수 있는 조건인 상태(State)는 일반적으로 시간에 따라 변함
- 객체와 객체는 상호 연관성에 의한 관계가 형성됨
- 객체가 반응할 수 있는 메시지의 집합을 행위(연산, Method)라고 하며, 객체는 행위의 특징을 나타냄
- 객체는 일정한 기억장소를 갖고 있음
2. 클래스(Class) ⭐⭐ __ 20년 1, 2, 3회 기출문제
- 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것 ⭐

- 공통된 속성과 연산(행위)를 갖는 객체의 집합
- 객체지향 프로그램에서 데이터를 추상화하는 단위 ⭐
- 각각의 객체들이 갖는 속성과 연산(Method)을 정의하고 있는 틀
- 슈퍼 클래스(Super Class)는 특정 클래스의 상위(부모) 클래스
- 서브 클래스(Sub Class)는 특정 클래스의 하위(자식) 클래스
3. 인스턴스(Instance)
- 클래스에 속한 각각의 객체

- 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 함
4. 메서드(Method)
- 클래스로부터 생성된 객체를 사용하는 방법
- 전통적 시스템의 함수(Function) 또는 프로시저(Procedure)에 해당하는 연산
5. 메시지(Message)
- 객체에게 어떤 행위를 하도록 지시하기 위한 방법
#캡상다형⭐
6. 캡슐화(encapsulation) __ 20년 3회 기출문제
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것

- 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부 접근이 제한됨
- 정보 은닉 측면과 가장 밀접한 관계가 있음
- 외부 모듈의 변경으로 인한 파급 효과가 적음
- 재사용 용이, 인터페이스 단순해짐
- 결합도 Down / 응집도 Up
7. 상속(Inheritance)
- 이미 정의된 상위(부모) 클래스의 모든 속성과 연산을 하위(자식) 클래스가 물려받는 것

- 소프트웨어의 재사용(Reuse)을 높이는 중요한 개념
8. 다중 상속(Multiple Inheritance)
- 한 개의 클래스가 두 개 이상의 상위(부모) 클래스로부터 속성과 연산을 상속받는 것
9. 다형성(Polymorphism)
- 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력

ex) ‘+’ 연산자의 경우 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능
#### 4. 결합도(Coupling) ⭐⭐
>[!summary] p.110, 1-49, 20년 1, 2, 3회 기출문제

- 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미
- 결합도는 낮을수록(﻿↓) Good = 독립적인 모듈
#내공외제스자 (Bad → Good) ⭐⭐
1. 내용 결합도(Content Coupling)
- 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
2. 공통 결합도(Common Coupling)
- 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 (전역 변수)
3. 외부 결합도(External Coupling)
- 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도 (순차적)
4. 제어 결합도(Control Coupling)
- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도

5. 스탬프 결합도(Stamp Coupling)
- 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
6. 자료 결합도(Data Coupling)
- 어떤 모듈이 다른 모듈을 호출하면서 매개 변수([[파라미터]])나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 결합도

#### 5. 응집도(Cohesion) ⭐⭐
>[!summary] p.111, 1-48, 20년 1, 2, 3회 기출문제

- 모듈의 내부 요소들의 서로 관련되어 있는 정도
- 응집도는 높을수록(↑) Good = 독립적인 모듈
#우논시절통순기 (Bad → Good) ⭐⭐
1. 우연적 응집도(Coincidental Cohesion)
- 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도
2. 논리적 응집도(Logical Cohesion)
- 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도

3. 시간적 응집도(Temporal Cohesion)
- 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
4. 절차적 응집도(Procedural Cohesion)
- 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도

5. 통신적(교환적) 응집도(Communication Cohesion)
- 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도

6. 순차적 응집도(Sequential Cohesion)
- 모듈 내 하나의 활동으로부터 나온 출력 데이터(출력값)를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도

7. 기능적 응집도(Functional Cohesion)
- 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

#### 6. 공통 모듈 ⭐
>[!summary] p.114, 1-47, 20년 1, 2회 기출문제

#정명완일추
1. 정확성(Correctness)
- 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
2. 명확성(Clarity) ⭐
- 해당 기능에 대해 일관되게 이해되고, 한 가지로 해석될 수 있도록 즉, 중의적으로 해석되지 않도록 명확하게 작성

3. 완전성(Completeness)
- 시스템 구현을 위해 필요한 모든 것을 기술
4. 일관성(Consistency)
- 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
5. 추적성(Traceability)
- 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

6. 재사용(Reuse) 규모에 따른 분류 __ 20년 4회 기출문제
- 함수와 **객**체, **컴**포넌트, **애**플리케이션
#### 7. 코드 ⭐⭐
>[!summary] p.116, 20년 1, 2, 3회 기출문제

- **식**별, **분**류, **배**열, **간**소화, **표**준화, **연**상, **암**호화, **오**류 검출 {기능}
#식분배간_표연암오
1. 순차(순서) 코드(Sequence Code, 일련 번호 코드) ⭐
- 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법




ex) 1, 2, 3, 4, …

2. 블록 코드(Block Code, 구분 코드) ⭐
- 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법


ex) 1001~1100: 총무부, 1101~1200: 영업부

3. 10진 코드(Decimal Code, 도서 분류식 코드) ⭐
- 0~9까지 10진 분할하고, 다시 각각에 대해 10진 분할하는 방법을 필요한 만큼 반복하는 방법


ex) 1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계

4. 그룹 분류 코드(Group Classification Code)
- 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법


ex) 1-01-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계

5. 연상 코드(Mnemonic Code, 기호 코드)
- 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법


ex) TV-40: 40인치 TV, L-15-220: 15W 220V 램프

6. 표의 숫자 코드(Significant Digit Code, 유효 숫자 코드) ⭐
- 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법


ex) 120-720-1500: 두께X폭X길이가 120X720X1500인 강판

7. 합성 코드(Combined Code)
- 2개 이상의 코드를 조합하여 만드는 방법


ex) 연상 코드+순차 코드 → KE-711: 대한항공 711기, AC-253: 에어캐나다 253기

8. 코드 부여 체계
- 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식

- 각 개체에 유일한 코드 부여하여 개체들의 식별 및 추출을 용이하게 함
- 코드를 부여하기 전 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드가 정의되야 함

ex) PJC-COM-003: 전체 시스템 단위의 3번째 공통 모듈

ex) PY3-MOD-010: PY3라는 단위 시스템의 10번째 모듈

#### 8. 디자인 패턴 ⭐⭐
>[!summary] p.119, 1-60, 20년 1, 2, 3회 기출문제

- 아키텍처 패턴이 디자인 패턴보다 상위 수준의 설계에 사용됨
- 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델
cf) 아키텍처 패턴은 전체 시스템의 구조를 설계하기 위한 참조 모델
#생구행
1. 생성 패턴(Creational Pattern) __ 20년 3회 기출문제 ⭐
- 추상 팩토리(Abstract Factory): 서로 연관, 의존하는 객체들을 그룹으로 생성해 추상적으로 표현

- **빌**더(Builder): 객체의 생성 과정과 표현 방법 분리 → 동일한 객체 생성에도 서로 다른 결과
- **팩**토리 메소드(Factory Method): 객체를 생성하기 위한 인터페이스를 정의하여, 어떤 클래스가 인스턴스화 될 것인지는 서브클래스가 결정하도록 하는 것(Virtual-Constructor 패턴)
- **프**로토타입(Prototype): 원본 객체를 복제하는 방법
- **싱**글톤(Singleton): 하나의 객체를 여러 프로세스가 동시에 참조할 수 없음

#추빌팩프싱

2. 구조 패턴(Structural Pattern) ⭐
- 어댑터(Adapter): 호환성이 없는 클래스 인터페이스를 이용할 수 있도록 변환해주는 패턴

- **브**리지(Bridge): 구현부에서 추상층을 분리하여, 독립적으로 확장 및 다양성을 가지는 패턴
- **컴**포지트(Composite): 여러 객체를 가진 복합, 단일 객체를 구분 없이 다룰 때 사용하는 패턴
- **데**코레이터(Decorator): 상속을 사용하지 않고도 객체의 기능을 동적으로 확장해주는 패턴
- **퍼**싸드(Façade): 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴; ex) 리모컨
- **플**라이웨이트(Flyweight): 공유해서 사용함으로써 메모리를 절약하는 패턴
- **프**록시(Proxy): 접근이 어려운 객체를 연결해주는 인터페이스 역할을 수행하는 패턴

#어브컴데_퍼플프

3. 행위 패턴(Behavioral Pattern)
- 책임 연쇄(Chain of Responsibility): 한 객체가 처리하지 못하면 다음 객체로 넘어가는 패턴

- 커맨드(Command): 요청에 사용되는 각종 명령어들을 추상, 구체 클래스로 분리하여 단순화함
- 인터프리터(Interpreter): 언어에 문법 표현을 정의하는 패턴
- 반복자(Iterator): 동일한 인터페이스를 사용하도록 하는 패턴
- 중재자(Mediator): 서로의 존재를 모르는 상태에서도 협력할 수 있게 하는 패턴
- 메멘토(Memento): 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
- 옵서버(Observer): 관찰대상의 변화를 탐지하는 패턴
- 상태(State): 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 전략(Strategy): 클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하는 패턴
- 템플릿 메소드(Template Method): 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에 정의하는 패턴
- 방문자(Visitor): 필요할 때마다 해당 클래스에 방문해서 처리하는 패턴

	- 산출물 : 생성 패턴과 구조 패턴에 해당 안되면 행위 패턴

### 인터페이스 설계
#### 1. 인터페이스 요구사항 검증 ⭐
>[!summary] p.135, 1-75

1. 요구사항 검증(Requirements Verification)
- 인터페이스 요구사항 검토 계획 수립 → 검토 및 오류 수정 → 베이스라인 설정
2. 요구사항 검증 방법 ⭐⭐ __ 20년 1, 2, 3회 기출문제
- 동료 검토(Peer Review): 요구사항 명세서 작성자가 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 검토 방법

- **워**크 스루(Walk Through): 검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후, 짧은 검토 회의를 통해 결함을 발견하는 검토 방법
- **인**스펙션(Inspection): 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 확인하면서 결함을 발견하는 검토 방법

#동워인

3. 인터페이스 요구사항 검증 주요 항목
- 기능성(Functionality), 완전성(Completeness), 일관성(Consistency), 명확성(Unambiguity), 검증 가능성(Verifiability), 추적 가능성(Traceability), 변경 용이성(Easily Changeable)


#기완일_명검추변

#### 2. 인터페이스 ⭐
>[!summary] p.140, 1-81

1. 인터페이스 식별
- 인터페이스 요구사항 명세서와 인터페이스 요구사항 목록을 기반으로 개발할 시스템과 이와 연계할 내, 외부 시스템 사이의 인터페이스를 식별하고 인터페이스 목록을 작성하는 것

2. 인터페이스 시스템 식별
- 인터페이스별로 인터페이스에 참여하는 시스템들을 송신 시스템과 수신 시스템으로 구분하여 작성하는 것

3. 인터페이스 표준 항목 ⭐
- 시스템 공통부: 시스템 간 연동 시 필요한 공통 정보
	- 산출물 : 인터페이스 ID, 전송 시스템 정보, 서비스 코드 정보, 응답 결과 정보, 장애 정보

- 거래 공통부: 시스템들이 연동된 후 송, 수신 되는 데이터를 처리할 때 필요한 정보
	- 산출물 : 직원 정보, 승인자 정보, 기기 정보, 매체 정보

	
#### 3. 인터페이스 방법 명세화 ⭐⭐
>[!summary] p.145, 1-98

1. 시스템 연계 기술 ⭐⭐
- 직접 연계 방식

- DB **링**크(DB link): 수신 시스템에서 DB Link를 생성하고 송신 시스템에서 해당 DB 링크를 직접 참조하는 방식
ex) 테이블명@DB Link명
- DB 연결(DB **Con**nection): 수신 시스템의 WAS에서 송신 시스템 DB로 연결하는 DB 커넥션 풀(DB Connection Pool)을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀명을 이용
ex) 송신 시스템의 Data Source = DB Connection Pool 이름
- **A**PI/Open API: 송신 시스템의 DB에서 데이터를 읽어와 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
	- 산출물 : Open API는 이런 기능을 누구나 무료로 사용할 수 있도록 공개된 API
- **J**DBC: 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템 DB와 연결
- **하**이퍼 링크(Hyper Link): 웹 애플리케이션에서 하이퍼링크 이용
ex) <a href=’url’>구글</a>

#링컨에제하

- 연계 솔루션: EAI 서버와 송, 수신 시스템에 설치되는 클라이언트를 이용하는 방식

- 간접 연계 방식

- **소**켓(Socket): 서버는 통신을 위한 소켓을 생성하여 포트를 할당하고 클라이언트의 통신 요청 시 클라이언트와 연결하는 네트워크 기술
- **웹** 서비스(Web Service): 웹 서비스에서 WSDL, UDDI, SOAP 프로토콜을 이용해 연계하는 서비스
	- 산출물 : WSDL(Web Services Description Language): 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어

	- 산출물 : UDDI(Universal Description, Discovery and Integration): 인터넷에서 전 세계의 비즈니스 업체 목록에 자신의 목록을 등록하기 위한 확장성 생성 언어(XML)기반의 규격

	- 산출물 : SOAP(Simple Object Access Protocol): 웹 서비스를 실제로 이용하기 위한 객체 간의 통신 규약

- ESB(Enterprise Service **Bus**): 개방형 표준인 웹 서비스를 이용하며, 메시징과 웹 서비스, 데이터 변형, 인텔리전트 라우팅을 결합하여 다양한 애플리케이션 간의 연결과 상호작용을 지원하는 표준기반의 미들웨어 플랫폼

#소웹버

2. 인터페이스 통신 유형
- 단방향: 시스템에서 거래 요청만 하고 응답은 없는 방식

- 동기(Sync): 시스템에서 거래 요청 후 응답이 올 때까지 대기(Request-Reply)하는 방식
ex) 은행 업무: 송금 버튼을 누르면 그 즉시 버튼에 대한 응답으로 돈이 송금됨
- 비동기(Async): 시스템에서 거래 요청 후 다른 작업을 수행하다 응답이 오면 처리하는 방식
ex) 채점하는 교수님: 시험지를 받고 채점하는 건 그 날 즉시해도, 다음 날 채점해도 상관없음

	- 산출물 : 동기, 비동기는 양방향

3. 인터페이스 처리 유형
- 실시간 방식: 사용자가 요청한 내용을 바로 처리해야 할 때 사용하는 방식

- **지**연 처리 방식: 매건 단위 처리로 비용이 많이 발생할 때 사용하는 방식
- **배**치 방식: 대량의 데이터를 처리할 때 사용하는 방식

#실지배

4. 인터페이스 발생 주기
- 매일, 수시, 주 1회 등
#### 4. 미들웨어 솔루션 명세 ⭐⭐
>[!summary] p.152 / 1-97, 20년 1, 2, 3회 기출문제

- 운영체제(OS)와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어
#디원메트_레객와
1. DB(Database)
- 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어, 2-Tier 아키텍처
	- 산출물 : ODBC(마이크로소프트), IDAPI(볼랜드), Glue(오라클)

2. RPC(Remote Procedure Call, 원격 프로시저 호출)
- 응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어
	- 산출물 : Entera(이큐브시스템스), ONC/RPC(OSF)
3. MOM(Message Oriented Middleware, 메시지 지향 미들웨어) ⭐
- 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
	- 산출물 : MQ(IBM), Message Q(오라클), JMS(JCP)

4. TP-Monitor(Transaction Processing Monitor, 트랜잭션 처리 모니터) ⭐
- 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어

- 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용됨
	- 산출물 : tuxedo(오라클), tmax(티맥스소프트)
5. Legacyware(레거시웨어)
- 기존 애플리케이션에 새로운 업데이트된 기능을 덧붙이고자 할 때 사용되는 미들웨어
6. ORB(Object Request Broker, 객체 요청 브로커) ⭐
- 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
* 코바(CORBA; Common Object Request Broker Architecture):
네트워크에서 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격을 의미


	- 산출물 : Orbix(Micro Focus), CORBA(OMG)

7. WAS(Web Application Server, 앱 애플리케이션 서버) ⭐
- 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어


cf) 웹 서버: 정적인 콘텐츠를 처리
- 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어

- HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능
#Web Logic(오라클), WebSphere(IBM), JEUS, Tomcat
###  추가 정리, 수제비 및 기출문제 ⭐⭐⭐
1. 플랫폼의 유형 __ 1-2
	- 싱글 사이드 플랫폼: 제휴 관계를 통해 소비자와 공급자를 연결하는 형태
		- ex) 아이튠즈, 안드로이드 마켓
	- **투** 사이드 플랫폼: 두 그룹을 중개하고 모두에게 개방하는 형태
		- ex) 소개팅 앱
	- **멀**티 사이드 플랫폼: 다양한 이해관계 그룹을 연결하여 중개하는 형태
		- ex) 페이스북, 인스타그램
2. 플랫폼 성능 특성 분석 기법 __ 1-3
	- 사용자 **인**터뷰, **성**능 테스트, **산**출물 점검 #인성산
3. OSI 7계층(Layer) ⭐⭐ __ 1-5
	- 응용 계층(Application Layer, 7): 사용자와 네트워크 간 응용서비스 연결, 데이터 생성
		- 산출물 : HTTP, FTP, TELNET, SMTP/SNTP, DNS
	- 표현 계층(**P**resentation Layer, 6): 데이터 형식 설정, 코드변환, 암/복호화
		- 산출물 : JPEG, MPEG
	- 세션 계층(**S**ession Layer, 5): 연결 접속(유지), 동기제어, 동기점(대화)
		- 산출물 : SSH, TLS
	- 전송 계층(**T**ransport Layer, 4): 종단간(End to End) 신뢰성 있고 효율적인 데이터 전송, 데이터 분할, 재조립, 흐름 제어(슬라이딩 윈도우), 오류 제어, 혼잡 제어
		- 산출물 : TCP/UDP, RTCP → 세그먼트(Segment)
	- 네트워크 계층(**Ne**twork Layer, 3): 단말기 간 데이터 전송을 위한 최적화된 경로(라우팅) 제공
		- 산출물 : IP, ICMP, IGMP, RIP, OSPF → 패킷(Packet)
	- 데이터 링크 계층(**Da**ta Link Layer, 2): 인접 시스템 간 물리적 연결을 이용해 데이터 전송, 동기화, 오류제어, 흐름 제어, 오류검출 및 재전송
		- 산출물 : HDLC, PPP, LLC, Ethernet(이더넷) → 프레임(Frame)
	- 물리 계층(**Phy**sical Layer, 1): 매체 간의 전기적, 기능적, 절차적 기능 정의
		- 산출물 : RS-232C → 비트(Bit)
4. **린(LEAN) __ 1-14** → 애자일(Agile) 방법론 유형 중 하나
	- 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화
5. CASE(Computer-Aided Software Engineering) 도구의 분류 __ 1-19, 1, 2회 기출문제
	- 상위 CASE: 계획수립, 요구분석, 기본설계 단계를 다이어그램으로 표현
		- 산출물 : 모순 검사, 오류 검증, 자료흐름도 작성 지원
	- **중**위 CASE
		- 산출물 : 상세 설계 작업, 화면 출력 작성 지원
	- **하**위 CASE
		- 산출물 : 시스템 명세서, 소스 코드 생성 지원
6. UI 컨셉션 세부 수행 활동 __ 1-33
	- 정보 구조 설계 → 대표 화면 와이어 프레임 스케치 → 페이퍼 프로토타입을 통한 스토리보드 설계
7. UI 설계 프로세스 __ 1-39
	- 문제 정의 → 사용자 모델 정의 → 작업 분석 → 컴퓨터 오브젝트 및 기능 정의 → 사용자 인터페이스 정의 → 디자인 평가


#문사작컴인디

8. 소프트웨어 설계 유형 __ 1-51
- **자**료 구조 설계, **아**키텍처 설계, **인**터페이스 설계, **프**로시저 설계
#자아인프
9. 소프트웨어 아키텍처 4+1뷰 __ 1-53
- **유**스케이스 뷰, **논**리 뷰, **프**로세스 뷰, **구**현 뷰, **배**포 뷰
#유논프구배
10) 럼바우의 객체 지향 분석 / 객체 모델링 기법(OMT) ⭐⭐ __ 1-59,
1, 2, 3, 4회 기출문제
- **객**체 모델링: 객체 다이어그램
- **동**적 모델링: 상태도 (상태 다이어그램)
- **기**능 모델링: 자료 흐름도
#객동기
11) 요구사항 관리 프로세스 __ 1-74, 5-6
- 요구사항 **협**상 → 요구사항 **기**준선 → 요구사항 **변**경관리 → 요구사항 **확**인 및 검증
#협기변확
12) 인터페이스 정의서 작성 __ 1-95
- **인**터페이스 ID, **최**대 처리 횟수, 데이터 **크**기(평균/최대), **시**스템 정보, **데**이터 정보
#인최크시데
13) 자료 흐름도(DFD; Data Flow Diagram) ⭐⭐ __ 개정 전 기출문제, 1, 2, 3회 기출문제
![[%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%201%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%AE%E1%84%85%E1%85%AD%E1%84%80%200d5432921ef740afb4edd35688908660/image1.png]]
**#PTSD** → **P**rocess, **T**erminator, Data **S**tore, **D**ata Flow
14) UML 확장 모델의 스테레오 타입 객체 표현 기호 __ 20년 1, 2회 기출문제
	- 산출물 : **<< >>**
15) 자료 사전 기호 __ 개정 전 기출문제, 20년 1, 2, 3회 기출문제
| --- | --- |
16)** ﻿객체지향 기법에서 클래스들 사이의 **'부분-전체(part-whole)'**관계 또는 **'부분(is-a-part-of)'**의 관계로 설명되는 **연관성을 나타내는 용어**는? **__ 20년 1, 2회 기출문제
① 일반화 ② 추상화 ③ 캡슐화 ④ **집단화**
① 일반화(Generalization)
일반화는 객체들에 있어 공통적인 성질들을 상위 객체로 정의하고, 특수화(specialization)된 객체들을 하위의 부분형(subtype) 객체로 정의하는 추상화 방법이다.
② 추상화(Abstraction)
현실 세계의 물체를 객체에 사상할 때에는 현실을 그대로 객체로서 표현하는 것이 아니고, 문제의 중요한 측면, 혹은 주목하고 싶은 문제의 측면을 강조한다. 즉, 불필요한 부분을 생략하고 객체의 가장 중요한 것에만 중점을 두어 간략화 시킨 것을 말한다.
③ 캡슐화(Encapsulation)
객체의 자료와 행위를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것을 캡슐화라고 한다. 이렇게 캡슐화 된 객체의 행위는 외부에서 볼 때는 실제가 아닌 추상적인 것이 되므로 정보 은닉(information hiding)개념이 지켜진다.
+ 정보 은닉은 객체가 캡슐화를 통하여 내부의 데이터나 [[오퍼레이션]]의 구현 내용을 감추는 것을 말한다. 즉, 외부에서의 무분별한 접근을 허용하지 않는다는 것이다.
④ 집단화(Aggregation)
집단화는 **서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체를 만드는 것**이다. 집단화는 여러 개의 속성을 묶어 사용자 정의형의 엔티티를 만드는 수단으로 사용한다. 한 객체에서 하나 이상의 객체는 사용자 표정의 형이 될 때 복합 객체(composite object)라고 불린다. 즉, 집단화는 **복합 객체의 종속 성분을 모델링하기 위해 사용**되며, 이들 복합 성분 클래스 관계를 통해 복합 속성 계층(composite attribute hierarchy)을 형성한다.
17) HIPO(Hierarchy Input Process Output) __ 개정 전 기출문제, 20년 1, 2회 기출문제
- 하향식 소프트웨어 개발을 위한 문서화 도구
- HIPO 차트 종류: 가시적 도표, 총체적 도표, 세부적 도표
- 기능과 자료의 의존 관계를 동시에 표현할 수 있음
- 보기 쉽고 이해하기 쉬움
18) 객체지향 분석 방법론 __ 개정 전 / 20년 1, 2회 / 21년 1회 기출문제
- Coad와 Yourdon 방법 ⭐
- E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것
- Booch 방법
-미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법

- Jacobson 방법
- 유스케이스(Use Case, 사용사례)를 강조하여 사용하는 분석 방법
- Wirfs-Brocks 방법
-분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 분석 방법

19) UML의 시퀀스 다이어그램의 구성 항목 __ 20년 3회 기출문제
- **생명선**(Life line), **실행**(Activation, 활성 박스), **메시지**(Message)
#생실메
20) 객체지향 설계 원칙 ⭐ __ 개정 전 기출문제, 20년 3회 기출문제
| --- | --- |
#SOLID
21) 디자인 패턴 구성요소 __ 20년 3회 기출문제
| --- | --- |
#패문솔 사결샘
22) DBC(Design by Contract, 계약에 의한 설계) __ 20년 3회 기출문제
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%201%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%AE%E1%84%85%E1%85%AD%E1%84%80%200d5432921ef740afb4edd35688908660/image2.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%201과목%20소프트웨어%20설계%20무료ᄀ%200d5432921ef740afb4edd35688908660/image2.png)
- 프로그램 모듈들의 책임을 문서화하는데 초점을 맞춤
- 각각의 모듈이 가져야 하는 기능만큼만 동작하도록 함
- 위의 개념들을 문서화하고 검증하는 것이 핵심임
23) CASE(Computer-Aided Software Engineering) 도구 __ 20년 3, 4회 기출문제
- 소프트웨어 개발 과정의 일부 또는 전체를 자동화하기 위한 도구
- 표준화된 개발 환경 구축 및 문서 자동화 기능 제공
- 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션 증대
**주요기능**: S/W 라이프 사이클 전 단계의 연결, 그래픽 지원, 다양한 소프트웨어 개발 모형 지원

##  2. 소프트웨어 개발
### 데이터 입출력 / 통합 구현
#### 1. 자료구조 ⭐⭐
>[!summary] p.162, 2-2

##### 자료 구조의 분류
- 선형 구조(Linear Structure)
	- 배열(Array)
		- 정적인 자료 구조로 기억장소의 추가가 어렵고 메모리의 낭비가 발생함
		- 첨자를 이용
		- 반복적인 데이터 처리 작업에 적합한 구조
		- 데이터마다 동일한 이름의 변수를 사용해 처리가 간편함
	- 스택(Stack)
		- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이뤄지는 자료 구조
		- 후입선출(LIFO; Last In First Out) 방식
	- 큐(Queue)
		- 리스트의 한쪽에서는 삽입 작업, 다른 한쪽에서는 삭제 작업이 이뤄지는 자료 구조
		- 선입선출(FIFO;First In First Out) 방식
		- 시작(F, Front)과 끝(R, Rear)을 표시하는 두 개의 포인터가 있음
		- 운영체제의 작업 스케줄링에 사용함
	- 데크(Deque)
		- 리스트의 양쪽 끝에서 삽입과 삭제작업을 할 수 있는 자료 구조
	- 선형 리스트(Linear List) = 연속 리스트(순차적임), 연결 리스트(순차적이지 않음)
		- 연속 리스트(Contiguous List)
			- 배열과 같이 연속되는 기억장소에 저장되는 자료 구조
			- 기억장소를 연속적으로 배정받아, 기억장소 이용 효율은 밀도가 1로서 가장 좋음
			- 중간에 데이터를 삽입하기 위해 연속된 빈 공간이 있어야함
			- 삽입, 삭제 시 자료의 이동이 필요함
		- 연결 리스트(Linked List)
			- 자료들을 반드시 연속적으로 배열시키지 않고 임의의 기억공간을 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용해 서로 연결시킨 자료 구조
			- 노드의 삽입, 삭제 작업이 용이
			- 기억공간이 연속적으로 놓여 있지 않아도 저장가능
			- 연결을 위한 포인터가 필요하기 때문에 순차 리스트에 비해 기억 공간의 효율이 좋지 않음
			- 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느림
			- 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘듦
- 비선형 구조(Non-Linear Structure)
	- 트리(Tree) ⭐⭐
		- 정점(Node, 노드)과 선분(Branch, 가지)을 이용해 사이클을 이루지 않도록 구성한 그래프(Graph)의 특수한 형태
		- 노드(Node): 트리의 기본 요소, 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것
			- 근 노드(Root Node): 트리의 맨 위에 있는 노드
			- **디그리(Degree, 차수)**: 각 노드에서 뻗어 나온 가지의 수 ⭐
			- **단말 노드(Terminal Node)**: 자식이 하나도 없는 노드, Degree가 0인 노드 ⭐
			- 자식 노드(Son Node): 어떤 노드에 연결된 다음 레벨의 노드들
			- 부모 노드(Parent Node): 어떤 노드에 연결된 이전 레벨의 노드들
			- 형제 노드(Brother Node, Sibling): 동일한 부모를 갖는 노드들
		- 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수
			- 산출물 : **차수(Degree)**와 **단말(Terminal)의 수**를 물어보는 기출문제 多 **__ 1, 2, 3회 기출문제**![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%202%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%86%E1%85%AE%E1%84%85%E1%85%AD%E1%84%80%2031d0cdc6647a4f2c98fb48fdcd7d5458/image1.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%202과목%20소프트웨어%20개발%20무료ᄀ%2031d0cdc6647a4f2c98fb48fdcd7d5458/image1.png)
		- **차수(Degree):** **3** - D, E, F (B의 자식 노드)
		- **단말(Terminal): 5** - D, E, H, I, G (자식이 하나도 없는 노드)
	- 그래프(Graph)
		- 방향 그래프
			- 정점을 연결하는 선에 방향이 있는 그래프
			- n개의 정점으로 구성된 방향 그래프의 최대 간선 수 = n(n-1)
		- 무방향 그래프
			- 정점을 연결하는 선에 방향이 없는 그래프
			- n개의 정점으로 구성된 무방향 그래프의 최대 간선 수 = n(n-1)/2

#### 2. 데이터베이스 / DBMS ⭐
>[!summary] p.168

1.  데이터베이스(Database) ⭐ #공통운저
	- 공용 데이터(Shared Data): 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료
	- **통**합된 데이터(Integrated Data): 자료의 중복을 최대로 배제한 데이터의 모임
	- **운**영 데이터(Operational Data): 고유한 업무를 수행하는 데 없어서는 안 될 자료
	- **저**장된 데이터(Stored Data): 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
2. DBMS(Database Management System; 데이터베이스 관리 시스템)
	- 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어
	- 정의 기능: 데이터베이스에 저장될 데이터의 타입과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능 → **DDL**
	- 조작 기능: 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능 → **DML**
	- 제어 기능: 무결성, 보안, 권한, 병행 제어 → **DCL**

#### 3. 데이터 입, 출력 ⭐⭐
>[!summary] p.171

1. [[SQL]](Structured Query Language)
	- 1974년 IBM 연구소에서 개발한 SEQUEL에서 유래함
	- 관계대수와 관계해석을 기초로 한 혼합 데이터 언어
	- 데이터 정의어(DDL; Data Define Language): DOMAIN(**도**메인), SCHEMA(**스**키마), TABLE(**테**이블), VIEW(**뷰**), INDEX(**인**덱스)를 **정의**하거나 **변경** 또는 **삭제**할 때 사용하는 언어 #도스테뷰인
	- 데이터 조작어(DML; Data Manipulation Language)
		- SELECT(검색), INSERT(삽입), UPDATE(갱신), DELETE(삭제)로 저장된 데이터를 실질적으로 처리하는 데 사용하는 언어
	- 데이터 제어어(DCL; Data Control Language)
		- 데이터의 무결성, 보안, 회복, 병행 제어 등을 정의하는 데 사용되는 언어
2. 데이터 접속(Data Mapping) __ 2-18
	- 소프트웨어의 기능 구현을 위해 프로그래밍 코드와 데이터베이스의 데이터를 연결(Mapping)하는 것을 말함
	- **[[SQL]] Mapping**: 프로그래밍 코드 내 [[SQL]]을 직접 입력해 DBMS의 데이터에 접속하는 기술 ⭐
		- 산출물 : JDBC, ODBC, MyBatis
	- **ORM**(Object-Relational Mapping): 객체(Object)와 관계형데이터베이스(RDB)의 데이터를 연결(Mapping)하는 기술 ⭐
		- 산출물 : JPA, Hibernate, Django
3. 트랜잭션(Transaction) ⭐⭐ __ 2-19
	- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
	- 한꺼번에 모두 수행되어야 할 일련의 연산들
	- COMMIT: 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어
	- ROLLBACK: 트랜잭션 처리가 비정상으로 종료되어 DB의 길관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산
	- SAVEPOINT(=CHECKPOINT): 트랜잭션 내에서 ROLLBACK할 위치인 저장점을 지정하는 명령어, 여러 개의 SAVEPOINT 지정 가능
	-  트랜잭션의 특징 #ACID
| 원리                       | 특징                                                                             |
| -------------------------- | -------------------------------------------------------------------------------- |
| 원자성(Atomicity)          | 트랜잭션 연산을 데이터베이스 모두에 반영 또는 반영하지 말아야 함(All or Nothing) |
| 일관성 (Consistency)       | 트랜잭션이 실행을 성공적으로 완료할 시 일관성 있는 데이터베이스 상태를 유지      |
| 독립성 (Isolation, 격리성) | 둘 이상 트랜잭션 동시 실행 시 한 개의 트랜잭션만 접근이 가능하여 간섭 불가       |
| 영속성 (Durability)  |  성공적으로 완료된 트랜잭션 결과는 영구적으로 반영됨                                          |


#### 4. 절차형 [[SQL]] ⭐
>[!summary] p.173, 2-22

1. 개요
	- C, JAVA 등의 프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 [[SQL]]
	- 일반적인 프로그래밍 언어에 비해 효율이 떨어짐
	- 연속적인 작업들을 처리하는데 적합
	- BEGIN ~ END 형식으로 작성되는 블록(Block) 구조로 기능별 모듈화 가능
	- 프로시저(Procedure): 호출을 통해 실행되어 미리 저장해 놓은 [[SQL]] 작업 수행, 처리 결과는 한 개 이상의 값 혹은 반환을 아예 하지 않음
	- **트리거(Trigger)**: 입력, 갱신, 삭제 등의 이벤트가 발생할 때마다 관력 작업을 자동 수행
	- **사용자 정의 함수**: 프로시저와 유사하게 [[SQL]]을 사용해 일련의 작업을 연속적으로 처리함, 종료 시 예약어 RETURN을 사용해 처리 결과를 단일값으로 반환
2. 테스트와 디버깅
	- 테스트 전 구문 오류(Syntax Error)나 참조 오류의 존재 여부 확인
	- 오류 및 경고 메시지가 상세히 출력되지 않으므로 SHOW 명령어를 통해 내용 확인
	- 실제로 데이터베이스에 변화를 줄 수 있는 삽입 및 변경 관련 SQL문을 주석으로 처리하고 디버깅 수행
3. 쿼리 성능 최적화
	- 데이터 입, 출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화하는 것
	- 성능 측정 도구 APM(Application Performance Management/Monitoring)을 사용해 최적화할 쿼리를 선정
	- 최적화할 쿼리에 대해 옵티마이저(Optimizer)가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스 재구성
#### 5. 개발 지원 도구 ⭐⭐
>[!summary] p.186, 2-38

1. 통합 개발 환경(IDE; Integrated Development Environment)
	- 개발에 필요한 환경, 즉 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등의 다양한 툴을 하나의 인터페이스로 통합해 제공하는 것을 의미함
		- [[이클립스]](Eclipse) … IBM
		- 비주얼 스튜디오(Visual Studio) … Microsoft
		- 엑스 코드(X Code) … Apple
		- 안드로이드 스튜디오(Android Studio) … Google
		- IDEA … JetBrains
2. 빌드 자동화 도구 __ p.218, 2-70
	- 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리(Preprocessing), 컴파일(Complie) 등의 작업들을 수행하는 소프트웨어
	- **Ant(Another Neat Tool)**
		- 아파치 소프트웨어 재단에서 개발한 소프트웨어
		- 자바 프로젝트의 공식적인 빌드 자동화 도구
		- XML 기반의 빌드 스크립트를 사용
		- 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의
		- 스크립트의 재사용이 어려움
	- **Maven**
		- 아파치 소프트웨어 재단에서 Ant의 대안으로 개발
		- 규칙이나 표준이 존재해 예외 사항만 기록됨
		- 컴파일과 빌드를 동시에 수행할 수 있음
		- 의존성(Dependency)을 설정하여 라이브러리를 관리
	- **Gradle ⭐**
		- 기존의 Ant와 Maven을 보완해 개발된 빌드 자동화 도구
		- 안드로이드 스튜디오(안드로이드 앱 개발)의 공식 빌드 도구
		- Maven과 동일하게 의존성(Dependency) 활용
		- 그루비(Groovy) 기반의 빌드 스크립트 사용
		- 플러그인을 설정하면, JAVA, C/C++, Python 등의 언어도 빌드 가능
		- 실행할 처리 명령들을 모아 태스크(Task)로 만든 후 태스크 단위로 실행
		- 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능 지원 → 빌드의 속도 향상
	- **Jenkins ⭐**
		- JAVA 기반의 오픈 소스 형태로 가장 많이 사용되는 빌드 자동화 도구
		- 서블릿 컨테이너에서 실행되는 서버 기반 도구
		- SVN, Git 등 대부분의 형상 관리 도구와 연동 가능
		- 친숙한 Web GUI 제공
		- 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능
3. 기타 협업 도구(Groupware, 그룹웨어)
| 종류                | 내용                                      |
|-------------------|-----------------------------------------|
| 일정 관리 도구          | 구글 캘린더                                  |
| 프로젝트 관리 도구        | 트렐로(Trello), 지라(Jira)                   |
| 정보 공유 및 커뮤니케이션 도구 | 슬랙(Slack), 잔디(Jandi), 태스크월드(Task world) |
| 디자인 도구            | 스케치(Sketch), 제플린(Zeplin)                |
| 아이디어 공유 도구        | 에버노트(Evernote)                          |
| 형상 관리 도구          | 깃허브(GitHub)                             |

### 제품소프트웨어 패키징
#### 1. 소프트웨어 패키징 ⭐
>[!summary] p.194, 2-44

1. 개요
- 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것

- 개발자가 아닌 사용자를 중심으로 진행
2. 고려사항
- 운영체제(OS), CPU, 메모리 등에 필요한 최소 환경을 정의

- 하드웨어와 함께 관리될 수 있도록 Managed Service형태로 제공
- 다양한 사용자의 요구사항 반영
3. 패키징 작업 순서
- 기능 식별 → 모듈화 → 빌드 진행 → 사용자 환경 분석 → 패키징 및 적용 시험 → 패키징 변경 개선 → 배포


#식모빌_환패변

4. 제품 소프트웨어 패키징 도구 활용 시 고려사항 ⭐ __ 20년 1, 2, 3회 기출문제
- 패키징 시 사용자에게 배포되는 SW이므로 보안 고려
- 사용자 편의성을 위한 복잡성 및 비효율성 문제 고려
- 제품 SW종류에 적합한 암호화 알고리즘 적용
- 다양한 이기종 연동 고려
#### 2. 릴리즈 노트 ⭐
>[!summary] p.196, 2-46

1. 릴리즈 노트(Release Note)의 개요
	- 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 고객과 공유하기 위한 문서
	- 개선된 작업이 있을 때마다 관련 내용을 릴리즈 노트에 담아 제공
	- 개발팀에서 제공하는 소프트웨어 사양에 대한 최종 승인을 얻은 후 문서화되어 제공
2. 초기 버전 작성 시 고려사항
| 항목             | 내용                                                                                                                                 |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| Header(머리말) ★ | 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 릴리즈 노트 버전 등 <br> (20년 1회차 #실기 #기출문제) |
| 개요             | 소프트웨어 및 변경사항 전체에 대한 간략한 내용                                                                                       |
| 목적             | 해당 릴리즈 버전에서의 새로운 기능이나 수정된 기능의 목록과 릴리즈 노트의 목적에 대한 간략한 개요                                    |
| 문제 요약        | 수정된 버그에 대한 간략한 설명 또는 릴리즈 추가 항목에 대한 요약                                                                     |
| 재현 항목        | 버그 발견에 대한 과정 설명                                                                                                           |
| 수정/개선 내용   | 버그를 수정/개선한 내용을 간단히 설명                                                                                                |
| 사용자 영향도    | 사용자가 다른 기능들을 사용하는데 있어 해당 릴리즈 버전에서의 기능 변화가 미칠 수 있는 영향에 대한 설명                              |
| SW 지원 영향도   | 해당 릴리즈 버전에서의 기능 변화가 다른 응용 프로그램들을 지원하는 프로세스에 미칠 수 있는 영향에 대한 설명                          |
| 노트             | SW/HW 설치 항목, 업그레이드, 소프트웨어 문서화에 대한 참고 항목                                                                      |
| 면책 조항        | 회사 및 소프트웨어와 관련하여 참조할 사항   <br> ex) 프리웨어, 불법 복제 금지 등                                                     |
| 연락처           | 사용자 지원 및 문의 응대를 위한 연락처 정보                                                                                          |


3. 추가 버전 작성 시 고려사항
	- 베타 버전이 출시되거나 긴급한 버그 수정, 업그레이드와 같은 자체 기능 향상, 사용자 요청 등의 특수한 상황이 발생하는 경우 추가로 작성
	- 버그 번호를 포함한 모든 수정된 내용을 담아 릴리즈 노트 작성
	- 추가나 수정된 경우 자체 기능 향상과는 다른 별도의 릴리즈 버전 출시하고 릴리즈 노트 작성
4. 릴리즈 노트 작성 순서
	- 모듈 식별 → 릴리즈 정보 확인 → 릴리즈 노트 개요 작성 → 영향도 체크 → 정식 릴리즈 노트 작성 → 추가 개선 항목 식별


#식정개_영정추

#### 3. 디지털 저작권 관리 ⭐⭐
>[!summary] p.200, 2-51,  디지털 콘텐츠의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술
1. 디지털 저작권 관리(DRM; Digital Right Management)의 흐름 ⭐
	- 콘텐츠 제공자(Contents Provider): 콘텐츠를 제공하는 저작권자

콘텐츠 분배자(Contents Provider): 암호화된 콘텐츠를 유통하는 곳이나 사람
콘텐츠 소비자(Customer): 콘텐츠를 구매해서 사용하는 주체

- **패**키저(Packager): 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
- **클**리어링 하우스(Clearing House): 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 결제관리 등을 수행하는 곳
- DRM **컨**트롤러(DRM Controller): 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
- **보**안 컨테이너(Security Container): 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

#콘패클컨보

2. 디지털 저작권 관리의 기술 요소** ⭐ **__ 2-110, 20년 1, 2, 3회 기출문제
- 암호화(Encryption): 콘텐츠 및 라이선스를 암호화하고 전자서명을 할 수 있는 기술

- **키** 관리(Key Management): 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
- **식**별 기술(Identification): 콘텐츠에 대한 식별 체계 표현 기술
- **저**작권 표현(Right Expression): 라이선스의 내용 표현 기술
- 암호화 **파**일 생성(Packager): 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
- **정**책 관리(Policy Management): 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- **크**랙 방지(Tamper Resistance): 크랙에 의한 콘텐츠 사용 방지 기술
- **인**증(Authentication): 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

#암키식저_파정크인

#### 4. 형상 관리 ⭐⭐
>[!summary] p.210, 2-40

1. 소프트웨어 패키징의 형상 관리(SCM; Software Configuration Management)
	- 형상 관리는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동임
	- 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행
2. 형상 관리의 중요성
	- 소프트웨어의 변경 사항을 체계적으로 추적하고 통제할 수 있음
	- 제품 소프트웨어에 대한 무절제한 변경 방지
	- 진행 정도를 확인하기 위한 기준으로 사용될 수 있음
3. 형상 관리 기능
	- 형상 식별: 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
	- 형상 **통**제(변경 관리): 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(베이스 라인, Base line)이 잘 반영될 수 있도록 조정하는 작업
	- 형상 **감**사: 기준선(베이스 라인)의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
	- 형상 **기**록(상태 보고): 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

#식통감기

- 버전 제어: 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구(Tool)를 결합시키는 작업
4. 소프트웨어 버전 등록 관련 주요 용어
| 명령어              | 설명                                                                          |
|------------------|-----------------------------------------------------------------------------|
| 저장소 (Repository) | 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳                                        |
| 가져오기 (Import)    | 버전 관리가 되고 있지 않은 아무것도 없는 저장소(Repository)에 처음으로 파일을 복사하는 것                    |
| 체크아웃 (Check-Out) | 프로그램을 수정하기 위해 저장소(Repository)에서 파일을 받아오는 것                                  |
| 체크인 (Check-In)   | 체크아웃 한 파일의 수정을 완료한 후, 저장소(Repository)의 파일을 새로운 버전으로 갱신하는 것                  |
| 커밋 (Commit)      | 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌(Confilct)을 알리고 diff도구를 이용해 수정한 후, 갱신을 완료함 |
| 동기화 (Update)     | 저장소에 있는 최신 버전으로 자신의 작업 공간(로컬/지역 저장소)을 동기화하는 것                               |

5. 소프트웨어 버전 등록 과정
- 가져오기(Import) → 인출(Check-Out) → 예치(Commit) → 동기화(Update) → 차이(Diff)


#임체컴업디

6. 제품 소프트웨어의 형상 관리 역할 ⭐ __ 20년 3회 기출문제
- 형상 관리를 통해 이전 리비전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용

- 불필요한 사용자의 소스 수정 제한
- 동일한 프로젝트에 대해 여러 개발자 동시 개발 가능
#### 5. 버전 관리 도구 ⭐⭐
>[!summary] p.213, 2-67

1. 공유 폴더 방식
- 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식

- 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사함
- 담당자는 공유 폴더의 파일을 자기 PC로 복사해 컴파일 한 후 이상 유무 확인
- 파일의 변경 사항을 데이터베이스에 기록하며 관리

	- 산출물 : SCCS, RCS, PVCS, QVCS

2. 클라이언트/서버 방식
- 버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리되는 방식

- 서버의 자료를 개발자별로 자신의 PC(클라이언트)로 복사해 작업한 후 변경된 내용을 중앙 서버에 반영
- 모든 버전 관리는 서버에서 수행됨
- 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력
- 서버에 문제가 생기면 다른 개발자와의 협업 및 버전 관리 작업은 중단됨

	- 산출물 : CVS, SVN(Subversion)

3. 분산 저장소 방식
- 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식

- 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사해 작업한 후 변경 된 내용을 로컬 저장소에서 우선 반영(Commit)한 다음 이를 원격 저장소에 반영(Push)
- 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용해 작업 가능
- 로컬 저장소에서 작업을 수행할 수 있어 처리속도가 빠름

	- 산출물 : Git, Bitkeeper

4. SVN(Subversion)
- CVS를 개선한 것으로 아파치 소프트웨어 재단에서 2000년 발표함

- 모든 개발 작업은 trunk 디렉터리에서 수행되며, 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업을 완료한 후 trunk 디렉터리와 병합(merge)
- 커밋(Commit)할 때마다 리비전(Revision)이 1씩 증가
- 서버는 주로 유닉스(UNIX) 사용
- 오픈 소스로 무료사용 가능
- CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능
| --- | --- |
5. Git(깃) ⭐
- 리누스 토발즈(Linus Torvalds)가 2005년 리눅스 커널 개발에 사용할 관리 도구로 개발한 이후 주니오 하마노(Junio Hamano)에 의해 유지 보수되고 있음

- 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳으로, 자신의 버전 관리 내역을 반영(Push)하거나 다른 개발자의 변경 내용을 가져올 때(Fetch) 사용
- 로컬 저장소는 개발자들이 본인의 실제 개발을 진행하는 장소로 버전 관리가 수행됨
- 브랜치(Branch)를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅 가능
- 파일의 변화를 스냅샷(Snapshot)으로 저장
- 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름 파악 가능
| --- | --- |
	- 산출물 : git init → git remote add → git add -all → git commit → git push

### 애플리케이션 테스트 관리
#### 1. 애플리케이션 테스트 ⭐⭐
>[!summary] p.224, 2-78

1. 애플리케이션 테스트의 개념
- 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차

- 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인(Validation)
- 소프트웨어가 기능을 정확히 수행하는지 검증(Verification)
2. 애플리케이션 테스트의 기본 원리 ⭐ __ 20년 1, 2회 기출문제
| --- | --- |
#결완초집 살정오

#### 2. 애플리케이션 테스트의 분류 ⭐⭐
>[!summary] p.227, 2-33

1. 프로그램 실행 여부에 따른 테스트
- 정적 테스트: 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트
	- 산출물 : 워크 스루, 인스펙션, 코드 검사

- 동적 테스트: 프로그램을 실행하여 오류를 찾는 테스트
	- 산출물 : 화이트박스 테스트, 블랙박스 테스트
⭐ 테스트 = 검사
2. 테스트 기반에 따른 테스트
- 명세 기반 테스트: 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
	- 산출물 : 동등 분할, 경계값 분석(블랙박스 테스트)

- **구**조 기반 테스트: 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
	- 산출물 : 구문 기반, 결정 기반, 조건 기반(화이트박스 테스트)
- **경**험 기반 테스트: 테스터의 경험을 기반으로 수행하는 테스트
	- 산출물 : 에러 추정, 체크 리스트, 탐색적 테스팅

#명구경

3. 시각에 따른 테스트
- 검증(Verification) 테스트: 개발자의 시각에서 제품의 생산 과정을 테스트하는 것
	- 산출물 : 단위 테스트, 통합 테스트, 시스템 테스트

- 확인(Validation) 테스트: 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것
	- 산출물 : **인**수 테스트(알파 테스트, 베타 테스트) ⭐ **__ 1, 2, 3회 기출문제**
4. 목적에 따른 테스트
| --- | --- |
5. 테스트 커버리지 유형 __ 2-34
| --- | --- |
#구결조_조변다
#### 3. 화이트박스 테스트, 블랙박스 테스트 ⭐⭐⭐
>[!summary] p.229, 2-33, 2-77

1. 화이트박스 테스트(White Box Test) __ 20년 1, 2, 3회 기출문제
- 모듈 안의 내용(작동)을 직접 볼 수 있음
- 내부의 **논리적인** 모든 경로를 테스트해 테스트 케이스를 설계
- 소스 코드(Source Code)의 모든 문장을 한번 이상 수행함으로써 진행됨
- 선택, 반복 등의 부분들을 수행함으로써 **논리적** 경로 점검
| --- | --- |
#기조루흐
2. 블랙박스(Black Box Test) __ 20년 1, 2, 3회 기출문제
- 모듈 안에서 어떤 일(작동)이 일어나는지 알 수 없음

- 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트로 기능 테스트라고도 함
- 소프트웨어 인터페이스에서 실시되는 테스트
| --- | --- |
#동경원비오
#### 4. 개발 단계에 따른 애플리케이션 테스트 ⭐
>[!summary] p.232

#단통시인
1. 단위 테스트(Unit Test)
- 코딩 직후 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트 하는 것
- 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행
- 명세 기반 테스트, 구조 기반 테스트 중 주로 구조 기반 테스트를 시행함
2. 통합 테스트(Integration Test) __ 2-87
- 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미

- 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류 검사
	- 산출물 : **빅**뱅 테스트, **상**향식 테스트(클러스터, Cluster/드라이버, Driver), **하**향식 테스트(스텁, Stub)
3. 시스템 테스트(System Test)
- 개발된 소프트웨어가 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
- 실제 사용 환경과 유사하게 만든 테스트 환경에서 테스트 수행해야 함
- 기능적 요구사항(블랙박스 테스트), 비기능적 요구사항(화이트박스 테스트) 구분
4. 인수 테스트(Acceptance Test) ⭐
- 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두는 테스트
| --- | --- |
#### 5. 통합 테스트 ⭐⭐
>[!summary] p.235, 2-87

1. 상향식 통합 테스트(Bottom Up Integration Test)
- 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법

- 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 **클러스터(Cluster)** 필요

- 하위 모듈들을 클러스터(Cluster)로 결합 → 더미 모듈인 **드라이버(Driver)** 작성 → 통합된 클러스터 단위로 테스트 → 테스트 완료 후 클러스터는 프로그램 구조의 상위로 이동해 결합하고 드라이버는 실제 모듈로 대체됨 ⭐

2. 하향식 통합 테스트(Top Down Integration Test) __ 20년 1, 2, 3회 기출문제
- 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법

- 깊이 우선 통합법, 넓이 우선 통합법 사용
- 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음
- 상위 모듈에서는 테스트 케이스 사용하기 어려움

- 주요 제어 모듈은 작성된 프로그램을 사용, 주요 제어 모듈의 종속 모듈은 스텁(Stub)으로 대체 → 깊이 우선 또는 넓이 우선 등의 통합 방식에 따라 하위 모듈인 스텁(Stub)들이 한 번에 하나씩 실제 모듈로 교체됨 → 모듈이 통합될 때마다 테스트 실시 → 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시

	- 산출물 : **스텁(Stub)** ⭐

3. 혼합식 통합 테스트
- 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원하는 방식

- **샌드위치(Sandwich)**식 통합 테스트 방법
#### 6. 테스트 케이스 | 테스트 시나리오 | 테스트 오라클 | 테스트 하네스 ⭐⭐
>[!summary] p.242~248, 2-75

1. 테스트 케이스(Test Case)
- 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서

- 명세 기반 테스트(블랙박스 테스트)의 설계 산출물에 해당
- 미리 설계해두면 테스트 오류 방지 및 테스트 수행 자원의 낭비를 줄일 수 있음
2. 테스트 시나리오(Test Scenario)
- 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합

- 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서

- 작성 시 유의 사항

- 시스템별, 모듈별, 항목별 등과 같이 여러 개의 시나리오로 분리해 작성
- 사용자의 요구사항과 설계 문서 등을 토대로 작성
3. 테스트 오라클(Test Oracle)
- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입해 비교하는 활동


- 특징

- 제한된 검증: 모든 테스트 케이스에 적용할 수 없음
- 수학적 기법: 값을 수학적 기법을 이용해 구할 수 있음
- 자동화 기능: 프로그램 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있음
| --- | --- |
#참샘휴일

4. 테스트 하네스(Test Harness) ⭐ __ 2-86
| --- | --- |
#드스슈케스목

#### 7. 결함 관리 ⭐
>[!summary] p.250, 2-81

1. 결함 상태 추적
| --- | --- |
#분추에
2. 결함 추적 순서
| --- | --- |
3. 결함 심각도, 결함 우선순위
- 결함 심각도: 치명적(Critical) > 주요(Major) > 보통(Normal) > 경미(Minor) > 단순(Simple)

- 결함 우선순위: 치명적(Critical) > 높음(High) > 보통(Medium) > 낮음(Low)
#### 8. 애플리케이션 성능 분석 ⭐⭐
>[!summary] p.254~257

1. 애플리케이션 성능 ⭐⭐ __ 20년 1, 2회 기출문제
| --- | --- |
#처응경자

2. 애플리케이션 성능 저하 원인 분석
- DB에 필요 이상의 많은 데이터를 요청한 경우

- 커넥션 풀(Connection Pool)의 크기를 너무 작거나 크게 설정한 경우
- JDBC나 ODBC 같은 미들웨어를 사용한 후 종료하지 않아 연결 누수가 발생한 경우
- 대량의 파일을 업로드하거나 다운로드해 처리 시간이 길어진 경우
3. 소스 코드 최적화
- 클린 코드(Clean Code) 작성 원칙


**#가단의중추** - **가**독성, **단**순성, **의**존성 배제, **중**복성 최소화, **추**상화

4. 소스 코드 품질분석 도구의 종류** ⭐ **__ 20년 1, 2회 기출문제
- 정적 분석 도구: pmd, cppcheck, checkstyle, SonarQube, ccm, cobertuna

- 동적 분석 도구: **A**valanche, **V**algrind
#### 9. 모듈 연계 ⭐⭐
>[!summary] p.267, 2-103

1. EAI(Enterprise Application Integration) __ 20년 1, 2회 기출문제
- 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션

| --- | --- |
#포허메하⭐
2. ESB(Enterprise Service Bus)
- 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션

- 애플리케이션 통합 측면에서 EAI와 유사하지만 애플리케이션 보다는 서비스 중심의 통합을 지향
- 결합도(Coupling)를 약하게(Loosely) 유지함
- 관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원이 가능

### 인터페이스 구현
#### 1. 인터페이스 구현 | 인터페이스 보안 ⭐⭐
>[!summary] p.276~281, 2-98, 2-112

1. 데이터 통신을 이용한 인터페이스 구현 __ 20년 1, 2회 기출문제
- 애플리케이션 영역에서 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송하고 이를 수신 측에서 파싱(Parsing)해 해석하는 방식

- 주로 JSON이나 XML형식의 데이터 포맷을 사용해 인터페이스를 구현
- **JSON**(JavaScript Object Notation): 속성-값 쌍(Attribut-Value Pairs)으로 이뤄진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷 ⭐
- **XML**(eXtensible Markup Language): 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어, 웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라우저에서 상호 호환적이지 못하다는 문제와 SGML(Stand Generalized Markup Language)의 복잡함을 해결하기 위해 개발됨 ⭐
2. 인터페이스 엔터티를 이용한 인터페이스 구현
- 인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔터티로 상호 연계하는 방식

- 일반적으로 인터페이스 테이블을 엔터티로 활용
- 송, 수신 인터페이스 테이블의 구조는 상황에 따라 서로 다르게 설계할 수도 있음
3. 인터페이스 보안 기능 적용 __ 2-108
- 네트워크(Network), 애플리케이션(Application), 데이터베이스(Database) 영역

- **스니핑**(Sniffing): 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형
- 소프트웨어 개발 보안(**시큐어 코딩**, Secure Coding): 소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동 ⭐

ex) **입**력 데이터 검증 표현, **보**안 기능, **시**간 및 상태, **에**러 처리, **코**드 오류, **캡**슐화, **A**PI 오용

#입보시_에코캡아

#### 2. 인터페이스 구현 검증 | 인터페이스 오류 확인 ⭐⭐
>[!summary] p.285~288, 2-119

1. 인터페이스 구현 검증 도구 ⭐ __ 20년 1, 2회 기출문제
| --- | --- |
#엑스피_엔셀와
2. 인터페이스 오류 발생 즉시 확인
- 오류 메시지 알람 표시, 오류 SMS 발송, 오류 내역 이메일 발송

3. 인터페이스 오류 발생 주기적인 확인
| --- | --- |
### 추가 정리, 수제비 및 기출문제 ⭐⭐⭐
1. 트리 순회방법 ⭐ __ 2-6, 20년 1, 2, 3회 기출문제
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%202%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%86%E1%85%AE%E1%84%85%E1%85%AD%E1%84%80%2031d0cdc6647a4f2c98fb48fdcd7d5458/image2.jpeg](image2.jpeg)
- **전**위 순회(Pre-Order Traversal): Root → Left → Right
- **중**위 순회(In-Order Traversal): Left → Root → Right
- **후**위 순회(Post-Order Traversal): Left → Right → Root
2. 이진 트리 __ 2-6
- 디그리(Degree, 차수)가 2이하인 노드로 구성돼 자식이 둘 이하로 구성된 트리
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%202%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%86%E1%85%AE%E1%84%85%E1%85%AD%E1%84%80%2031d0cdc6647a4f2c98fb48fdcd7d5458/image3.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%202과목%20소프트웨어%20개발%20무료ᄀ%2031d0cdc6647a4f2c98fb48fdcd7d5458/image3.png)
3. 논리 데이터 저장소 __ 2-9
| --- | --- |
#개속관
4. 물리 데이터 저장소 __ 2-13
- 논리 데이터 저장소에서 물리 데이터 저장소 모델로 변환하는 절차


단위 개체를 테이블로 변환 → 속성을 컬럼으로 변환 → UID(Unique Identifier)를 기본 키(Primary Key)로 변환 → 관계를 외래 키(Foreign Key)로 변환 → 컬럼 유형(Type)과 길이(Length) 정의 → 반정규화(De-normalization) 수행

5. 인덱스(Index) __ 2-15
- 분포도(Selectivity) 10~15% 이내


- 인덱스 컬럼 선정

- 수정이 빈번하지 않는 “컬럼”
- ORDER BY, GROUP BY, UNION이 빈번한 “컬럼”
- 분포도가 좋은 컬럼은 단독 인덱스로 생성
- 인덱스들이 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성

- 설계 시 고려사항

- 지나치게 많은 인덱스는 오버헤드(Overhead) 발생
- 인덱스만의 추가적인 저장 공간이 필요
- 넓은 범위 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킴
6. 뷰(View) __ 2-16
- 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블로 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같음

- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않지만 사용자에게 있는 것처럼 간주됨
- 데이터의 논리적 독립성을 제공할 수 있음
- 정의된 뷰로 다른 뷰를 정의할 수 있음
- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨
| --- | --- |
- 장점
-논리적 데이터 독립성 제공

- 접근 제어를 통한 자동 보안 제공

- 단점

- 독립적인 인덱스를 가질 수 없음
- 뷰의 정의를 ALTER로 변경할 수 없음 → DROP하고 새로 CREATE해야 함
- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름
7. 클러스터(Cluster) __ 2-16
- 인덱스의 단점을 해결한 기법 → 분포도(Selectivity)가 넓을수록 오히려 유리함

- 분포도가 넓은 “테이블”의 클러스터링은 저장 공간의 절약이 가능
- 대량의 범위를 자주 액세스(조회)하는 경우 적용
- 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용

- 클러스터 테이블 선정

- 수정이 빈번하지 않는 “테이블”
- ORDER BY, GROUP BY, UNION이 빈번한 “테이블”
- 처리 범위가 넓어 문제가 발생하는 경우 단일 테이블 클러스터링
- 조인이 많아 문제가 발생되는 경우는 다중 테이블 클러스터링

- 설계 시 고려사항

- 조회 속도를 향상시켜주지만 입력, 수정, 삭제 시 성능이 저하됨(부하가 증가)
8. 파티션(Partition) __ 2-17, 20년 3회 기출문제
| --- | --- |
#레해리컴
- 파티션의 장점
-성능 향상, 가용성 향상, 백업 가능, 경합 감소
#성가백합

9. PL/SQL __ 2-22
| --- | --- |
#선실예
- 장점: **컴**파일 불필요, **모**듈화 기능, **절**차적 언어 사용, **에**러 처리
#컴모절에
- PL/SQL을 활용한 저장형 객체 활용
- 저장된 **프**로시저, 저장된 **함**수, 저장된 **패**키지, **트**리거(Trigger)
#프함패트
10) 단위 모듈 구현의 원리 __ 2-32
| --- | --- |
#정분추독

11) 알고리즘 설계 기법 ⭐ __ 2-92, 20년 3회 기출문제
| --- | --- |
#분동탐백
12) 시간 복잡도에 다른 알고리즘 ⭐⭐ __ 2-93, 20년 1, 2회 기출문제
| --- | --- | --- |
13) SW 품질 측정을 위해 개발자 관점에서 고려해야 할 항목 __ 20년 1, 2회 기출문제
- **정확성, 무결성, 사용성** (O) / 간결성 (X)
14) 인터페이스 보안을 위해 네트워크 영역에 적용되는 솔루션 __ 1, 2, 3회 기출문제
- IPSec, SSL, S-HTTP
15) 외계인코드(Alien Code) __ 개정 전 기출문제, 20년 1, 2회 기출문제
- 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램
16) IPC(Inter-Process Communication) __ p.181
- 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합으로, 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현 가능

| --- | --- |
#SSS PM
17) 정렬 알고리즘 ⭐ __ 개정 전 기출문제, 20년 3회 기출문제
37, 14, 17, 40 ,35
- **선택 정렬, PASS 3 (3회전)**
- **PASS 1** ▶ **37, 14**, 17, 40, 35 → **14, 37**, 17, 40, 35
1번째 37를 제외한 14, 17, 40, 35 중 가장 작은 수(14)와 37을 선택해서 바꿈
- **PASS 2** ▶ 14, **37, 17**, 40, 35 → 14, **17, 37**, 40, 35
1, 2번째 14, 37를 제외한 17, 40, 35 중 가장 작은 수(17)와 37을 선택해서 바꿈
- **PASS 3** ▶ 14, 17, **37**, 40, **35** → 14, 17, **35**, 40, **37** (정답)
1, 2, 3번째 14, 17, 37를 제외한 40, 35 중 가장 작은 수(35)와 37을 선택해서 바꿈
- **버블 정렬, PASS 1 (1회전) __ 보통 실기 코딩문제로 나옴**
- **PASS 1** ▶ **37, 14**, 17, 40, 35 → **14, 37**, 17, 40, 35
1번째 37와 2번째 14를 비교해서 1번째(37) > 2번째(14)가 참이라면 바꿈
- 14, **37, 17**, 40, 35 → 14, **17, 37**, 40, 35 (정답)
2번째 37와 3번째 17를 비교해서 2번째(37) > 3번째(17)가 참이라면 바꿈
3번째 37와 4번째 40을 비교해서 3번째(37) > 4번째(40)가 거짓이므로 종료(끝)
- **삽입 정렬, PASS 4 (4회전)**
- **PASS 1** ▶ 37, **14**, 17, 40, 35 → **14**, 37, 17, 40, 35
2번째 14를 앞의 1번째 37과 비교해서 수가 더 작다면 바꿔 삽입함
- **PASS 2** ▶ 14, 37, **17**, 40, 35 → 14, **17**, 37, 40, 35
3번째 17을 앞의 2번째 37, 1번째 14와 비교해서 수가 더 작다면 바꿔 삽입함

- **PASS 3** ▶ 14, 17, 37, **40**, 35
4번째 40을 앞의 3번째 37, 2번째 17, 1번째 14 비교해서 수가 더 작다면 바꿔 삽입함

- **PASS 4** ▶ 14, 17, 37, 40, **35** → 14, 17, **35**, 37, 40 (정답)
5번째 35를 앞의 4번째 40, 3번째 37, 2번째 17, 1번째 14와 비교해서 수가 더 작다면 바꿔 삽입함

18) McCabe의 cyclomatic 수 __ 개정 전 기출문제, 20년 3회 기출문제


- **Edge(선) – Node(점) + 2**
→ 6 – 4(a, b, c, d) + 2 = **4**
19) 소프트웨어 재공학이 소프트웨어 재개발에 비해 갖는 장점 __ 20년 3회 기출문제
- 위험부담 감소, 비용 절감, 시스템 명세의 오류억제, 개발시간의 감소
20) 소프트웨어 품질 목표 __ 20년 3회 기출문제
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%202%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%86%E1%85%AE%E1%84%85%E1%85%AD%E1%84%80%2031d0cdc6647a4f2c98fb48fdcd7d5458/image5.jpeg](image5.jpeg)
21) 소프트웨어 공학의 기본 원칙 __ 20년 3회 기출문제
- 품질 높은 소프트웨어 상품 개발
- 지속적인 검증 시행
- 결과에 대한 명확한 기록 유지
22) AJAX**(**A**synchronous **J**avaScript **a**nd **X**ML) ⭐⭐ **__ 20년 3회 기출문제
- **JavaScript**를 사용한 **비동기 통신기술**로 **클라이언트와 서버 간**에 **XML 데이터를 주고 받는 기술**
23) 외부 스키마, 내부 스키마, 개념 스키마 __ 개정 전 기출문제, 20년 4회 기출문제
- 외부 스키마(External Schema): 사용자의 관점에서 보여주는 데이터베이스 구조로 전체 데이터베이스의 일부이므로 서브 스키마로고도 함
- 내부 스키마(Internal Schema): 저장장치의 입장에서 데이터베이스 전체가 저장되는 방법을 명세한 것으로 단 하나만 존재함
- 개념 스키마(Conceptual Schema): 전체 사용자 또는 모든 응용 시스템이 필요한 데이터베이스 구조로 조직 전체의 데이터베이스로 단 하나만 존재함
24) 해싱함수 __ 20년 4회 기출문제
| --- | --- |

## 3. 데이터베이스 구축
### SQL 응용 / 활용
#### 1. 데이터베이스 설계 ⭐⭐
>[!summary] p.298

1. 데이터베이스 설계 시 고려사항
	- 무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장
2. 데이터베이스 설계 순서 ⭐⭐ __ 20년 1, 2회 기출문제
	- | --- | --- |
	- #요개논물구

#### 2. 데이터 모델 ⭐⭐
>[!summary] p.302, 3-59

1. 데이터 모델의 구성 요소 #개속관
	- 개체(Entity): 데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
	- **속**성(Attribute): 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
	- **관**계(Relationship): 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미
2. 개념적 데이터 모델
	- 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
		- 산출물 : E-R(Entity-Relation) 모델
3. 논리적 데이터 모델 __ 3-62
	- 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
	- 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미
		- 산출물 : 관계 모델, 계층 모델, 네트워크 모델
4. 데이터 모델에 표시할 요소 ⭐ #구연제
	- 구조(Structure): 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현
	- **연**산(Operation): 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구
	- **제**약 조건(Constraint): DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

#### 3. 개체(Entity) ⭐
>[!summary] p.305

1. 개체의 정의 및 특징
	- 실세계에 독립적으로 존재하는 유형, 무형의 정보로 서로 연관된 몇 개의 속성으로 구성됨
	- 데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
	- 독립적으로 존재하거나 그 자체로서도 구별 가능
	- 유일한 식별자(Unique Identifier)에 의해 식별 가능
	- 다른 개체와 하나 이상의 관계(Relationship)가 있음
2. 개체 선정 방법
	- 실제 업무를 담당하고 있는 담당자와 인터뷰를 함
	- 실제 업무에 사용되고 있는 장부와 전표를 이용
	- 자료 흐름도(DFD; Data Flow Diagram)를 통해 업무 분석을 수행했을 경우 자료 흐름도의 자료 저장소(Data Store)를 이용함
	- BPR(Business Process Reengineering, 업무 프로세스 재설계)에 의해 업무를 재정의한 경우 관련 개체를 찾음
3. 개체명 지정 방법
	- 일반적으로 해당 업무에서 사용하는 용어로 지정
	- 약어 사용은 되도록 제한
	- 가능하면 단수 명사 사용
	- 모든 개체명은 유일해야 함
	- 가능하면 개체가 생성되는 의미에 따라 이름 부여 
	  ex) 교수, 고객, 주문, 도시 등

#### 4. 속성(Attribute) ⭐
>[!summary] p.307

1. 속성의 정의 및 특징
	- 데이터베이스를 구성하는 가장 작은 논리적 단위
	- 파일 구조상의 데이터 항목 또는 데이터 필드
	- 개체를 구성하는 항목 및 개체의 특성을 기술
	- **속성의 수**를 디그리(Degree) 또는 차수라고 함 ⭐
	- cf) **튜플(Tuple)의 수**는 카디널리티(Cardinality) ⭐
2. 속성의 특성에 따른 분류
	- | --- | --- | #기설파
3. 개체 구성 방식에 따른 분류
	- | --- | --- |
4. 속성명 지정 원칙
	- 해당 업무에서 사용하는 용어 지정
	- 서술형으로 지정하지 않음
	- 가급적 약어의 사용은 제한
	- 개체명은 속성명으로 사용할 수 없음
	- 개체에서 유일하게 식별 가능하도록 지정
#### 5. 관계(Relationship) ⭐
>[!summary] p.310

1. 관계의 형태
	- 일 대 일(1:1): 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계
	- 일 대 다(1:N): 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고 있지만, 개체 집합 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계
	- 다 대 다(N:M): 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고, 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계
2. 관계의 종류 #종중재배
	- 종속(Dependant) 관계
	- 중복(Redundant) 관계
	- 재귀(Recursive) 관계
	- 배타(Exclusive) 관계

#### 6. 식별자(Identifier) ⭐
>[!summary] p.313

- 하나의 개체 내에서 각각의 인스턴스를 유일(Unique)하게 구분할 수 있는 구분자
- 모든 개체는 한 개 이상의 식별자를 반드시 가져야 함
	- | --- | --- | --- |

#### E-R(개체-관계) 모델 ⭐⭐
>[!summary] p.319, 3-60

1. 개요
	- 개념적 데이터 모델의 가장 대표적인 것
	- 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적인 구성 요소가 정립됨
	- 데이터를 **개**체(Entity), **속**성(AttributE), **관**계(Relationship)으로 묘사
	- 특정 DBMS를 고려한 것은 아님
	- E-R 다이어그램으로 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타냄
2. 피터 첸 표기법 ⭐ __ 20년 1, 2회 기출문제
   ![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%203%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%86%E1%85%AE%E1%84%85%201a1c1c31c4dc405dad9b50753588a4bc/image2.png|400](정보처리기사%20필기,%203과목%20데이터베이스%20구축%20무ᄅ%201a1c1c31c4dc405dad9b50753588a4bc/image2.png)
	- 이중 타원 다중 값 속성(복합속성)
3. 정보 공학 표기법(Information Engineering Notation, 크로우즈 핏)
	- 1981년 클리프 핀켈쉬타인(Clive Finkelstein)과 제임스 마틴(James Maritn)이 공동 개발
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%203%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%86%E1%85%AE%E1%84%85%201a1c1c31c4dc405dad9b50753588a4bc/image3.jpeg](image3.jpeg)
| --- | --- |
- 실선은 1개를 의미, 까마귀 발은 N개를 의미함

- 원형 표시는 선택적 의미를 지니는데 관계가 있을 수도, 없을 수도 있다는 것
4. 바커 표기법(Barker Notation)
- 영국 컨설팅 회사 CACI에서 개발, 리차드 바커(Richard Barker)에 의해 정립


![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%203%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%86%E1%85%AE%E1%84%85%201a1c1c31c4dc405dad9b50753588a4bc/image4.jpeg](image4.jpeg)

| --- | --- |
### 논리 / 물리 데이터베이스 설계
#### 1. 관계형 데이터 모델 ⭐⭐
>[!summary] p.322, 3-28

1. 개요 ⭐
	- 2차원적인 표(Table)를 이용해 데이터 상호 관계를 정의하는 DB 구조
	- 기본 키(Primary Key)와 이를 참조하는 외래 키(Foreign Key)로 데이터 간의 관계를 표현
	- 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
	- 관계형 모델의 대표적인 언어는 SQL이고 1:1, 1:N, N:M 관계를 자유롭게 표현
2. 관계형 데이터 모델(Relational Data Model)의 구성
	- <고객> 테이블에 있는 ‘고객번호’와 <주문서>테이블에 있는 ‘주문번호’는 “기본 키”
	- <주문> 테이블에 있는 ‘고객번호’, ‘주문번호’는 기본 키를 참조하고 있는 “외래 키”
	- <고객> 테이블과 <주문> 테이블의 관계는 1:N
		- 산출물 : 즉 한 명의 고객은 여러 개의 주문을 신청할 수 있음
	- <주문서> 테이블과 <주문> 테이블의 관계는 1:1
		- 산출물 : 즉 주문서는 주문번호 1개에 대한 정보만을 가짐

#### 2. 관계형 데이터베이스의 구조 ⭐⭐
>[!summary] p.325, 3-51

1. 관계형 데이터베이스의 Relation 구조 ⭐⭐
	- 1970년 IBM에 근무하던 코드(E. F. Codd)에 의해 처음 제안됨
	- 튜플(Tuple), 행(Row), 레코드(Record)
		- 속성의 모임으로 구성됨
		- 파일 구조상 레코드(실제 데이터)와 같은 의미
		- **튜플의 수** = 카디널리티(Cardinality) 또는 기수, 대응수 ⭐
	- 속성(Attribute), 열(Column), 필드(Field)
		- 데이터베이스를 구성하는 가장 작은 논리적 단위
		- 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
		- 개체의 특성을 기술
		- **속성의 수** = 디그리(Degree) 또는 차수 ⭐
	- 도메인(Domain) ⭐ __ 20년 1, 2, 3회 기출문제
		- 하나의 속성(Attribute, 애트리뷰트)이 가질 수 있는 같은 타입 원자(Atomic)값들의 집합ex) 성별 속성(Attribute)의 도메인은 ‘남’, ‘여’로 그 외의 값은 입력될 수 없음(일반적)
2. 릴레이션의 특징 ⭐ __ 20년 3회 기출문제
	- 한 릴레이션(테이블)에 포함된 튜플(행)들은 모두 상이함, 즉 서로 다른 값을 갖음
	- 한 릴레이션(테이블)에 포함된 튜플(행) 사이에는 순서가 없음
	- 릴레이션 스키마를 구성하는 애트리뷰트(열) 간의 순서는 중요하지 않음
	- 각 애트리뷰트는 식별을 위해 릴레이션 내에서 유일한 이름을 가짐, 그러나 그에 해당하는 도메인(애트리뷰트를 구성하는 값)에는 동일한 값이 있을 수 있음
		- ex) ‘학년’ 속성에는 1, 2, 3, 4 값이 중복될 수 있음
		- 애트리뷰트는 논리적으로 더 이상 쪼갤 수 없는 원자 값으로 저장함
- **정리**
	1. **튜플**은 서로 상이한 값을 갖고, 순서가 없음
	2. **애트리뷰트**는 원자 값을 가지고, 순서가 중요하지 않으며, 유일한 이름을 가짐

#### 3. 키(Key) ⭐⭐
>[!summary] p.328

- 데이터베이스에서 튜플들을 서로 구분할 수 있는 기준이 되는 속성(Attribute)
1. 후보키(Candidate Key) ⭐ __ 20년 1, 2회 기출문제
	- 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들, 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재
	- 릴레이션에 있는 모든 튜플에 대해 **유일성**과 **최소성**을 만족시켜야 함 ⭐
	- **유일성**(Unique): 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함
	- **최소성**(Minimality): 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야 함
2. 기본키(Primary Key)
	- 후보키 중에서 특별히 선정된 주키(Main Key)로, 중복된 값과 NULL값을 가질 수 없음
	- 후보키의 성질인 유일성과 최소성을 가지며 튜플을 식별하기 위해 반드시 필요한 키
3. 대체키(Alternate Key)
	- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미
4. 슈퍼키(Super Key) ⭐
	- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
	- 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함
5. 외래키(Foreign Key) ⭐ __ 20년 1, 2회 기출문제
	- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

- 참조되는 릴레이션의 기본키와 대응돼 릴레이션 간의 참조 관계를 표현
#### 4. 무결성(Integrity) ⭐⭐
>[!summary] p.331, 3-94

- 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성을 의미
1. 개체 무결성(Entity Integrity, 실체 무결성) ⭐ __ 20년 1, 2, 3회 기출문제
- 테이블의 기본키를 구성하는 어떤 속성(Attribute)도 널(NULL)값이나 중복 값을 가질 수 없음

- 기본키의 속성 값이 널(NULL)값이 아닌 원자 값을 갖는 성질
2. 도메인 무결성(Domain Integrity, 영역 무결성)
- 릴레이션 내의 튜플들이 각 속성(Attribute)의 도메인에 지정된 값 만을 가져야 함

3. 참조 무결성(Referential Integrity) ⭐
- 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함

- 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
4. 사용자 정의 무결성(User-Defined Integrity)
- 속성 값들이 사용자가 정의한 제약 조건에 만족해야 함

5. 데이터 무결성 강화
- 애플리케이션: 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가

- 데이터베이스 트리거: 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가
- 제약 조건: 데이터베이스에 제약 조건을 설정해 무결성을 유지
#### 5. 관계대수 및 관계해석 ⭐⭐⭐
>[!summary] p.334, 3-52

1. 관계대수 ⭐⭐ __ 20년 1, 2, 3회 기출문제
- 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게(How) 유도하는가를 기술하는 절차적인 언어


- 순수관계 연산자

| --- | --- | --- |
#셀프조디


- 일반집합 연산자

| --- | --- | --- |
#합교차카

2. 관계해석(Relational Calculus) __ 3-54
- 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안

- 원하는 정보가 무엇(What)이라는 것만 정의하는 비절차적 특성
- 튜플 관계해석, 도메인 관계해석
- 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력면에서 동등
- 관계대수로 표현한 식은 관계해석으로 표현할 수 있음
| --- | --- | --- | --- |
3. 관계대수와 관계해석 비교 ⭐
| --- | --- | --- |
#### 6. 정규화(Normalization), 반정규화(Denormalization) ⭐⭐
>[!summary] p.341, 3-63, 3-100

- 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정
- 데이터베이스의 논리적 설계 단계에서 수행
1. 정규화의 목적 ⭐ __ 20년 3회 기출문제
- 데이터 구조의 안정성 및 무결성을 유지
- 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만듦
- 효과적인 검색 알고리즘 생성 가능
- 데이터 중복을 배제해 **이상(Anomaly)**의 발생 방지 및 자료 저장 공간의 최소화
- 개체와 속성의 누락 여부 확인 가능
- 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임
2. 이상(Anomaly)의 개념 및 종류 ⭐ __ 20년 3회 기출문제
- 정규화를 거치지 않아 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못하게 발생하는 곤란한 현상


- **삽**입 이상(Insertion Anomaly): 릴레이션에 데이터를 삽입할 때 의도와 상관없이 원하지 않은 값들도 함께 삽입되는 현상

- **삭**제 이상(Deletion Anomaly): 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상

- **갱**신 이상(Update Anomaly): 릴레이션에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상

#삽삭갱

3. 정규화의 원칙
- 정보의 무손실, 분리의 원칙, 데이터의 중복성 감소

4. 정규화 과정 ⭐⭐ __ 20년 1, 2, 3회 기출문제
| --- | --- |
#원부이결다조

5. 반정규화 개념 ⭐
- 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위 ⭐⭐

- 그러나 데이터의 일관성 및 정합성이 저하될 수 있음
6. 반정규화 방법 __ 20년 1, 2회 기출문제
- 테이블 통합: 1:1 관계 | 1:N 관계 | 슈퍼타입/서브타입 {테이블 통합}



- 테이블 분할: 수평 분할, 수직 분할 → 기본키의 유일성 관리가 어려워짐
- 중복 테이블 추가: **집**계 테이블 | **진**행 테이블 | **특**정 부분만을 포함하는 테이블 {추가}
#집진특⭐
- 중복 속성 추가: 자주 사용하는 속성을 하나 더 추가하는 것
#### 7. 시스템 카탈로그(System Catalog) ⭐⭐
>[!summary] p.346, 3-32, 3-54
1. 시스템 카탈로그의 의미 ⭐
	- 사용자를 포함해 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
	- 좁은 의미로는 카탈로그를 <mark class="hltr-purple">데이터 사전(Data Dictionary)</mark>이라고도 함
	- 시스템 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 함
2. 카탈로그의 특징
	- 일반 이용자도 SQL을 이용해 내용을 검색할 수 있음
	- INSERT, DELETE, UPDATE문으로 카탈로그를 갱신할 수 없음 ⭐
	- DBMS에 따라 상이한 구조를 갖음
	- 카탈로그는 DBMS가 스스로 생성하고 유지함
	- 사용자가 SQL문을 실행시켜 변화를 주면 시스템이 자동으로 갱신함
3. 데이터 디렉터리(Data Directory, 사전 관리기)
	- 데이터 사전(Data Dictionary)에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템
	- 시스템만 접근할 수 있음
		- cf) 시스템 카탈로그(데이터 사전): 사용자와 시스템 모두 접근할 수 있음

#### 8. 데이터베이스 저장 공간 설계 ⭐
>[!summary] p.366
1. 테이블(Table) __ 3-31
	- 데이터베이스의 가장 기본적인 객체로 행(Row, 튜플), 열(Column, 컬럼)로 구성
	- 논리 설계 단계의 개체(Entity)에 대응하는 객체
2. 클러스터드 인덱스 테이블(Clustered Index Table)
	- 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블
	- 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축됨
3. 파티셔닝 테이블(Partitioning Table) __ 20년 3회 기출문제
	- 대용량의 테이블을 작은 논리적 단위인 파티션으로 나는 테이블
	- 파티션 키를 잘못 구성하면 성능 저하 등의 역효과 초래
		- | --- | --- |
		- #레해리컴
	- 파티션의 장점
		- 성능 향상, 가용성 향상, 백업 가능, 경합 감소 #성가백합
4. 외부 테이블(External Table)
	- 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일
		- 산출물 : 데이터 웨어하우스(Data Warehouse), ETL(Extraction, Transformation, Loading)
5. 임시 테이블(Temporary Table)
	- 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
	- 임시테이블에 저장된 데이터는 트랜잭션이 종료되면 삭제됨
	- 절차적인 처리를 위해 임시로 사용하는 테이블
6. 컬럼(Column, 열)
	- 가변 길이 데이터 타입: 예상되는 최대 길이로 정의
	- 고정 길이 데이터 타입: 최소 길이로 지정
	- 소수점 이하 자릿수: 소수점 이하 자릿수는 반올림되어 저장
	- 고정 길이 컬럼이고 NOT NULL인 컬럼: 앞 쪽
	- 가변 길이 컬럼, NULL값이 많을 것으로 예상되는 컬럼: 뒤 쪽
7. 테이블스페이스(Tablespace)
	- 테이블이 저장되는 논리적인 영역
	- 테이블을 저장하면 논리적으로는 테이블스페이스에 저장되고, 물리적으로는 해당 테이블스페이스와 연관된 데이터 파일(Data File)에 저장됨
	- 테이블스페이스 설계 시 고려사항
		- 업무별로 구분해 지정하고, 테이블과 인덱스는 분리해 저장함
		- 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장함
		- LOB(Large Object) 타입의 데이터는 독립적인 공간으로 지정함

#### 9. 트랜잭션(Transaction) ⭐⭐⭐
>[!summary] p.371, 3-29
1. 트랜잭션의 정의 ⭐ __ 20년 3회 기출문제
	- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
	- 한꺼번에 모두 수행되어야 할 일련의 연산들
	- **COMMIT**: 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어
	- **ROLLBACK**: 트랜잭션 처리가 비정상으로 종료되어 DB의 일관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산
	- SAVEPOINT(=CHECKPOINT): 트랜잭션 내에서 ROLLBACK할 위치인 저장점을 지정하는 명령어, 여러 개의 SAVEPOINT 지정 가능
	- COMMIT과 ROLLBACK 명령어에 의해 보장 받는 트랜잭션 특징 = **원자성 ⭐**
2. 트랜잭션의 특성 ⭐⭐ __ 20년 1, 2회 기출문제
	- | --- | --- |
	- #ACID
3. CRUD 매트릭스 __ 3-104
	- Create, Read, Update, Delete, ‘C > D > U > R’의 우선순위 적용
	- 테이블, 프로세스에 C, R, U, D가 모두 없는 경우
	- 테이블에 C 또는 R이 없는 경우 (프로세스는 하나만 있어도 돌아감)

#### 10. 인덱스(Index) ⭐
>[!summary] p.375, 2-15, 3-38
1. 인덱스의 개념 및 선정기준, 고려사항
	- 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터>쌍으로 구성된 데이터 구조
	- 인덱스 컬럼 선정 ⭐
		- 인덱스 컬럼의 분포도(Selectivity)가 10~15% 이내인 “컬럼”
		- 가능한 한 수정이 빈번하지 않는 “컬럼”
		- ORDER BY, GROUP BY, UNION이 빈번한 “컬럼”
		- 분포도가 좋은 컬럼은 단독 인덱스로 생성
		- 인덱스들이 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성
	- 설계 시 고려사항 ⭐
		- 새로 추가되는 인덱스는 기존 엑세스 경로에 영향을 미칠 수 있음
		- 지나치게 많은 인덱스는 오버헤드(Overhead) 발생
		- 넓은 범위 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킴
		- 인덱스만의 추가적인 저장 공간이 필요
		- 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계
2. 인덱스 종류
	- 클러스터드 인덱스(Clustered Index) / 넌클러스터드 인덱스(Non-Clustered Index)
	- **트리 기반 인덱스**: 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
	- **비트맵 인덱스**: 인덱스 컬럼의 데이터를 Bit 값인 0, 1로 변환해 인덱스 키 사용
	- **함수 기반 인덱스**: 컬럼에 특정 함수나 수식을 적용해 산출된 값을 사용하는 것
	- **비트맵 조인 인덱스**: 다수의 조인된 객체로 구성된 인덱스
	- **도메인 인덱스**: 개발자가 필요한 인덱스를 직접 만들어 사용하는 것 (확장형 인덱스)

#### 11. 뷰(View) ⭐⭐
>[!summary] p.380, 2-16, 3-36, 3-55
1. 뷰의 개요 및 특징
	- 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블로 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같음
	- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않지만 사용자에게 있는 것처럼 간주됨 → 저장장치 내에 논리적으로 존재
	- 정의된 뷰로 다른 뷰를 정의할 수 있음
	- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨
	- | --- | --- |
2. 뷰의 장, 단점 ⭐ __ 20년 1, 2, 3회 기출문제
	- 장점
		- 논리적 데이터 독립성 제공
		- 접근 제어를 통한 자동 보안 제공
		- 사용자 데이터 관리 용이
	- 단점
		- 독립적인 인덱스를 가질 수 없음
		- 뷰의 정의를 ALTER로 변경할 수 없음 → DROP하고 새로 CREATE해야 함
		- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름

#### 12. 클러스터(Cluster) ⭐
>[!summary] p.383, 2-16, 3-87

1. 클러스터의 개요 및 특징 ⭐
	- 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법
	- 인덱스의 단점을 해결한 기법 → 분포도(Selectivity)가 넓을수록 오히려 유리함
	- 분포도가 넓은 “테이블”의 클러스터링은 저장 공간의 절약이 가능
	- 대량의 범위를 자주 액세스(조회)하는 경우 적용
	- 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용
2. 클러스터의 선정기준 및 고려사항
	- 클러스터 테이블 선정
		- 수정이 빈번하지 않는 “테이블”
		- ORDER BY, GROUP BY, UNION이 빈번한 “테이블”
		- 처리 범위가 넓어 문제가 발생하는 경우 단일 테이블 클러스터링 사용
		- 조인이 많아 문제가 발생되는 경우는 다중 테이블 클러스터링 사용
	- 설계 시 고려사항
		- 클러스터링 된 테이블은 조회 속도를 향상시켜주지만 입력, 수정, 삭제 시 성능이 저하됨(부하가 증가)
		- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋음
		- 클러스터링 된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상됨

#### 13. 분산 데이터베이스 설계 ⭐⭐
>[!summary] p.390, 3-77

1. 분산 데이터베이스 정의
- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site)에 분산돼 있는 데이터베이스

2. 분산 데이터베이스의 구성 요소
| --- | --- |
3. 분산 데이터베이스의 목표 ⭐⭐ __ 20년 1, 2, 3회 기출문제
| --- | --- |
#위복병분장

4. 분산 데이터베이스의 장, 단점
| --- | --- |
5. 분산 데이터베이스 설계
- 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적


- 분산 설계 방법

- 테이블 위치 분산: 테이블을 각기 다른 서버에 분산시켜 배치하는 방법
- **분할**(Fragmentation): 테이블의 데이터를 분할하여 분산시키는 것
- **할당**(Allocation): 동일한 분할을 여러 개의 서버에 생성하는 방법
	- 산출물 : 중복이 없는 할당, 중복이 있는 할당
#### 14. 데이터베이스 이중화 / 서버 클러스터링 ⭐
>[!summary] p.394, 3-78

1. 데이터베이스 이중화(Database Replication)
- 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제해 관리하는 것

2. 데이터베이스 이중화의 분류
| --- | --- |
3. 데이터베이스 이중화 구성 방법
| --- | --- |
4. 서버 클러스터링(Server Clustering)
- 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
**▶** **고가용성 클러스터링**: 하나의 서버에 장애 발생 → 다른 서버가 대신 처리
**▶** **병렬 처리 클러스터링**: 하나의 작업을 여러 개의 서버에 분산해 처리
#### 15. 데이터베이스 보안 / 스토리지 ⭐⭐
>[!summary] p.397~407, 3-79

1. 데이터베이스 보안의 개요
	- 데이터베이스 일부분 또는 전체에 대해서 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술
	- 데이터베이스 사용자들은 일반적으로 서로 다른 객체에 대해 다른 접근 권리 또는 권한을 가짐
2. 암호화(Encryption)
	- 암호화(Encryption) 과정
	- 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정
		- 산출물 : 개인키 암호 방식(대칭키), 공개키 암호 방식(비대칭키)
	- 복호화(Decryption) 과정
	- 암호문을 원래의 평문으로 바꾸는 과정
3. 암호화 방식
| --- | --- | --- |
4. 접근통제 __ 5-86
- 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것

- 접근통제 3요소: 접근통제 **정**책, 접근통제 **보**안모델, 접근통제 메**커**니즘
#정보커
- 임의 접근통제(DAC; Discretionary Access Control)
-데이터에 접근하는 사용자의 신원에 따라 접근 권한 부여
	- 산출물 : 접근통제 권한=주체

- 강제 접근통제(MAC; Mandatory Access Control)
-주체와 객체의 등급을 비교해 접근 권한 부여
	- 산출물 : 접근통제 권한=제3자

5. 접근통제 정책
| --- | --- |
6. 접근통제 메커니즘 ⭐
- 접근통제 목록(ACL; Access Control List): 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지를 기록한 목록


- 능력 리스트(**CL**; Capability List): 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록

- 보안 등급(Security Label), 패스워드, 암호화

7. 접근통제 보안 모델
- 기밀성 모델: 군사적인 목적으로 개발된 최초의 수학적 모델, 기밀성 보장 최우선
	- 산출물 : 벨라파듈라 모델: No Read UP(기밀성), No Write Down

- 무결성 모델: 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델
	- 산출물 : 비바 모델: No Read Down, No Write Up(무결성)
- 접근통제 모델: 접근통제 메커니즘을 보안 모델로 발전시킨 것
	- 산출물 : 접근통제 행렬(Access Control Matrix): 행=주체, 열=객체
8. 데이터베이스 백업 종류 __ 3-88, 5-51
| --- | --- | --- |
- **로그 파일**: 데이터베이스의 상태 변화를 시간의 흐름에 따라 모두 기록한 파일
9. 스토리지(Storage) __ 3-75, 5-49
| --- | --- | --- | --- |
#다나쓰
#### 16. 논리 데이터 모델의 물리 데이터 모델 변환 및 품질 검토 ⭐
>[!summary] p.410~418, 2-13

1. 일반적인 변환 절차
- 단위 개체를 테이블로 변환 → 속성을 컬럼으로 변환 → UID(Unique Identifier)를 기본 키(Primary Key)로 변환 → 관계를 외래 키(Foreign Key)로 변환 → 컬럼 유형(Type)과 길이(Length) 정의 → 반정규화(De-normalization) 수행

2. 슈퍼타입/서브타입을 테이블로 변환
-슈퍼타입 기준 테이블 변환: 서브타입을 슈퍼타입에 통합해 하나의 테이블로 만드는 것

- 서브타입 기준 테이블 변환: 슈퍼타입 속성들을 각각의 서브타입에 추가해 서브타입들을 개별적인 테이블로 만드는 것
- 개별타입 기준 테이블 변환: 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것
3. 물리 데이터 모델 품질 기준 (=논리 데이터 모델 품질 기준) __ 3-70, 3-102
| --- | --- |
#정완준_최일활
### SQL 응용 ⭐⭐⭐
>[!summary] p.426~4, 3-8
- 1974년 IBM 연구소에서 개발한 SEQUEL에서 유래함
- 관계대수와 관계해석을 기초로 한 혼합 데이터 언어

1. SQL(Structured Query Language)의 분류 ⭐⭐ __ 20년 1, 2회 기출문제
	- DDL(Data Define Language, 데이터 정의어) __ 3-26
		- DOMAIN(**도**메인), SCHEMA(**스**키마), TABLE(**테**이블), VIEW(**뷰**), INDEX(**인**덱스)를 **정의**하거나 **변경** 또는 **삭제**할 때 사용하는 언어 #도스테뷰인
		- | --- | --- |
	- DML(Data Manipulation Language, 데이터 조작어) ⭐ __ 3-13, 1, 2회 기출문제
		- 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 처리하는 데 사용하는 언어
		- | --- | --- |
	- DCL(Data Control Language, 데이터 제어어) __ 3-15, 20년 1, 2, 3회 기출문제
		- 데이터의 무결성, 보안, 회복, 병행수행 제어 ⭐ 등을 정의하는 데 사용되는 언어
		- 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용
		- | --- | --- |
		- ex) GRANT UPDATE ON 고객(테이블) TO 홍길동 WITH GRANT OPTION;
		- ex) REVOKE GRANT OPTION FOR UPDATE ON 고객(테이블) FROM 홍길동 CASCADE;
2. SELECT __ p.444~453 ⭐ __ 20년 1, 2, 3회 기출문제
	- **WHERE**절: 검색할 조건을 기술
	- ORDER BY절: 특정 속성을 기준으로 정렬해 검색할 때 사용
		- 산출물 : ASC(오름차순), DESC(내림차순) – 따로 설정이 없을 때는 기본적으로 ASC 사용
	- **GROUP BY**절: 특정 속성을 기준으로 그룹화해 검색할 때 사용, 일반적으로 그룹 함수와 함께 사용
	- **HAVING**절: GROUP BY와 함께 사용되며, 그룹에 대한 조건 지정
	- **DISTINCT**: 중복 튜플 제거 ⭐
	- **집계/그룹함수**: GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술함 ![[#그룹함수의 종류]]
	- 윈도우 함수: GROUP BY절을 이용하지 않고 속성의 값을 집계할 함수를 기술함
	- 함수의 인수로 지정한 속성이 대상 레코드의 범위가 되는데, 이를 WINDOW라 함
	- 산출물 : PARTITION BY: 윈도우 함수가 적용될 범위로 사용할 속성 지정
		- → `WINDOW 함수 OVER (PARTITION BY 속성 ORDER BY 속성) [AS 바꾸고 싶은 이름]`
	- | --- | --- |
3. 조인(JOIN) __ p.461, 3-43
	- 결합을 의미하며, 관계형 데이터베이스에서의 조인은 교집합 결과를 가지는 결합 방법을 의미
	- 두 릴레이션으로부터 연관된 튜플들을 결합해, 하나의 새로운 릴레이션을 반환

#### 조인의 종류
##### 논리적 조인
| 구분                 | 조인 유형                        | 설명                                          |
|--------------------|------------------------------|---------------------------------------------|
| INNER JOIN <br>(내부 조인) | EQUI JOIN (동등 조인)            | 공통 존재 컬럼의 값이 같은 경우를 추출                      |
|                    | NATURAL JOIN (자연 조인)         | 두 테이블의 모든 컬럼을 비교해, 같은 컬럼 명을 가진 값이 같은 경우를 추출 |
|                    | CROSS JOIN (교차 조인)           | 조인 조건이 없는 모든 데이터 조합을 추출 ★                   |
| OUTER JOIN <Br>(외부 조인) | LEFT OUTER JOIN (왼쪽 외부 조인)   | 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출         |
|                    | RIGHT OUTER JOIN (오른쪽 외부 조인) | 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출         |
|                    | FULL OUTER JOIN (완전 외부 조인)   | 양쪽의 모든 데이터를 추출                              |

##### 물리적 조인
| 종류                          | 설명                                                           |
|-----------------------------|--------------------------------------------------------------|
| NESTED-LOOP JOIN <br>(중첩 반복 조인) | 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row를 결합해 원하는 결과를 조합하는 방식 |
| SORT-MERGE JOIN <Br>(정렬 합병 조인)  | 양쪽 테이블의 정렬한 결과를 차례로 검색하면서 연결고리 형태로 합병하는 방식                   |
| HASH JOIN <Br>(해시 조인)           | 해싱 함수 기법을 활용하여 조인을 수행하는 방식                                   |


#### 그룹함수의 종류
| 종류                  | 설명                                                                                     |
|---------------------|----------------------------------------------------------------------------------------|
| COUNT(속성명)          | 그룹별 튜플 수를 구하는 함수                                                                       |
| SUM(속성명)            | 그룹별 합계를 구하는 함수                                                                         |
| AVG(속성명)            | 그룹별 평균을 구하는 함수                                                                         |
| MAX(속성명)            | 그룹별 최대값을 구하는 함수                                                                        |
| MIN(속성명)            | 그룹별 최소값을 구하는 함수                                                                        |
| STDDEV(속성명)         | 그룹별 표준편차를 구하는 함수                                                                       |
| VARIANCE(속성명)       | 그룹별 분산을 구하는 함수                                                                         |
| ROLLUP(속성명, 속성명, …) | 인수로 주어진 속성을 대상으로 그룹별 소계를 구하는 함수, 속성의 개수가 n개면, n+1레벨까지, 하위 레벨에서 상위 레벨 순으로 데이터 집계        |
| CUBE(속성명, 속성명, …)   | 인수로 주어진 속성을 대상으로 모든 조합의 그룹별 소계를 구하는 함수, 속성의 개수가 n개면, n2 레벨까지, 상위 레벨에서 하위 레벨 순으로 데이터 집계 |


### SQL 활용 ⭐⭐
>[!summary] p.476~484

1. 절차형 SQL
- C, JAVA 등의 프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL

- 일반적인 프로그래밍 언어에 비해 효율이 떨어지지만, 연속적인 작업 처리 적합
- BEGIN ~ END 형식으로 작성되는 블록(Block) 구조로 기능별 모듈화 가능
2. 프로시저(Procedure) #디비컨SET
- 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업 수행, 처리 결과는 한 개 이상의 값 혹은 반환을 아예 하지 않음

- 시스템의 일일 마감 작업, 일괄(Batch) 작업 등에 주로 사용됨

**DECLARE**(필수): 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 **선**언부

**BEGIN**(필수): 프로시저의 시작을 의미, **실**행부

**CON**TROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨

**S**QL: DML, DCL이 삽입되어 데이터 관리를 위한 작업 수행 ⭐

**E**XCEPTION: BEGIN ~ END 안의 구문 실행 시 **예**외가 발생하면 이를 처리

**T**RANSACTION: 수행된 데이터 작업들을 DB에 적용할지 말지 결정하는 처리부

**END**(필수): 프로시저의 종료를 의미, BEGIN/END는 함께 다님

→ **CREATE** [OR REPLACE] **PROCEDURE** 프로시저명([[파라미터]]) [지역변수 선언]

BEGIN
프로시저 BODY;

**END**;
* OR REPLACE: 선택적인 예약어, 동일한 프로시저 이름이 이미 존재하는 경우 기존의 프로시저를 대체할 수 있음


- **EXECUTE, EXEC, CALL** 프로시저명; / **DROP** PROCEDURE 프로시저명;

3. 트리거(Trigger) __ 3-2, 20년 1, 2회 기출문제 #디이비컨SE
- 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관력 작업을 자동 수행 ⭐
- 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용됨

- DCL(데이터 제어어)을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류 발생
- 트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향을 미치므로 트리거를 생성할 때 세심한 주의가 필요

**DECLARE**(필수): 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의하는 **선**언부

**EVENT**(필수): 트리거가 실행되는 조건을 명시

**BEGIN**(필수): 트리거의 시작을 의미, **실**행부

**CON**TROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨

**S**QL: DML문이 삽입되어 데이터 관리를 위한 작업 수행 ⭐

**E**XCEPTION: BEGIN ~ END 안의 구문 실행 시 **예**외가 발생하면 이를 처리

**END**(필수): 트리거의 종료를 의미, BEGIN/END는 함께 다님

→ **CREATE** [OR REPLACE] **TRIGGER** 트리거명 [동작시기 옵션][동작 옵션] ON 테이블명

**REFERENCING**[NEW | OLD] AS 테이블명

**FOR EACH ROW** [WHEN 조건식]

BEGIN
트리거 BODY;


**END**;

- 동작시기 옵션: AFTER(테이블이 변경된 후 트리거 실행), BEFORE(변경되기 전 실행)
- NEW | OLD: NEW(추가되거나 수정에 참여할 테이블), OLD(수정되거나 삭제 전 테이블)
- FOR EACH ROW: 각 튜플마다 트리거 적용
- DROP TRIGGER 트리거명;

3. 사용자 정의 함수 __ 3-5 #디비컨SER
- 프로시저와 유사하게 SQL을 사용해 일련의 작업을 연속적으로 처리

- 종료 시 예약어 RETURN을 사용해 처리 결과를 단일값으로 반환
- DML문(SELECT, INSERT, DELETE, UPDATE)의 호출에 의해 실행됨
- RETURN을 통해 값을 반환해, 출력(OUT) [[파라미터]]가 없음
- INSERT, DELETE, UPDATE로 테이블 조작은 할 수 없고, SELECT로 조회만 할 수 있음
- 프로시저를 호출해 사용할 수 없음 ⭐
| --- | --- | --- |
DECLARE(필수): 사용자 정의 함수의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부


**BEGIN**(필수): 사용자 정의 함수의 시작을 의미, **실**행부

**CON**TROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리됨

**S**QL: SELECT문이 삽입되어 데이터 관리를 위한 작업 수행 ⭐

**E**XCEPTION: BEGIN ~ END 안의 구문 실행 시 **예**외가 발생하면 이를 처리

**RETURN**(필수): 호출 프로그램에 반활할 값이나 변수를 정의 ⭐

**END**(필수): 사용자 정의 함수의 종료를 의미, BEGIN/END는 함께 다님

→ **CREATE** [OR REPLACE] **FUNCTION** 사용자 정의 함수명([[파라미터]]) [지역변수 선언]

BEGIN
사용자 정의 함수 BODY;


**RETURN** 반환값;

**END**;

DMBS 접속 기술 ⭐
>[!summary] p.489

1. 웹 응용 시스템의 구조
- 사용자 ←→ 웹 서버 ←→ WAS ←→ DBMS


	- 산출물 : 사용자는 웹 서버에 접속해 데이터를 주고 받고, 웹 서버는 WAS에게 해당 요청을 전달함, 그 다음 WAS는 수신한 요청을 트랜잭션 언어로 변환한 후 DBMS에 전달해 데이터를 받으면, 이 데이터를 다시 웹 서버로 전달해 사용자에게 도달하게 함

2. DBMS 접속 기술
- JDBC(Java Database Connectivity)

- 1997년 썬 마이크로시스템에서 출시, JAVA 언어로 다양한 종류의 데이터베이스에 접속하고 SQL문을 수행할 때 사용되는 표준 API
- 접속하려는 DBMS에 대한 드라이버가 필요

- ODBC(Open Database Connectivity)

- 1992년 마이크로소프트에서 출시, 데이터베이스에 접근하기 위한 표준 개방형 API로 개발 언어에 관계없이 사용 가능
- ODBC도 접속하려는 DMBS에 맞는 드라이버가 필요하지만, 접속하려는 DBMS의 인터페이스를 알지 못하더라도 ODBC 문장을 사용해 SQL을 작성하면 ODBC에 포함된 드라이버 관리자가 해당 DBMS의 인터페이스에 맞게 연결해줌

→ DBMS의 종류를 몰라도 됨

3. 정적 SQL vs 동적 SQL
| --- | --- | --- |
ORM(Object-Relational Mapping) ⭐
>[!summary] p.496

1. ORM의 개요
- 객체(Object)와 관계형데이터베이스(RDB)의 데이터를 연결(Mapping)하는 기술 ⭐

- ORM으로 생성된 가상의 객체지향 데이터베이스는 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수 용이
- 직관적이고 간단하게 데이터 조작 가능
2. ORM 프레임워크
| --- | --- |
3. ORM의 한계
- 프레임워크가 자동으로 SQL을 작성하기 때문에 의도대로 작성되었는지 확인해야 함
- 객체지향적인 사용 고려와 프로젝트가 크고 복잡해질수록 적용하기 어려워짐
- 기존의 기업들은 ORM을 고려하지 않은 데이터베이스를 사용하고 있기 때문에, ORM에 적합하게 변환하려면 많은 시간과 노력 필요

#### 17. 쿼리 성능 최적화 ⭐
>[!summary] p.498, 3-107

- 데이터 입, 출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화하는 것
- 쿼리 성능 최적화하기 전, 성능 측정 도구인 APM(Application Performance Management)을 사용해 최적화 할 쿼리를 선정해야 함
- 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획(Execution Plan)을 EXPLAIN 명령어를 통해 검토하고, SQL 코드와 인덱스 재구성
	*옵티마이저(Optimizer): 작성된 SQL이 가장 효율적으로 수행되도록 최적의 경로를 찾아 주는 모듈

1. RBO(Rule Based Optimizer) vs CBO(Cost Based Optimizer)
	- | --- | --- | --- |
2. SQL 코드 및 인덱스 재구성
	- **SQL 코드 재구성**
		- 서브 쿼리에 특정 데이터가 존재하는지 확인 할 때는 IN보다 EXISTS 활용
		- 실행 계획이 잘못되었다고 판단되는 경우 힌트(Hint)를 활용해 변경
	- **인덱스 재구성**
		- 인덱스의 추가 및 변경은 해당 테이블을 참조하는 다른 SQL문에도 영향을 줄 수 있으므로 신중히 결정
		- 단일 인덱스로 쓰기나 수정 없이 일기로만 사용되는 테이블의 경우 IOT(Index-Organized Table) 구성 고려

### 데이터 전환 ⭐
>[!summary] p.508, 3-109

1. 데이터 전환의 정의
	- 운영 중인 기존 정보 시스템에 축적되어 있는 데이터를 추출(Extraction)하여 새로 개발할 정보 시스템에서 운영 가능하도록 변환(Transformation) 후, 적재(Loading)하는 일련의 과정
		- 산출물 : ETL(Extraction, Transformation, Loading): 추출, 변환, 적재 과정
		- 산출물 : **데이터 이행**(Data Migration), 데이터 이관이라고도 함
2. 데이터 전환 계획서
| --- | --- |
**추가 정리, 수제비 및 기출문제** ⭐⭐⭐
1. WHERE 조건 ⭐ __ 3-8, 20년 3회 기출문제
| --- | --- | --- |
2. LIKE와 같이 사용하는 와일드 문자 ⭐ __ 3-9
| --- | --- | --- |
3. 주석 처리 __ 3-9
| --- | --- |
4. 힌트의 사용 __ 3-9
- SQL 문에 사전 정보를 줘서, SQL문 실행에 빠른 결과를 가져오는 효과를 만드는 문법
| --- | --- |
5. 집합 연산자 __ 3-41
- 테이블을 집합 개념으로 보고, 두 테이블 연산에 집합 연산자를 사용하는 방식

- 여러 질의 결과를 연결해 하나로 결합하는 방식을 사용
| --- | --- |
6. 서브쿼리(Sub-Query) __ 3-46
- SQL문 안에 포함된 또 다른 SQL문

| --- | --- |
7. 데이터 지역화(Data Locality) ⭐ __ 3-91
- 데이터베이스의 저장 데이터를 효율적으로 이용할 수 있도록 저장하는 방법

- **구역성(Locality)**라고도 함

- 데이터 지역화의 종류

| --- | --- | --- |
#시공순


- 데이터 지역화를 활용한 관리 기법

| --- | --- |
8. 병행제어의 로킹(Locking) 단위 ⭐⭐ __ 개정 전 / 20_1, 2, 3회 / 21년 1회 기출문제
- 한번에 한 명만 사용할 수 있게 잠그는(Locking) 단위
- 로킹의 대상이 되는 객체의 크기를 로킹 단위라고 함
- 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
- 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
- **로킹 단위가 작으면 小**
- 로킹 오버헤드가 증가함
- 데이터베이스 공유도가 증가함 (= 병행성 수준이 높아짐)
- **로킹 단위가 크면 大**
- 로킹 오버헤드가 감소함
- 데이터베이스 공유도가 감소함 (= 병행성 수준이 낮아짐)
9. 데이터베이스 로그(log)를 필요로 하는 회복기법 __ 20년 3회 기출문제
#지RE 즉UN
- **지연 갱신 기법(Deferred Update)**
-트랜잭션이 부분 완료 상태에 이르기까지 발생한 모든 변경 내용을 로그 파일에만 저장하고, 데이터베이스에는 COMMIT이 발생할 때까지 저장을 지연하는 기법

- 트랜잭션이 실패할 경우 UNDO없이 로그 단순 폐기

	- 산출물 : REDO

- **즉시 갱신 기법(Immediate Update)**
-트랜잭션 수행 도중 데이터를 변경하면 변경 정보를 로그 파일에 저장하고, 부분 완료되기 전이라도 모든 변경 내용을 즉시 데이터베이스에 반영하는 기법

- 로그 파일을 참조해 **미완료된 변경**에 대해 **UNDO를 우선 실행**한 후, 완료된 변경에 대해 REDO 실행 (UNDO는 **COMMIT된 지점이 없음**)

	- 산출물 : UNDO

- **정보처리기사 실기, REDO/UNDO 기출문제**

![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%203%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%86%E1%85%AE%E1%84%85%201a1c1c31c4dc405dad9b50753588a4bc/image7.png](image7.png)

## 4. 프로그래밍 언어 활용
### 서버프로그램 구현
#### 1. 개발 환경 구축 ⭐⭐
>[!summary] p.534, 4-2

1. 개발 환경 구축의 개요
- 응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 하드웨어 및 소프트웨어 장비를 구축하는 것

- 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등의 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축함
2. 하드웨어 환경 ⭐
- 사용자와의 인터페이스 역할을 하는 클라이언트(Client)와 클라이언트와 통신하여 서비스를 제공하는 서버(Server)로 구성됨

- **클라이언트**: PC, 스마트폰 등
- **서버**: 웹 서버, 웹 애플리케이션 서버(WAS), 데이터베이스 서버, 파일 서버 등

-** **웹 서버**(Web Server) **__ 4-96

- 클라이언트로부터 직접 요청을 받아 처리하는 서버로, 저용량의 정적 파일들을 제공

	- 산출물 : Apache HTTP Server, Microsoft Internet Service, Google Web Server 등

-** 웹 애플리케이션 서버(**WAS**; Web Application Server) **⭐

- 정적인 콘텐츠를 처리하는 웹 서버(Web Server)와 반대됨
- 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어(=소프트웨어)
- 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공

	- 산출물 : Apache Tomcat, IBM WebSphere, Oracle WebLogic, JEUS, JBoss, Jetty, Resin 등등

-** **데이터베이스 서버**(Database Server) __ **4-98

- 데이터베이스와 이를 관리하는 DBMS를 운영하는 서버
	- 산출물 : MySQL Server, IBM WebSphere, Oracle WebLogic 등

**▶** **파일 서버**(File Server)

- 데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버

	- 산출물 : AWS S3 등

3. 웹 서버(Web Server)의 기능 __ 4-97
| --- | --- |
4. 소프트웨어 환경
- 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성됨

- **시스템 소프트웨어**: 운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS
- **개발 소프트웨어**: **요**구사항 관리 도구, **설**계/모델링 도구, **빌**드 도구, **구**현 도구, **테**스트 도구, **형**상 관리 도구 등

#요설_빌구테형

-** **요**구사항 관리 도구 **⭐

- 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어

	- 산출물 : JIRA, IMB DOORS, inteGREAT, Reqtify, Trello 등

**▶** **설**계/모델링 도구

- [[UML]]을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어

	- 산출물 : DB Designer, PlantUML, ArgoUML 등

-** **빌**드 도구 **⭐

- 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어

	- 산출물 : Ant, Maven, Gradle, Jenkins 등

-** **구**현 도구 **⭐

- 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어

	- 산출물 : Eclipse, IntelliJ IDEA, Visual Studio, Node.js 등

**▶** **테**스트 도구

- 모듈들이 요구사항에 적합하게 구현됐는지 테스트하는 소프트웨어

	- 산출물 : CppUnit, JUnit, HttpUnit, NUnit, SprintTest 등

-** **형**상 관리 도구 **⭐

- 산출물들을 버전별로 관리하여 품질 향상을 지원하는 스프트웨어

	- 산출물 : CVS, SVN(Subversion), GIT 등

5. 개발 언어의 선정 기준 ⭐⭐
| --- | --- |
#적효이친범

#### 2. 서버 개발 ⭐
>[!summary] p.537, 4-6

1. 서버 개발의 개요
- 웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 애플리케이션 서버(WAS)에 탑재하는 것을 의미함

- 서버 개발에 사용되는 프로그래밍 언어
	- 산출물 : JAVA, JavaScript, Python, PHP, Ruby등
2. 서버 개발 프레임워크 ⭐
* 프레임워크(Framework): ‘뼈대’, ‘골조’를 의미하는데, 소프트웨어에서는 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모아둔 집합체를 뜻함

- 대부분 MVC(Model, View, Controller) 패턴을 기반으로 개발됨
| --- | --- |
3. 서버 프로그램 구현(효과적인 모듈 설계) __ 4-9, 20년 3회 기출문제
- 응용 소프트웨어와 동일하게 모듈 및 공통 모듈을 개발한 후, 모듈들을 통합하는 방식으로 구현, 유지보수가 용이해야 함

- 모듈의 독립성을 높이려면 모듈의 결합도(Coupling)를 약하게 하고,
응집도(Cohesion)를 강하게 하며 모듈의 크기를 작게 만들어야 함 **⭐⭐**
- 복잡도와 중복성을 줄이고 일관성 유지
- 공통 모듈은 여러 프로그램에서 재사용(Reuse) 할 수 있는 모듈을 의미함
→ 함수와 객체 재사용, 컴포넌트 재사용, 애플리케이션 재사용
- **재사용 프로그래밍 기법**
- **객**체지향 프로그래밍, **제**네릭 프로그래밍, **자**동 프로그래밍, **메**타 프로그래밍
#객제자메
4. 프레임워크의 특성 ⭐⭐
| --- | --- |
#모재확역

\
5. 프레임워크의 구성요소 __ 4-7
- **개**발환경, **실**행환경, **운**영환경, **관**리환경
#개실운관

#### 3. 보안 및 API ⭐⭐
>[!summary] p.540, 4-16

1. 소프트웨어 개발 보안의 개요
- 소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여 보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 일련의 보안 활동을 의미


	- 산출물 : 시큐어 코딩(Secure Coding) ⭐

- **기**밀성(Confidentiality), **무**결성(Integrity), **가**용성(Availability) 유지하는 것을 목표

#기무가⭐

- 정부에서 제공하는 소프트웨어 개발 보안 가이드를 참고하여 소프트웨어 개발 과정에서 점검해야 할 보안 항목들을 점검
2. 소프트웨어 개발 보안 점검 항목
| --- | --- |
#세입보시 에코캡아

**3) API(Application Programming Interface)** ⭐ __ 4-18
- 응용 프로그램 개발 시 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 함으로써 효율적인 소프트웨어 구현을 도와주는 인터페이스

- 개발에 필요한 여러 도구를 제공
- 누구나 무료로 사용할 수 있게 공개된 API를 Open API라고 함

	- 산출물 : Windows API, 단일 유닉스 규격(SUS), Java API, 웹 API 등

#### 4. 배치 프로그램 ⭐⭐
>[!summary] p.542, 4-21

1. 배치 프로그램(Batch Program)의 개요 ⭐ __ 20년 3회 기출문제
- 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것

| --- | --- |
#이온정

| --- | --- |
#대자견안성
2. 배치 스케줄러(Batch Scheduler), 잡 스케줄러(Job Scheduler)
- 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구
- **스프링 배치(Spring Batch)**: Spring 프레임워크의 특성을 그대로 가져와 스프링이 가지고 있는 다양한 기능들을 모두 사용할 수 있는 오픈 소스 프레임워크
	- 산출물 : 주요 구성 요소: Job, Job Launcher, Job Repository, Step
- **쿼츠(Quartz)**: Spring 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리
	- 산출물 : 주요 구성 요소: Job, Job Detail, Trigger, Scheduler
#### 5. 패키지 소프트웨어 ⭐
>[!summary] p.544, 4-101

1. 패키지 소프트웨어(Package Software)의 개요
- 기업에서 일반적으로 사용하는 여러 기능들을 통합하여 제공하는 소프트웨어

- 기업에서 패키지 소프트웨어를 구입해 기업 환경에 적합하게 커스터마이징 후 사용
- 기능 요구사항을 70% 이상 충족시키는 패키지 소프트웨어 사용
2. 패키지 소프트웨어 vs 전용 개발 소프트웨어
| --- | --- | --- |
### 프로그래밍 언어 활용
#### 1. 데이터 타입 ⭐⭐
>[!summary] p.552, 4-24, 20년 3회 기출문제

- 변수(Variable)에 저장될 데이터의 형식을 나타내는 것으로, 변수에 값을 저장하기 전에 문자형, 정수형, 실수형 등 어떤 형식의 값으로 저장할지 선언하는 것
| --- | --- | --- |
#불문열_정소배
- **C/C++의 데이터 타입 크기**
| --- | --- | --- |
#### 2. 변수 ⭐⭐⭐
>[!summary] p.555, 4-25

1. 변수(Variable)의 개요
- 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간으로, 변할 수 있는 값을 의미

2. 변수명 작성 규칙 ⭐ __ 20년 3회 기출문제
- 영문자, 숫자, _(under bar) 사용 가능 ⭐ → ex) a, A, a1, _, _korea (O) / text-color (X)

- 첫 글자는 영문자(대, 소문자), _(under bar)로 시작할 수 있으나, 숫자는 올 수 없음 ⭐
- 글자 수에 제한이 없고, 대, 소문자 구분 → Kim, kim (O)
- 공백이나 *, +, -, / 등의 특수문자를 사용할 수 없음 ⭐ → ex) my student, $a, <a (X)
- 예약어를 변수명으로 사용할 수 없음 ⭐ → if, for, while (X)
- 변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 함
| --- | --- |
3. 예약어 – C언어
| --- | --- | --- |
4. 기억 클래스
- 변수 선언 시 메모리 내에 변수의 값을 저장하기 위한 기억영역이 할당되는데, 할당 되는 기억영역에 따라 사용 범위에 제한이 있다. 이러한 기억영역을 결정하는 작업을 기억 클래스(Storage Class)라 함

| --- | --- | --- | --- | --- |
#자레정외

5. 변수의 선언
| --- | --- |
#### 3. 연산자 ⭐⭐⭐
>[!summary] p.560, 4-26

#산시관비논
1. 산술 연산자 ⭐
| --- | --- |
ex) ++a, --a (연산 전 ↑, ↓)
ex) a++, a-- (연산 후 ↑, ↓)
2. 시프트 연산자
| --- | --- | --- |
3. 관계 연산자 ⭐
| --- | --- |
4. 비트 연산자 ⭐ __ 20년 1, 2회 기출문제
- 비트별(0, 1)로 연산해 결과를 얻는 연산자
| --- | --- | --- |
5. 논리 연산자 ⭐
- 두 개의 논리 값을 연산하여 참(true, 1) 또는 거짓(false, 0)을 결과로 얻는 연산자
| --- | --- | --- |
#조대순
6. 조건 연산자(삼항 연산자) __ 20년 3회 기출문제
- 조건에 따라 서로 다른 수식 수행 / **if(?),** **else(:)**
	- 산출물 : 조건 수식 **?** 수식1 **:** 수식2;
→ ‘조건 수식’이 **참**(true, 1)이면 ‘**수식1**’ 수행, **거짓**(false, 0)이면 ‘**수식2**’ 수행
7. 대입 연산자
| --- | --- | --- |
8. 기타 연산자
| --- | --- |
9. 연산자 우선순위 ⭐
| --- | --- | --- | --- | --- |
#산시관비논 조대순

#### 4. 제어문, 반복문 ⭐⭐
>[!summary] p.572~579, 4-27

1. 제어문의 개념
- 컴퓨터 프로그램은 명령어가 서술된 순서에 따라 무조건 위에서 아래로 실행되는데, 조건을 지정해서 진행 순서를 변경할 수 있다. 이렇게 프로그램의 순서를 변경할 때 사용하는 명령문을 제어문이라고 함

2. 단순 if문
- 형식 1: 조건이 참일 때만 실행

- 조건이 참일 때 실행할 문장이 하나인 경우

if(조건)

실행할 문장;

- 조건이 참일 때 실행할 문장이 두 문장 이상인 경우

if(조건)

{

실행할 문장1; // 실행할 문장이 두 문장 이상이면 { } 중괄호로 감싸기



실행할 문장2;

…

}
- 형식 2: 조건이 참일 때와 거짓일 때 실행할 문장이 다름


if(조건)

실행할 문장1; // 조건이 **참**일 경우 실행

else

실행할 문장2; // 조건이 **거짓**일 경우 실행

3. 다중 if문 ⭐
- 형식 1: 조건이 여러 개일 때 사용


if(조건1)

실행할 문장1; // 조건1이 참일 경우 실행

else if(조건2)

실행할 문장2; // 조건2가 참일 경우 실행

else if(조건3)

실행할 문장3; // 조건3이 참일 경우 실행

…

else

실행할 문장4; // 앞의 조건이 모두 거짓일 경우 실행

- 형식 2: if문 안에 if문이 포함됨

if(조건1)

{ // 조건1이 참일 경우 실행

if(조건2)

실행할 문장1; // 조건2가 참일 경우 실행

else(조건2)

실행할 문장2; // 조건2가 거짓일 경우 실행

}

else

실행할 문장3; // 조건1이 거짓일 경우 실행

4. switch문 ⭐⭐
- 조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리할 수 있는 제어문


switch(수식)

{

case 레이블1:

실행할 문장1; // 수식의 결과가 레이블 1과 일치할 때 실행

break; // switch문 종료함

case 레이블 2:

실행할 문장2; // 수식의 결과가 레이블 2와 일치할 때 실행

break; // switch문 종료함

…

default: // 수식의 결과가 레이블 1~2와 일치하지 않을 때,
실행할 문장3; 혹은 break가 없을 땐 무조건 default 실행


}

ex)
switch(2)


{ case 3: printf(“1”); // 수식의 결과(2)가 레이블 1(3)과 일치하지 않음

break;

case 2: printf(“2”); // 수식의 결과(2)가 레이블 2(2)와 일치함 → printf(“2”); 실행

break; // switch문 종료함

case 1: printf(“3”); // 수식의 결과(2)가 레이블 3(1)과 일치하지 않음
break;


} → 결과 2 표시됨

5. 반복문의 개념
- 제어문의 한 종류로 일정한 횟수를 반복하는 명령문을 말한다. 보통 변수의 값을 일정하게 증가시키면서 정해진 수가 될 때까지 명령이나 명령 그룹을 반복 수행함

6. for문
- 초기값, 최종값, 증가값을 지정하는 수식을 이용해 정해진 횟수를 반복하는 제어문
- 초기값을 정한 다음 최종값에 대한 조건이 참이면 실행할 문장을 실행한 후 초기값을 증가값 만큼 증가시키면서 최종값에 대한 조건이 참인 동안 실행할 문장을 반복 수행함


- 형식

for(초기값; 최종값; 증가값)

실행할 문장; // 최종값이 참인 동안 실행, 두 문장 이상 → { } 입력



7. while문
- 조건이 참인 동안 실행할 문장을 반복 수행하는 제어문
- 조건이 참인 동안 실행할 문장을 반복 수행하다가 조건이 거짓이면 while문을 끝낸 후 다음 코드를 실행

- 조건이 처음부터 거짓이면 한 번도 실행하지 않음 ⭐

- 형식

while(조건)

실행할 문장; // 조건이 참인 동안 실행, 두 문장 이상 → { } 입력



8. do ~ while문 ⭐
- 조건이 참인 동안 정해진 문장을 반복 수행하다가 조건이 거짓이면 반복문을 벗어나는 while문과 같은 동작을 함

- 그러나 조건이 처음부터 거짓이어도 실행할 문장을 무조건 한 번 실행함**,** 그리고 다음 조건을 판단하여 탈출 여부를 결정함

- 형식

do

실행할 문장; // 조건이 참인 동안 실행, 두 문장 이상 → { } 입력

while(조건);

9. break, continue
- switch문이나 반복문의 실행을 제어하기 위해 사용되는 예약어
- break ⭐
- switch문이나 반복문 안에서 break가 나오면 블록을 벗어남
- continue
- continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮김
- 반복문에서만 사용됨
#### 5. 배열과 문자열 ⭐⭐
>[!summary] p.585

1. 배열의 개념
- 동일한 데이터 유형을 여러 개 사용해야 할 경우 이를 손쉽게 처리하기 위해 여러 개의 변수들을 조합해서 하나의 이름으로 정의해 사용하는 것

- 개별적인 요소들의 위치는 첨자를 이용하여 지정
- 변수명 뒤에 대괄호 [ ]를 붙이고 그 안에 사용할 개수를 지정
- C언어에서 배열의 위치는 0부터 시작됨
2. 1차원 배열
- 1차원 배열은 변수들을 일직선상의 개념으로 조합한 배열

| --- | --- |
첫 번째 두 번째 세 번째 네 번째 다섯 번째
| --- | --- | --- | --- | --- |
	- 산출물 : a[3]: a는 배열의 이름이고, 3은 첨자로 배열 a에서의 위치를 나타냄
a[3]에 4를 저장시키려면 ‘a[3]=4’와 같이 작성
3. 2차원 배열 ⭐
- 2차원 배열은 변수들을 평면, 즉 행과 열로 조합한 배열

| --- | --- |
첫 번째 두 번째 세 번째 네 번째 다섯 번째
| --- | --- | --- | --- | --- |
	- 산출물 : b[0][2]: b는 배열의 이름이고, 0은 행 첨자, 2는 열 첨자로서 배열 b의 위치를 나타냄
4. 배열의 초기화
- 배열 선언 시 초기값을 정할 수 있음


- 1차원 배열 초기화

char a[3] = {‘A’, ‘B’, ‘C’} / char a[ ] = {‘A’, ‘B’, ‘C’}



| --- | --- | --- |
a[0] a[1] a[2]


- 2차원 배열 초기화

int a[2][4] = { {10, 20, 30, 40}, {50, 60, 70, 80} }; / = { 10, 20, 30, 40, 50, 60, 70, 80};



a[0][0] a[0][1] a[0][2] a[0][3]

| --- | --- | --- | --- |
a[1][0] a[1][1] a[1][2] a[1][3]

5. 배열 형태의 문자열 변수
→ char 배열이름[크기] = “문자열”


ex) char a[5] = “love”

| --- | --- | --- | --- | --- |
*문자열의 끝을 알리기 위한 널 문자(‘\0’)이 자동 삽입됨

#### 6. 포인터 ⭐
>[!summary] p.594

1. 포인터와 포인터 변수
- 포인터는 변수의 주소를 말하며, C언어에서는 주소를 제어할 수 있는 기능을 제공함

- C언어에서 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라고 함
- 포인터 변수는 필요에 의해 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수임

- 포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 간접 연산자 *를 붙임 → int *a;

- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 &를 붙임 → a = &b;

- 실행문에서 포인터 변수에 간접 연산자 *를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말함 → c = *a;

2. 포인터와 배열
- 배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근할 수 있음

- 배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 & 연산자를 사용

ex) int a[5], *b;

b = a → 배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주소를 b에 저장함

b = &a[0] → a 배열의 첫 번째 요소인 a[0]의 주소(&)를 b에 저장함

#### 7. 절차적 프로그래밍 언어 ⭐⭐
>[!summary] p.600, 4-29

1. 절차적 프로그래밍 언어의 개요
- 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해나가는 언어

- 프로그램이 실행되는 절차(Procedure)를 중요시 함
2. 절차적 프로그래밍 언어의 장, 단점
- 컴퓨터의 처리 구조와 유사하여 실행 속도가 빠름

- 같은 코드를 복사하지 않고 다른 위치에서 호출하여 사용할 수 있음(이식성)
- 모듈 구성이 용이하며, 구조적인 프로그래밍이 가능함
- 프로그램을 분석하기 어렵고, 유지 보수나 코드의 수정이 어려움
3. 절차적 프로그래밍 언어의 종류 ⭐
| --- | --- |
#### 8. 객체지향 프로그래밍 언어 ⭐⭐
>[!summary] p.602, 4-30

1. 객체지향 프로그래밍 언어의 개요
- 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 프로그램을 작성할 수 있도록 한 프로그래밍 기법

2. 객체지향 프로그래밍 언어의 장, 단점
- 상속을 통한 재사용과 시스템의 확장이 용이하고, 코드의 재활용성이 높음

- 사용자와 개발자 사이의 이해를 쉽게 해주고, 대형 프로그램의 작성이 용이함
- 프로그래밍 구현을 지원해 주는 정형화된 분석 및 설계 방법이 없음
- 구현 시 처리 시간이 지연됨 → 실행 속도가 느림
3. 객체지향 프로그래밍 언어의 종류 ⭐
| --- | --- |
4. 객체지향 프로그래밍 언어의 구성 요소 ⭐
- 객체(Object)
- 독립적으로 식별 가능한 이름을 갖고 있음

- 객체가 가질 수 있는 조건인 상태(State)는 일반적으로 시간에 따라 변함
- 객체와 객체는 상호 연관성에 의한 관계가 형성됨
- 객체가 반응할 수 있는 메시지의 집합을 행위(연산, Method)라고 하며, 객체는 행위의 특징을 나타냄
- 객체는 일정한 기억장소를 갖고 있음
- 클래스(Class)
- 공통된 속성과 연산(행위)를 갖는 객체의 집합

- 객체지향 프로그램에서 데이터를 추상화하는 단위 ⭐
- 각각의 객체들이 갖는 속성과 연산(Method)을 정의하고 있는 틀
- 슈퍼 클래스(Super Class)는 특정 클래스의 상위(부모) 클래스
- 서브 클래스(Sub Class)는 특정 클래스의 하위(자식) 클래스
- 인스턴스(Instance)
- 클래스에 속한 각각의 객체

- 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 함
- 메서드(Method)
- 클래스로부터 생성된 객체를 사용하는 방법
- 전통적 시스템의 함수(Function) 또는 프로시저(Procedure)에 해당하는 연산
- 메시지(Message)
- 객체에게 어떤 행위를 하도록 지시하기 위한 방법
5. 객체지향 프로그래밍 언어의 특징 ⭐⭐
| --- | --- |
#캡상다추정
#### 9. 스크립트 언어 ⭐⭐
>[!summary] p.605, 4-31, 20년 1, 2회 기출문제

1. 스크립트 언어의 개요
- HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 것으로, 기계어로 컴파일 되지 않고 별도의 번역기가 소스를 분석하여 동작하게 하는 언어

- 클라이언트의 웹 브라우저에서 해석되어 실행되는 클라이언트용 언어와, 서버에서 해석되어 실행된 후 결과만 클라이언트로 보내는 서버용 스크립트 언어

	- 산출물 : **클라이언트용 언어**: JavaScript / **서버용 스크립트 언어**: ASP, JSP, PHP, Python

2. 스크립트 언어의 장, 단점
- 컴파일 없이 바로 실행하므로 결과를 바로 확인할 수 있음 ⭐

- 개발 시간이 짧고, 소스 코드를 쉽고 빠르게 수정할 수 있음
- 코드를 읽고 해석해야 하므로 실행 속도가 느리고, 런타임 오류가 많이 발생함
3. 스크립트 언어의 종류 ⭐
| --- | --- |
#### 10. 선언형 언어 ⭐
>[!summary] p.607, 4-32

1. 선언형 언어의 개요
- 명령형 언어가 문제를 해결하기 위한 방법을 기술한다면, 선언형 언어는 프로그램이 수행해야 하는 문제를 기술하는 언어

- 함수형 언어(적용형 언어)와 논리형 언어(선언적 언어)가 있음
- 목표를 명시하고 알고리즘은 명시하지 않음

cf) **명령형 언어**(절차적 언어, 객체지향 언어)

- 알고리즘을 명시하고 목표는 명시하지 않음
- 폰노이만 구조에 개념적인 기초를 두고 있음
- 특정 구문의 연산을 이용하여 상태를 변경시키고 프로그램을 동작시킴
2. 선언형 언어의 장, 단점
- 가독성이나 재사용성이 좋고, 오류가 적음

- 프로그램 동작을 변경하지 않고도 관련 값을 대체할 수 있음
3. 선언형 언어의 종류
| --- | --- |
#### 11. 라이브러리 ⭐
>[!summary] p.609, 4-10, 4-36

1. 라이브러리(Library)의 개념
- 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체로 필요할 때 언제든지 호출하여 사용할 수 있음


- **표준 라이브러리**: 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리

- **외부 라이브러리**: 개발자들이 필요한 기능을 만들어 인터넷 등에 공유해 놓을 것으로, 다운받아 설치한 후 사용함

2. C언어의 대표적인 표준 라이브러리
| --- | --- |
3. JAVA의 대표적인 표준 라이브러리
- JAVA에서 패키지를 사용하려면 ‘import java.util’과 같이 import문을 이용해 선언한 후 사용해야 함

| --- | --- |
### 응용 SW 기초기술 활용
#### 1. 데이터 입, 출력 ⭐⭐
>[!summary] p.611, 4-37

1. scanf( ) 함수
- C언어의 표준 입력 함수, 키보드로 입력받아 변수에 저장하는 함수

| --- | --- |
ex) scanf(“%3d”, &a); → %: 서식 문자 / 3: 입력 자릿수 / d: 10진수 / &a: 변수 a의 주소
	- 산출물 : 서식 문자열과 변수의 자료형은 일치해야 함, 한 번에 여러 개의 데이터 입력 가능
- **서식 문자열**
| --- | --- |
2. printf( ) 함수
- C언어의 표준 출력 함수, 인수로 주어진 값을 화면에 출력하는 함수

| --- | --- |
ex) printf(“%-8.2f”, 200.2); → 200.20VV(V는 빈 칸을 의미함)
%: 서식 문자 / -: 왼쪽부터 출력 / 8: 출력 자릿수 / 2: 소수점 이하 자리 / f: 실수 출력
- **주요 제어문자**
| --- | --- | --- |
3. 기타 표준 입, 출력 함수 ⭐
| --- | --- | --- |
#### 2. 운영체제의 개념 ⭐⭐⭐
>[!summary] p.632~637, 4-40

1. 운영체제(OS; Operating System)의 정의
- 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임


	- 산출물 : 사용자 > 응용 프로그램 > 유틸리티 > **운영체제(OS)** > 하드웨어

2. 운영체제의 목적 ⭐
| --- | --- |
#처반사신
3. 운영체제의 기능 ⭐ __ 20년 3회 기출문제
- CPU, 메모리 공간, 프로세서(처리기, Processor), 기억장치(주기억장치, 보조 기억장치), 입, 출력 장치, 파일 및 정보 등의 자원 관리

- 다중 사용자와 다중 응용프로그램 환경 하에서 현재 상태를 파악하고 자원을 효율적으로 분배 및 관리하기 위해 스케줄링 기능 제공
- 사용자와 시스템 간의 편리한 인터페이스 제공, 입출력 장치와 사용자 프로그램 제어
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
- 시스템의 오류 검사 및 복구, 자원 보호 기능 제공
- 입, 출력에 대한 보조 기능 제공 → 가상 계산기 기능 제공
4. 운영체제의 주요 자원 관리
| --- | --- |
5. 운영체제의 종류 ⭐
| --- | --- | --- |
6. Windows의 주요 특징 ⭐
- **GUI**(Graphic User Interface, 그래픽 사용자 인터페이스)
-키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식


→ 초보자도 쉽게 사용할 수 있게 GUI 채용

- **선점형 멀티태스킹**(Preemptive Mulit-Tasking)
-동시에 여러 개의 프로그램을 실행하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식


→ 하나의 응용 프로그램이 CPU를 독점하는 것을 방지할 수 있어 시스템 다운 현상없이 더욱 안정적인 작업을 할 수 있음

- **PnP**(Plug and Play, 자동 감지 기능)
-컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 OS가 자동으로 구성해주는 기능


→ 운영체제가 하드웨어의 규격을 자동으로 인식하여 동작하게 해주므로 PC 주변장치를 연결할 때 사용자가 직접 환경을 설정하지 않아도 됌,

PnP기능을 활용하기 위해서는 하드웨어와 소프트웨어 모두 PnP를 지원해야 함

- **OLE**(Object Linking and Embedding)
-다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체(Objects)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding)하여 편집할 수 있게 하는 기능


→ OLE로 연결된 이미지를 원본 프로그램에서 수정하거나 편집하면 그 내용이 그대로 해당 문서에 반영됨

- 255자의 긴 파일명
-VFAT(Virtual File Allocation Table)를 이용해 최대 255자까지 파일 이름 지정 가능


→ 파일 이름으로는 \ / : * ? “ < > |를 제외한 모든 문자 및 공백을 사용할 수 있으며, 한글의 경우 127자까지 저장 가능

- 개인 사용자(Single-User) 시스템
- 컴퓨터 한 대를 한 사람만이 독점해서 사용
6. UNIX의 개요 및 특징 ⭐⭐
- 소스가 공개된 개방형 시스템(Open System)
- 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제

- **다**중 작업(Multi-Tasking, 멀티 태스킹) 지원
- 다중 **사**용자(Multi-User) 지원
- 대부분 C언어로 작성되어 있어 **이**식성이 높으며 장치, 프로세스 간의 호환성이 높음
- **계**층 구조(트리 구조)의 파일 시스템
#대다사이계
→ 하드웨어 > **커널(Kernel)** > **쉘(Shell)** > 유틸리티(Utility) > 사용자(User)
- **커널(Kernel)** ⭐
- UNIX의 가장 핵심적인 부분
- 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행됨
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당
- 프로세스 관리, 기억장치 관리, 파일 관리, 입, 출력 관리 등 여러 가지 기능 수행
- 쉘(Shell)** **⭐ __ 20년 1, 2회 기출문제
- 사용자의 명령어를 인식하여 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
-주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능

- 시스템과 사용자 간의 인터페이스 역할을 담당
- 파이프라인 기능 지원 및 입, 출력 재지정을 통해 입, 출력의 방향 변경 가능
- 여러 종류의 쉘이 있음
- DOS의 COMMAND.COM과 같은 기능 수행
7. UNIX에서의 프로세스 간 통신
- 각 프로세스는 시스템 호출을 통해 커널의 기능을 사용하며, 프로세스 간 통신은 시그널(Signal), 파이프(Pipe), 소켓(Socket) 사용

- **시그널**(Signal): 간단한 메시지를 이용하여 통신하는 것, 초기 UNIX 시스템에서 사용
- 파이프(Pipe): 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식

- **소켓**(Socket): 프로세스 사이의 대화를 가능하게 하는 쌍방향 통신 방식
8. LINUX의 개요 및 특징
- 1991년 리누스 토발즈(Linus Torvalds)가 UNIX를 기반으로 개발한 운영체제
- 대부분의 특징이 UNIX와 동일하며 UNIX와 완벽하게 호환됨
- 프로그램 소스 코드가 무료로 공개되어 있음
9. MacOS의 개요 및 특징
- 1980년대 Apple사가 UNIX를 기반으로 개발한 운영체제
- 아이맥(iMAC)과 맥북(MacBook) 등 애플 사에서 생산하는 제품에서만 사용 가능
- 드라이버 설치 및 install과 uninstall의 과정이 단순
#### 3. 기억장치 관리 ⭐⭐⭐
>[!summary] p.640, 4-43

1. 기억장치의 관리 전략의 개요 ⭐
- 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기(When), 적재 위치(Where) 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위함


	- 산출물 : **반**입(Fetch), **배**치(Placement), **할**당(Allocation), **교**체(Replacemnet)

#반배할교

2. 반입(Fetch) 전략
- 보조기억장치에 보관중인 프로그램이나 데이터를 언제(When) 주기억장치로 적재할 것인지를 결정하는 전략


- 요구 반입(Demand Fetch): 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법

- 예상 반입(Anticipatory Fetch): 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법

3. 배치(Placement) 전략 __ 20년 3회 기출문제
- 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에(Where) 위치시킬 것인지를 결정하는 전략


- **최**초 적합(First Fit): 빈 영역 중에서 첫 번째 분할 영역에 배치

- 최**적** 적합(Best Fit): 빈 영역 중에서 단편화를 가정 작게 남기는 분할 영역에 배치

- 최**악** 적합(Worst Fit): 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치

#최적악

4. 교체(Replacement) 전략 __ 4-46
- 이미 사용되고 있는 영역 중에서 어느(Who) 영역을 교체할지 결정하는 전략


	- 산출물 : FIFO, LRU, LFU, NUR, OPT, SCR

5. 주기억장치 할당(Allocation)의 개념 ⭐
- 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게(How) 할당할지 정함


- **연**속 할당 기법: 프로그램을 주기억장치에 연속으로 할당하는 기법
	- 산출물 : **단**일 분할 할당 기법: 오버레이, 스와핑

	- 산출물 : **다**중 분할 할당 기법: 고정(정적) 분할 할당 기법, 가변(동적) 분할 할당 기법

- **분**산 할당 기법: 프로그램을 특정 단위의 조각으로 나누어 할당하는 기법
	- 산출물 : **페**이징(Paging) 기법 / **세**그먼테이션(Segmentation) 기법

#연단다_분페세

6. 가상기억장치의 개요 ⭐
- 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법

- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용
- 주기억장치의 이용률과 다중 프로그래밍 효율을 높일 수 있음
- 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업 필요
- 블록 단위로 나누어 사용하므로 연속 할당 방식의 단편화 해결 가능
7. 페이징(Paging) 기법 ⭐
- 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법

- 일정한 크기로 나눈 단위를 페이지(Page)라 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라 함
- 외부 단편화는 발생하지 않으나, **내부 단편화 발생 __ 4-48**
- 주소 변환을 위해 페이지의 위치 정보를 갖고 있는 페이지 맵 테이블(Page Map Table) 필요 → 페이지 맵 테이블 사용으로 비용 증가, 처리 속도 감소
8. 세그먼테이션(Segmentation) 기법 ⭐
- 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 기억공간을 절약하기 위해서 사용하는 실행시키는 방법

- 논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 가짐
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 갖고 있는 세그먼트 맵 테이블(Segment Map Table) 필요
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키(Storage Protection Key)가 필요
- 내부 단편화는 발생하지 않으나, **외부 단편화 발생 __ 4-48**
8. 페이지 교체 알고리즘 ⭐
- FIFO(First In First Out) = FCFS(First Come First Serve)

- 각 페이지가 주기억장치에 적재될 떄마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법

- **LRU**(Least Recently Used)

- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
- 가장 오래 전에 사용된 페이지 교체

- **LFU**(Least Frequently Used)

- 사용 빈도가 가장 적은 페이지를 교체하는 기법

- **OPT**(OPTimal replacement, 최적 교체)

- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
- 벨레이디(Belady)가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘

- **NUR**(Not Used Recently)

- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
- 각 페이지마다 두 개의 비트, 즉 참조 비트와 변형 비트 사용
| --- | --- | --- | --- | --- |
- SCR(Second Chance Replacement, 2차 기회 교체)

- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법
9. 페이지 크기 ⭐⭐
- **페이지 크기가 작을 경우**
- 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
- 불필요한 내용이 주기억장치에 적재될 확률이 적으므료 효율적인 워킹 셋 유지 가능
- Locality에 더 일치할 수 있기 때문에 기억장치 효율 높아짐
- 페이지 정보를 갖는 페이지 맵(사상) 테이블의 크기가 커지고, 매핑 속도가 늦어짐
- 디스크 접근 횟수가 많아져서 전체적인 입, 출력 시간은 늘어남
- **페이지 크기가 클 경우**
- 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남
- 불필요한 내용까지도 주기억장치에 적재될 수 있음
- 페이지 정보를 갖는 페이지 맵(사상) 테이블의 크기가 작아지고, 매핑 속도가 빨라짐
- 디스크 접근 횟수가 줄어들어 전체적인 입, 출력 효율성이 증가됨
10) Locality(지역성, 구역성) ⭐⭐
- 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론

- 스래싱(Thrashing)을 방지하기 위한 워킹 셋 이론의 기반
- 데닝(Denning) 교수에 의해 구역성의 개념이 증명됐으며, 캐시 메모리 시스템의 이론적 근거
| --- | --- |
11) 워킹 셋(Working Set) ⭐ __ 4-50
- 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
- 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정됨

- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경됨
12) 페이지 부재 빈도(PFF; Page Fault Frequency) 방식 __ 4-50
- 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식

- 페이지 부재(Page Fault)는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상이며, 페이지 부재 빈도는 페이지 부재가 일어나는 횟수를 의미함
13) 프리페이징(Prepaging)
- 처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 미리 한꺼번에 페이지 프레임에 적재하는 기법


→ 기억장치에 들어온 페이지들 중에서 사용되지 않는 페이지가 많을 수도 있음

14) 스래싱(Thrashing) ⭐ __ 4-49
- 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
→ 전체 시스템 성능 저하
- 다중 프로그래밍(멀티 태스킹)의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소됨

- **스래싱 현상 방지 방법**
- 다중 프로그래밍의 정도를 적정 수준으로 유지 ⭐
- 페이지 부재 빈도(Page Fault Frequency)를 조절해 사용
- 워킹 셋(Working Set)을 유지함
- 부족한 자원을 증설하고, 일부 프로세스를 중단시킴
#### 4. 프로세스 및 스케줄링 ⭐⭐
>[!summary] p.657~661, 4-51

1. 프로세스(Process)의 정의
- 일반적으로 프로세서(처리기, Processor), 즉 CPU에 의해 처리되는 사용자 프로그램, 시스템 프로그램인 실행중인 프로그램을 의미하며 작업(Job), 태스크(Task)라고도 함

- 프로세서(Processor) → 프로세스(Process) → 프로시저(Procedure, 절차)

- 프로세스의 정의 ⭐

- 프로시저가 활동중인 것
- 비동기적 행위를 일으키는 주체 **⭐⭐**
- 운영체제가 관리하는 실행 단위
- 실행중인 프로그램
- PCB(Process Control Block)을 가진 프로그램
- 실기억장치에 저장된 프로그램
- 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
2. PCB(Process Control Block, 프로세스 제어 블록) ⭐
| --- | --- |
#식상카레_스계입메
3. 프로세스 상태 전이 ⭐ __ 20년 1, 2회 기출문제
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image1.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%204과목%20프로그래밍%20언어%20활ᄋ%20d17101021a174d90a1e18a14fc38b60c/image1.png)
4. 프로세스 상태 전이 관련 용어
| --- | --- |
5. 스레드(Thread) ⭐ __ 20년 1, 2회 기출문제
- 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 단위


- **단일 스레드**: 하나의 프로세스에 하나의 스레드가 존재하는 경우

- **다중 스레드**: 하나의 프로세스에 하나 이상의 스레드가 존재하는 경우 ⭐

- 프로세스의 일부 특성을 갖고 있기 떄문에 경량 프로세스라고도 함
- 동일 프로세스 환경에서 서로 독립적인 다중 수행 가능

→ 하나의 프로세스를 여러 개의 스레드로 생성해 병행성 증진 및 성능과 처리율 향상

프로그램 응답 시간 단축과 기억장소의 낭비가 줄어들고 통신이 향상됨 ⭐

6. 스케줄링(Scheduling)의 개요
- 프로세스가 생성되어 실행될 떄 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업

| --- | --- |
	- 산출물 : 문맥 교환(Context Switching): 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것 ⭐

7. 스케줄링의 목적
- 공정성: 모든 프로세스에 공정하게 할당

- 처리량 증가: 단위 시간당 프로세스 처리량 증가
- CPU 이용률 증가: CPU 낭비 시간 줄이고, 사용되는 시간 비율 증가
- 우선순위 제도: 우선순위가 높은 프로세스 먼저 실행
- 오버헤드 최소화: 오버헤드 최소화
- 응답시간(Response Time, 반응 시간) 최소화: 작업 지시 및 반응 시작 시간 최소화
- 반환 시간(Turn Around Time) 최소화: 제출한 시간부터 실행 완료 시간 최소화
- 대기 시간 최소화: 준비상태 큐에서 대기하는 시간 최소화
- 균형 있는 자원의 사용: 메모리, 입, 출력장치 등의 자원을 균형 있게 사용
- 무한 연기 회피: 자원을 사용하기 위해 무한정 연기되는 상태 회피

→ CPU이용률, 처리율, 반환 시간, 대기 시간, 응답 시간 ⭐

8. 프로세스 스케줄링의 기법 ⭐ __ 4-54
- 선점(Preemptive) 스케줄링: 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 선점할 수 있는 기법

- 우선순위가 높은 프로세스 빠르게 처리 가능
- 빠른 응답 시간을 요구하는 대화식 시분할 시스템(Time Sharing System)에 사용됨
- 많은 오버헤드 발생
- 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록 필요

	- 산출물 : **R**ound Robin, SR**T**(Shortest Remaining Time), **M**LQ(Multi-Level Queue), M**F**Q

#RTMF

- 비선점(Non-Preemptive) 스케줄링: 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 선점할 수 없는 기법

- CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU 사용
- 모든 프로세스에 대한 요구를 공정하게 처리 가능
- 프로세스 응답 시간의 예측 용이
- 일괄 처리 방식에 적합
- 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우 발생

→ 가뭄 현상

	- 산출물 : 우선순위(**P**riority), 기한부(**D**eadline), **F**CFS(FIFO), S**J**F(Shortest Job First), **H**RN

#PDF_JH

- **HRN(Highest Response-ratio Next) __ 20년 1, 2, 3회 기출문제**

SJF 기법의 가뭄 현상을 보완하기 위한 방식으로, 대기 시간이 긴 프로세스일 경우 우선순위가 높아지고, 우선순위 계산식의 수치가 **가장 높은 것부터 낮은 순으로 우선순위를 부여**해 긴 작업과 짧은 작업 간의 지나친 불평등을 해소함

→ **HRN 우선순위 계산식**: (대기시간 + 서비스시간) / 서비스시간 ⭐

#### 5. 인터넷 및 OSI 참조 모델 ⭐⭐⭐
>[!summary] p.669~672, 4-70

1. IP 주소(Internet Protocol Address) __ 4-78
- 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소

- 숫자로 8비트씩 4부분, 총 32비트로 구성됨
| --- | --- |
2. 서브네팅(Subnetting)
- 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것
- 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라 하며, 이를 변경해 네트워크 주소를 여러 개로 분할해 사용

3. IPv6(Internet Protocol version 6) ⭐ __ 20년 1, 2, 3회 기출문제
- 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발됨
- 128비트의 긴 주소를 사용하고, IPv4에 비해 자료 전송 속도가 빠름
- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 해결 가능
- IPv4와 호환성이 뛰어나고, IPv6 확장 헤더로 네트워크 기능 확장이 용이함
- Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장(QoS; Quality of Service)이 용이

	- 산출물 : **유**니캐스트(Unicast), **멀**티캐스트(Multicast), **애**니캐스트(Anycast)
#유멀애⭐
cf) IPv4: **유**니캐스트, **멀**티캐스트, **브**로드캐스트(Broadcast) #유멀브
4. 도메인 네임(Domain Name)
- 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것

- 호스트 컴퓨터 이름(www), 소속 기관 이름(hankook), 소속 기관의 종류(co), 소속 국가명(kr) → www.hankook.co.kr
- 문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)라고 하며, 이런 역할을 하는 서버를 DNS 서버라 함 ⭐
5. OSI(Open System Interconnection) 참조 모델 ⭐⭐ __ 4-73, 20년 1, 2, 3회 기출문제
| --- | --- | --- |
#아(A)파(P)서(S)_티(T)내(Ne)다(Da)_피(Phy)나다!
#### 6. 네트워크 관련 장비 및 프로토콜 ⭐⭐
>[!summary] p.676~679

1. 네트워크 관련 장비
| --- | --- |
#게라스_브리허
2. 프로토콜(Protocol)의 정의 __ 4-72
- 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약

3. 프로토콜의 기본 요소 ⭐⭐
| --- | --- |
#구의타
TCP/IP ⭐⭐⭐
>[!summary] p.681

1. TCP/IP(Transmission Control Protocol/Internet Protocol)의 개요 __ 3회 기출문제
- 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜

| --- | --- |
2. TCP/IP의 구조 ⭐
| --- | --- | --- |
3. 응용 계층의 주요 프로토콜 ⭐
| --- | --- |
4. 전송 계층의 주요 프로토콜 ⭐
| --- | --- |
5. 인터넷 계층의 주요 프로토콜 ⭐ __ 20년 1, 2회 기출문제
| --- | --- |
6. 네트워크 액세스 계층의 주요 프로토콜 ⭐
| --- | --- |
**추가 정리, 수제비 및 기출문제** ⭐⭐⭐
1. 형상 관리 절차 __ 4-5
- 형상 식별: 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업


- 형상 **통**제(변경 관리): 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(베이스 라인, Base line)이 잘 반영될 수 있도록 조정하는 작업

- 형상 **감**사: 기준선(베이스 라인)의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업

- 형상 **기**록(상태 보고): 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

#식통감기

2. 모듈화 __ 4-11
| --- | --- |
#정분추독

3. 예외 처리 구성 __ 4-38
| --- | --- |
4. 프로토타입(Prototype) __ 4-39
- 속성과 메서드를 다른 클래스의 인스턴스 또는 빈 객체에 복제, 생성하는 작업을 덜 수 있는 프로그래밍 스타일

- 객체지향 프로그래밍과 달리 클래스를 명확히 정의하지 않아도 됨
5. 라우팅 프로토콜(Network, 3계층) ⭐ __ 4-85
| --- | --- |
6. 은행가 알고리즘(Banker’s Algorithm) __ 개정 전 기출문제, 20년 1, 2회 기출문제
- 교착상태의 해결 방법 중 Avoidance(회피) 사용
7. 교착 상태 발생의 필요 충분 조건 __ 개정 전 기출문제, 20년 1, 2회 기출문제
- 상호 배제(Mutual Exclusion), 점유와 대기(Hold and Wait), 환형 대기(Circular Wait), 비선점(Non-Preemption)

#상점환비
8. IEEE 802.11e __ 개정 전 기출문제, 20년 1, 2회 기출문제
- IEEE 802.11 워킹 그룹의 무선 LAN 표준화 현황 중 QoS(Quality of Service) 강화를 위해 MAC 지원 기능을 채택한 것

9. JAVA 언어의 접근제한자 ⭐⭐ __ 개정 전 기출문제, 20년 1, 2회 기출문제
| --- | --- |
→ **public > protected > default > private**
10) 배열의 초기화 __ p.589, 기출문제
78. C 언어에서 배열 b[5]의 값은? (2020년 제1, 2회차 필기시험, B형)


static int b[9]={1, 2, 3};



| --- | --- | --- | --- | --- | --- | --- | --- | --- |
b[0] b[1] b[2] b[3] b[4] b[5] b[6] b[7] b[8]


→ **b[5] = 0;**

11) 페이지 결함(Page Fault) 횟수 __ 19년 2회 기출문제, 20년 1, 2회 기출문제
46. 4개의 프레임을 수용할 수 있는 주 기억장치가있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우 페이지 결함의 발생 횟수는?

![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image2.gif](image2.gif)
① 4회 ② 5회 **③ 6회** ④ 7회
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image3.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%204과목%20프로그래밍%20언어%20활ᄋ%20d17101021a174d90a1e18a14fc38b60c/image3.png)
12) UNIX 명령어 __ p. 667, 20년 3회, 21년 1회 기출문제
| --- | --- |
13) 서브넷(Subnet) __ 17년 2회 기출문제, 20년 3회 기출문제
89. 200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 subnet으로 나누고 ip subnet -zero를 적용했다. 이때 서브네팅된 네트워크 중 10번째 네트워크의 broadcast IP 주소는?

**① 200.1.1.159** ② 201.1.5.175
③ 202.1.11.191 ④ 203.1.255.245
→ “**10**”개의 subnet으로 나눠야 함으로 2^3=”**8**”로는 부족하고, 2^4=”**16**”으로 나눔
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image4.png](image4.png)
200.1.1.0.0~200.1.1.0.15 (0~15)
200.1.1.16.0~200.1.1.0.31 (16~31)
200.1.1.32.0~200.1.1.0.47 (32~47)
200.1.1.48.0~200.1.1.0.63 (48~63)
200.1.1.64.0~200.1.1.0.79 (64~79)
200.1.1.80.0~200.1.1.0.95 (80~95)
200.1.1.96.0~200.1.1.0.111 (96~111)
200.1.1.112.0~200.1.1.0.127 (112~127)
200.1.1.128.0~200.1.1.0.143 (128~143)
200.1.1.144.0~200.1.1.0.159 (144~159) - 10번째

14) 소프트웨어 취약점 __ 20년 3회 기출문제
- 메모리를 다루는 데 오류가 발생하여 잘못된 동작을 하는 프로그램 취약점
→ **버퍼 오버플로**
15) Python List [ ] __ 20년 3회 기출문제
74. 다음은 사용자로부터 입력받은 문자열에서 처리음과 끝의 3글자를 추출한 후 합쳐서 출력하는 파이썬 코드에서 ⓐ에 들어갈 내용은?

![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%204%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%20d17101021a174d90a1e18a14fc38b60c/image5.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%204과목%20프로그래밍%20언어%20활ᄋ%20d17101021a174d90a1e18a14fc38b60c/image5.png)
① string[1:3] + string[-3:] ② string[:3] + string[-3:-1]

**③ string[0:3] + string[-3:]** ④ string[0:] + string[:-1]
① 최종 출력: elrld → [1, 2] + [-3, -2, -1]
② 최종 출력: Helrl → [0, 1, 2] + [-3, -2]
③ 최종 출력: Helrld → [0, 1, 2] + [-3, -2, -1]
④ 최종 출력: Hello WorldHello Worl → [0 ~ 10] + [-11 ~ -2]
*정리: string[ ] 안에서 :을 기준으로 앞에 값은 시작, 뒤의 값은 해당하는 값의 전까지 list를 출력함

16) Java 출력함수 __ 20년 4회 기출문제
| --- | --- |
17) C언어 데이터 처리 – 열거체, 구조체, 공용체 __ 20년 4회 기출문제
| --- | --- |
18) PHP 연산자 __ 20년 4회 기출문제
| --- | --- |

## 5. 정보시스템 구축 관리
### 소프트웨어 개발 방법론 활용
#### 1. 소프트웨어 개발 방법론 ⭐⭐
>[!summary] p.696, 5-4

#구정_객컴_에제
1. 구조적 방법론
- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리중심의 방법론
- 타당성 검토 → 계획 → 요구사항 **분**석 → **설**계 → **구**현 → **테**스트 → **유**지보수 단계
#분설구테유
2. 정보공학 방법론
- 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료(Data) 중심의 방법론 → 대규모 정보 시스템 구축 적합

3. 객체지향 방법론 ⭐
- 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론


- 구성 요소: 객체(Object), 클래스(Class), 메시지(Message), 메서드(Method) 등

- 기본 원칙: **캡**슐화, **상**속성, **다**형성, **추**상화, **정**보 은닉 → #캡상다추정

4. 컴포넌트 기반(CBD; Component Based Design) 방법론
- 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론

- 컴포넌트 및 소프트웨어의 재사용이 가능하여 시간과 노력을 절감할 수 있음
- 새로운 기능 추가가 쉬운 확장성
- 개발 기간 단축으로 인한 생산성 향상
5. 애자일(Agile) 방법론 ⭐
- 애자일은 ‘민첩한’, ‘기민한’이라는 의미로, 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행하는 방법론


	- 산출물 : **X**P(eXtreme Programming), **스**크럼(Scrum), **칸**반(Kanban), **크**리스탈(Crystal) 등

#엑스칸크

6. 제품 계열 방법론
- 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론

- 임베디드 소프트웨어를 만드는데 적합

- **영역공학**: 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역

- **응용공학**: 제품 요구 분석, 제품 설계, 제품을 구현하는 영역

#### 2. 비용 산정 기법 ⭐
>[!summary] p.700

1. 소프트웨어 비용 산정의 개요
- 소프트웨어의 개발 규모를 소요되는 인원, 자원, 기간 등으로 확인하여 실행 가능한 계획을 수립하기 위해 필요한 비용을 산정하는 것


	- 산출물 : 하향식 비용 산정 기법, 상향식 비용 산정 기법

2. 소프트웨어 비용 결정 요소
- 프로젝트 요소

| --- | --- |
- 자원 요소

| --- | --- |
- 생산성 요소

| --- | --- |
#### 3. 하향식 비용 산정 기법 ⭐
>[!summary] p.702

1. 하향식 비용 산정 기법의 개요
- 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적인 방법


	- 산출물 : 전문가 감정 기법, 델파이 기법

2. 전문가 감정 기법
- 조직 내에 있는 경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법
- 새로운 프로젝트에는 과거의 프로젝트와 다른 요소들이 있다는 것을 간과할 수 있음
- 새로운 프로젝트와 유사한 프로젝트에 대한 경험이 없을 수 있음
- 개인적이고 주관적일 수 있음
**3) 델파이 기법** ⭐
- 전문가 감정 기법의 주관적인 편견을 보완하기 위해 한 명의 조정자와 여러 전문가의 의견을 종합하여 산정하는 기법

#### 4. 상향식 비용 산정 기법 ⭐⭐⭐
>[!summary] p.704, 5-7

1. 상향식 비용 산정 기법의 개요
- 프로젝트의 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법
	- 산출물 : LOC(원시 코드 라인 수) 기법, 개발 단계별 인월수(Effort Per Task),
수학적 산정 기법(COCOMO 모형, Putnam 모형, 기능점수 모형)

2. LOC(원시 코드 라인 수, source Line Of Code) 기법 ⭐ __ 20년 1, 2회 기출문제
- 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법


94. LOC기법에 의하여 예측된 **총 라인 수가 50,000라인**, 프로그래머의 **월 평균 생산성이 200라인**, 개발에 참여할 **프로그래머가10인** 일 때, **개발 소요 기간**은?

(2020년 제1, 2회차 필기시험, B형)

→ ( 50,000 / 200 ) / 10 = **25개월**
3. 개발 단계별 인월수(Effort Per Task) 기법
- LOC 기법을 보완하기 위한 기법으로, 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정함, LOC 기법보다 더 정확함

4. COCOMO(Constructive Cost Model) 모형 ⭐⭐
- 보헴(Boehm)이 제안한 것으로, 원시 프로그램의 규모인 LOC에 의한 비용 산정 기법

- 비용 견적의 강도 분석 및 비용 견적의 유연성이 높아 소프트웨어 개발비 견적에 널리 통용되고 있음
- 같은 규모의 프로그램이라도 그 성격에 따라 비용이 다르게 산정됨
- 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)로 나타남
- COCOMO의 소프트웨어 개발 유형** **⭐ __ 20년 1, 2, 3회 기출문제
| --- | --- |
- COCOMO 모형의 종류 ⭐
| --- | --- |
5. Putnam 모형 __ 20년 1, 2, 3회 기출문제
- 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 가정해주는 모형
- 푸트남(Putnam)이 제안한 것으로 생명 주기 예측 모형이라고도 함
- 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 함
- 대형 프로젝트의 노력 분포 산정에 이용되는 기법
- 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소함
→ **SLIM**: Rayleigh-Norden 곡선과 Putnam 예측 모형을 기초로 개발된 자동화 추정 도구
6. 기능점수(FP; Function Point) 모형
- 알브레히트(Albrecht)가 제안한 것으로, 소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능점수를 산출하며 총 기능점수와 영향도를 이용하여 기능점수(FP)를 구한 후 이를 이용해서 비용을 산정하는 기법


→ **ESTIMACS**: 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 개발된 자동화 추정 도구

7. 기능점수 모형에서 비용산정에 이용되는 요소 __ p.709, 20년 3회 기출문제
- 자료 **입**력(입력 양식)
- 정보 **출**력(출력 보고서)
- **명**령어(사용자 질의수)
- **데**이터 파일
- 필요한 외부 루틴과의 **인**터페이스
#입출명데인
8. 프로젝트 관리 __ p.711
- 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동

| --- | --- |
#일비인위품
#### 5. 소프트웨어 개발 표준 ⭐⭐
>[!summary] p.713, 5-13

1. ISO/IEC 12207
- ISO(International Organization for Standardization, 국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스로, 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공함


	- 산출물 : **기**본 생명 주기 프로세스, **조**직 생명 주기 프로세스, **지**원 생명 주기 프로세스

	- 산출물 : **기조지 ⭐**

2. CMMI(Capability Maturity Model Integration, 능력 성숙도 통합 모델) ⭐
- 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델


- **프로세스 성숙도 5단계 __ 20년 1, 2회 기출문제**

| --- | --- | --- |
#초관정량최

3. SPICE(Software Process Improvement and Capability dEtermination) __ 3회 기출
- 소프트웨어 개발 표준 중 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준으로, 공식 명칭은 ISO/IEC 15504임


- **SPICE의 목적**

- 프로세스 개선을 위해 개발 기관이 스스로 평가
- 기관에서 지정한 요구조건의 만족여부를 개발 조직이 스스로 평가
- 계약 체결을 위해 수탁 기관의 프로세스를 평가

- **SPICE의 5개 프로세스 범주**

- **고**객-공급자(Customer-Supplier) 프로세스, **공**학(Engineering) 프로세스, **지**원(Support) 프로세스, **관**리(Management) 프로세스, **조**직(Organization) 프로세스

#고공지관조

- **SPICE의 프로세스 수행 능력 단계 ⭐**

| --- | --- |
#불수관 확예최

#### 6. 테일러링, 프레임워크 ⭐
>[!summary] p.716~718, 5-14

1. 소프트웨어 개발 방법론 테일러링의 개요
- 프로젝트 상황 및 특성에 맞도록 정의된 소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업


- **수행절차**: 프로젝트 특징 **정**의 → **표**준 프로세스 선정 및 검증 → **상**위 수준의 커스터마이징 → **세**부 커스터마이징 → 테일러링 **문**서화

#정표상세문

2. 소프트웨어 개발 방법론 테일러링 고려사항 __ 20년 1, 2회 기출문제
- **내부적 요건**: 목표 환경, 요구사항, 프로젝트 규모, 보유 기술
- **외부적 요건: 법**적 제약사항, 국제**표**준 품질기준 #법표⭐
3. 스프링 프레임워크(Spring Framework) ⭐
- JAVA 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크

- 동적인 웹 사이트 개발을 위해 다양한 서비스 제공
- 전자정부 표준 프레임워크의 기반 기술로 사용됨
4. 전자정부 프레임워크
- 대한민국의 공공부문 정보화 사업 시 효율적인 정보 시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크

- 응용 소프트웨어의 표준화, 품질 및 재사용성의 향상을 목표로 함
5. 닷넷 프레임워크(.NET Framework) ⭐
- Microsoft에서 개발한 Windows 프로그램 개발 및 실행 환경을 제공하는 프레임워크로, 공통 언어 런타임(CLR; Common Language Runtime)이라는 가상머신 상에서 작동함

### IT프로젝트 정보시스템 구축관리
#### 1. 네트워크 구축 ⭐⭐
>[!summary] p.731, 5-23

![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%205%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%80%E1%85%AA%E1%86%AB%20c3e23d19a6684999a35f934c69af5f4c/image1.gif](image1.gif)
#버트링성망
1. 버스형(Bus) __ 20년 3회 기출문제
- 한 개의 통신 회선에 여러 대의 단말장치가 연결되어 있는 형태 → LAN에서 사용

- 물리적 구조가 간단하고, 단말장치의 추가와 제거가 용이
- 단말장치가 고장나더라도 통신망 전체에 영향을 주지 않기 때문에 신뢰성 향상
- 기밀 보장이 어렵고, 통신 회선의 길이에 제한이 있음
2. 계층형(Tree, 트리형, 분산형)
- 중앙 컴퓨터와 일정 지역의 단말장치까지는 하나의 통신 회선으로 연결시키고, 이웃하는 단말장치는 일정 지역 내에 설치된 중간 단말장치로부터 다시 연결시키는 형태 → 분산 처리 시스템

3. 링형(Ring, 환형, 루프형)
- 컴퓨터와 단말장치들을 서로 이웃하는 것끼리 포인트 투 포인트(Point-to-Point) 방식으로 연결시킨 형태 → LAN에서 사용

- 분산 및 집중 제어 모두 가능하고 중계기 수가 많아짐
- 단말장치의 추가/제거 및 기밀 보호가 어려움
- 각 단말장치에서 전송 지연이 발생할 수 있음
- 데이터는 단방향 또는 양방향으로 전송할 수 있고, **단방향 링**의 경우 컴퓨터, 단말장치, 통신 회선 중 어느 하나라도 고장나면 전체 통신망에 영향을 미침
4. 성형(Star, 중앙 집중형)
- 중앙에 중앙 컴퓨터가 있고, 이를 중심으로 단말장치들이 연결되는 중앙 집중식의 네트워크 구성 형태

- 포인트 투 포인트(Point-to-Point) 방식으로 회선을 연결
- 단말장치의 추가와 제거가 쉽지만, 중앙 컴퓨터가 고장나면 전체 통신망의 기능이 정지됨
- 중앙 집중식이므로 교환 노드의 수가 가장 적음
5. 망형(Mesh, 네트워크형)
- 모든 지점의 컴퓨터와 단말장치를 서로 연결한 형태로, 노드의 연결성이 높음
- 많은 단말장치로부터 많은 양의 통신을 필요로 하는 경우 유리
- **공중 데이터 통신망**에서 사용되며, 통신 회선의 총 경로가 가장 긺
- 통신 회선 장애 시 다른 경로를 통하여 데이터 전송 가능
6. 네트워크 분류
| --- | --- |
#### 2. 스위치 ⭐⭐
>[!summary] p.735, 5-26

1. 스위치(Switch) 분류
| --- | --- |
2. 스위칭 방식
**▶** **Store and Forwarding**: 데이터를 모두 받은 후 스위칭하는 방식
**▶** **Cut-through**: 데이터의 목적지 주소만을 확인한 후 바로 스위칭하는 방식
**▶** **Fragment Free**: 위의 두 가지 방식의 장점을 결합한 방식
3. 백본 스위치(Backbone Switch) ⭐
- 여러 네트워크들을 연결할 때 중추적 역할을 하는 네트워크를 백본(Backbone)이라 하고, 백본에서 스위칭 역할을 하는 장비를 백본 스위치라고 함

- 백본 스위치는 모든 패킷이 지나가는 네트워크의 중심에 배치함
- 주로 L3 스위치가 백본 스위치의 역할을 함
4. Hierarchical 3 Layer 모델 ⭐⭐ (모델 사진 출처: [net-study.club](https://net-study.club/entry/%EC%86%8C%EA%B7%9C%EB%AA%A8-LAN-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%B6%95-%EA%B8%B0%EC%B4%88-I))
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%205%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%80%E1%85%AA%E1%86%AB%20c3e23d19a6684999a35f934c69af5f4c/image2.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%205과목%20정보시스템%20구축%20관%20c3e23d19a6684999a35f934c69af5f4c/image2.png)
| --- | --- |
#코디액
#### 3. 경로 제어, 트래픽 제어 ⭐⭐
>[!summary] p.737

1. 경로 제어 프로토콜(Routing Protocol) __ 20년 1, 2, 3회 기출문제
| --- | --- |
2. 트래픽 제어(Traffic Control)
- 네트워크의 보호, 성능 유지, 네트워크 자원의 효율적인 이용을 위해 전송되는 패킷의 흐름 또는 그 양을 조절하는 기능으로 흐름 제어, 폭주(혼합) 제어, 교착상태 방지 기법이 있음

3. 흐름 제어(Flow Control)
- 네트워크 내의 원활한 흐름을 위해 송, 수신 측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능

| --- | --- |
4. 폭주(혼잡) 제어(Congestion Control)
- 흐름 제어(Flow Control)가 송, 수신 측 사이의 패킷 수를 제어하는 기능이라면, 혼잡 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로(Overflow)를 방지하는 기능을 함

| --- | --- |
5. 교착 상태(Dead Lock) 방지
- 교환기 내에 패킷들을 축적하는 기억 공간이 꽉 차 있을 때 다음 패킷들이 기억 공간에 들어가기 위해 무한정 기다리는 형상

6. 교착 상태 발생의 필요 충분 조건 __ 개정 전 기출문제
- 상호 배제(Mutual Exclusion), 점유와 대기(Hold and Wait), 환형 대기(Circular Wait), 비선점(Non-Preemption)

#상점환비
### 소프트웨어 개발보안 구축
#### 1. 소프트웨어 개발 보안 ⭐
>[!summary] p.747, 5-38

1. 소프트웨어 개발 보안 관련 기관
| --- | --- |
#감사한 발행

2. 소프트웨어 개발 직무별 보안 활동
- 프로젝트 관리자(Project Manager): 응용 프로그램에 대한 보안 전략 전달


- **요구사항 분석가**(Requirement Specifier): 요구사항 설명 및 정의

- **아키텍트**(Architect): 보안 기술 문제 이해

- **설계자**(Designer): 발생할 수 있는 보안 위험에 대해 이해 및 대응

- **구현 개발자**(Implementer): 시큐어 코딩 표준 준수 개발 및 문서화 ⭐

- **테스트 분석가**(Test Analyst): 요구사항과 구현 결과 반복적 확인

- **보안 감시자**(Security Auditor): 전체 단계에서 활동 및 보안 보장

Secure OS ⭐⭐
>[!summary] p.758

1. Secure OS의 개요
- 기존의 운영체제(OS)에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 이식하여 외부의 침입으로부터 시스템 자원을 보호하는 운영체제

| --- | --- |
#암논시물 → 구현하기 복잡한 순서: 암 > 논 > 시 > 물

2. 참조 모니터(Reference Monitor)
- 보호대상의 객체에 대한 접근통제를 수행하는 추상머신이며, 이를 실제로 구현한 것이 보안 커널임


- **3가지 특징** #격검완

- **격**리성(Isolation): 부정 조작 불가능
- **검**증 가능성(Verifiability): 적절히 구현됐다는 것 확인 가능
- **완**전성(Completeness): 우회가 불가능
3. Secure OS의 보안 기능
- 식별 및 인증, 임의적 접근통제(DAC), 강제적 접근통제(MAC), 객체 재사용 보호, 완전한 조정, 신뢰 경로, 감사 및 감사기록 축소

#### 2. 회복 및 병행제어, 데이터 표준화 ⭐⭐
>[!summary] p.762~764, 5-60

1. 회복(Recovery)
- 트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업


- **장애의 유형**

- **트랜잭션 장애**: 트랜잭션 내부의 비정상적인 상황으로 인해 프로그램 실행이 중지되는 현상
- **시스템 장애**: 데이터베이스에 손상을 입히지는 않으나 하드웨어 오동작, 소프트웨어의 손상, 교착상태 등에 의해 모든 트랜잭션의 연속적인 수행에 장애를 주는 현상
- **미디어 장애**: 저장장치인 디스크 블록의 손상이나 디스크 헤드의 충돌 등에 의해 데이터베이스의 일부 또는 전부가 물리적으로 손상된 상태

- **회복 관리기(Recovery Management)**: DMBS의 구성 요소, 트랜잭션 실행이 성공적으로 완료되지 못하면 트랜잭션이 데이터 베이스에 생성했던 모든 변화를 취소(Undo)시키고, 트랜잭션 수행 이전의 원래 상태로 복구하는 역할 담당

- 메모리 덤프, 로그(Log)를 이용하여 회복 수행
2. 병행제어(Concurrency Control)
- 다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것


- **병행제어의 목적**

- 데이터베이스의 공유 최대화
- 데이터베이스의 일관성 유지
- 시스템 활용도 최대화
- 사용자에 대한 응답 시간 최소화
3. 병행수행의 문제점 ⭐ __ 5-61
| --- | --- |
#갱현모연

4. 데이터 표준화의 정의 __ 5-64
- 시스템을 구성하는 데이터 요소의 명칭, 정의, 형식, 규칙에 대한 원칙을 수립하고 적용하는 것을 의미


- **데이터 표준의 종류**

- 표준 **단**어: 업무에서 사용하고 일정한 의미를 갖고 있는 최소 단위의 단어
- 표준 **도**메인: 문자, 숫자, 날짜, 시간형과 같이 컬럼을 성질에 따라 그룹핑 한 개념
- 표준 **코**드: 선택할 수 있는 값을 정형화하기 위해 기준에 맞게 이미 정의된 코드값
- 표준 **용**어: 단어, 도메인, 코드 표준이 정의되면 이를 바탕으로 표준 용어 구성

#단도코용

5. 데이터 관리 조직
- 데이터 표준 원칙이나 데이터 표준의 준수 여부 등을 관리하는 사람들


	- 산출물 : 데이터 관리자(DA), 데이터베이스 관리자(DBA)

#### 3. 네트워크 관련 신기술 ⭐⭐⭐
>[!summary] p.724, 5-18, 20년 1, 2회 기출문제

| --- | --- |
#### 4. 소프트웨어 관련 신기술 ⭐⭐⭐
>[!summary] p.740, 5-36, 20년 3회 기출문제

| --- | --- |
#### 5. 하드웨어 관련 신기술 ⭐⭐⭐
>[!summary] p.753, 20년 3회 기출문제

| --- | --- |
#### 6. 데이터베이스 관련 신기술 ⭐⭐⭐
>[!summary] p.760, 5-56, 20년 1, 2회 기출문제

| --- | --- |
Secure SDLC ⭐
>[!summary] p.772, 5-2, 5-70

1. Secure SDLC의 개요
- 보안상 안전한 소프트웨어를 개발하기 위해 SDLC에 보안 강화를 위한 프로세스를 포함한 것


- 요구사항 **분**석: 보안 항목에 해당하는 요구사항을 식별하는 작업 수행

- **설**계: 요구사항들을 설계서에 반영하고 보안 설계서 작성

- **구**현: 표준 코딩 정의서 및 **시큐어 코딩(Secure Coding)**을 준수하며, 설계서에 따라 보안 요구사항 구현 및 지속적인 단위 테스트를 통해 소스 코드의 안정성 확보

- **테**스트: 동적 분석 도구 또는 모의 침투테스트를 통해 검증

- **유**지보수: 발생할 수 있는 보안사고 식별 및 보안 패치 식실시

#분설구테유

2. 보안 요소 ⭐⭐ __ 5-62, 20년 1, 2, 3회 기출문제
| --- | --- |
#기무가 인부

### 시스템 보안 구축
#### 1. 소프트웨어 개발 보안 구축 ⭐⭐⭐
| --- | --- |
#세입보시_에코캡아
>[!summary] p.775~790, 5-70, 20년 3회 기출문제

1. 세션 설계시 고려 사항 ⭐
- 모든 페이지에서 로그아웃이 가능하도록 UI(User Interface) 구성
- 로그아웃 요청 시 할당된 세션이 완전히 제거되도록 함
- 세션 타임아웃은 중요도가 높으면 2~5분, 낮으면 15~30분으로 설정
- 이전 세션이 종료되지 않으면 새 세션이 생성되지 못하도록 설계
- 패스워드 변경 시 활성화된 세션을 삭제한 후 재할당
2. 세션 ID의 관리 방법 ⭐
- 안전한 서버에서 최소 128비트의 길이로 생성
- 예측이 불가능하도록 안전한 난수 알고리즘 적용
- 노출되지 않도록 URL Rewrite 기능을 사용하지 않는 방향으로 설계
- 로그인 시 로그인 전의 세션 ID를 삭제하고 재할당
- 장기간 접속하고 있는 세션 ID는 주기적으로 재할당되도록 설계
3. 크로스 사이트 스크립팅(XSS; Cross-Site Scripting) ⭐
- 웹페이지에 악의적인 스크립트를 삽입하여 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점


→ HTML 태그의 사용을 제한하거나 스크립트에 삽입되지 않도록 ‘<’, ‘>’, ‘&’ 등의 문자를 다른 문자로 치환함으로써 방지

4. 부적절한 자원 해제 ⭐
- 자원을 반환하는 코드를 누락하거나 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점


→ 오류로 인해 함수가 중간에 종료되었을 때, 예외처리에 관계없이 자원이 반환되도록 코딩함으로써 방지

#### 2. 암호 알고리즘 ⭐⭐⭐
>[!summary] p.792, 5-76

1. 암호 알고리즘의 개요
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%205%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%80%E1%85%AA%E1%86%AB%20c3e23d19a6684999a35f934c69af5f4c/image3.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%205과목%20정보시스템%20구축%20관%20c3e23d19a6684999a35f934c69af5f4c/image3.png)
2. 암호화(Encryption)
- **암호화(Encryption) 과정**
- 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정
	- 산출물 : 개인키 암호 방식(대칭키), 공개키 암호 방식(비대칭키)
- **복호화(Decryption) 과정**
- 암호문을 원래의 평문으로 바꾸는 과정
3. 암호화 방식 ⭐⭐ __ 20년 1, 2, 3회 기출문제
| --- | --- | --- | --- |
4. 암호화 방식 장, 단점 ⭐
| --- | --- | --- |
5. 양방향 알고리즘 종류 ⭐⭐ __ 20년 3회 기출문제
| --- | --- |
6. 해시(Hash)
- 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것
- 해시 알고리즘을 해시 함수라고 부르며, 해시 함수로 변환된 값이나 키를 해시값 또는 해시키라 부름

- 데이터의 암호화, 무결성 검증을 위해 사용될 뿐만 아니라 정보보호의 다양한 분야에서 활용됨 ⭐
	- 산출물 : **SHA** 시리즈, **MD5**, N-NASH, SNEFRU ⭐
#### 3. 서비스 공격 유형 ⭐⭐⭐
>[!summary] p.802, 5-81, 20년 1, 2, 3회 기출문제

| --- | --- |
1. 네트워크 침해 공격 관련 용어
| --- | --- |
2. 정보 보안 침해 공격 관련 용어 __ 20년 1, 2회 기출문제
| --- | --- |
#### 4. 보안 솔루션 ⭐⭐⭐
>[!summary] p.816, 5-96, 20년 3회 기출문제

| --- | --- |
#### 5. 서버 인증 ⭐
>[!summary] p.807, 5-85

1. 인증(Authentication)의 개념 ⭐
- 다중 사용자 컴퓨터 시스템이나 네트워크 시스템에서 로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안 절차

- **인증의 주요 유형**: **지**식 기반 인증, **소**유 기반 인증, **생**체 기반 인증, **특**정 기반 인증
#지소생특
2. 지식 기반 인증(Something You know)
- 사용자가 기억하고 있는 정보를 기반으로 인증을 수행하는 것


	- 산출물 : 고정된 패스워드(Password), 패스 프레이즈(Pass phrase, **문장**), 아이핀(i-PIN)

3. 소유 기반 인증(Something You Have)
- 사용자가 소유하고 있는 것을 기반으로 인증을 수행하는 것

	- 산출물 : 신분증, 메모리 카드(토큰), 스마트 카드, OTP(One Time Password)
4. 생체 기반 인증(Something You Are)
- 사용자의 고유한 생체 정보를 기반으로 인증을 수행하는 것

	- 산출물 : 지문, 홍채/망막, 얼굴, 음성, 정맥 등
5. 특징 기반 인증
- 행위 기반 인증(Something You Do): 사용자의 행동 정보를 이용해 인증 수행
	- 산출물 : **서명**, 동작
- 위치 기반 인증(Somewhere You Are): 인증을 시도하는 위치의 적절성 확인
	- 산출물 : 콜백, GPS나 IP 주소를 이용한 위치 기반 인증
#### 6. 로그 분석 ⭐
>[!summary] p.813, 5-94

1. 로그(Log)의 개념
- 시스템 사용에 대한 모든 내역을 기록해 놓은 것으로, 이러한 로그 정보를 이용하면 시스템 침해 사고 발생 시 해킹 흔적이나 공격 기법을 파악할 수 있음

2. 리눅스(LINUX)의 주요 로그 파일 ⭐
| --- | --- | --- | --- |
3. Windows 로그
- Windows 시스템에서는 이벤트 로그 형식으로 시스템의 로그를 관리함
- Windows의 이벤트 뷰어를 이용하여 이벤트 로그를 확인함
4. Windows 이벤트 뷰어의 로그
- **응**용 프로그램 로그, **보**안 로그, **시**스템 로그, **S**etup 로그, **F**orwarded Events 로그
#응보시SF
**추가 정리, 수제비 및 기출문제** ⭐⭐⭐
1. 오픈플로우(Openflow) ⭐ __ 5-20
- 네트워크 장치의 컨트롤 플레인(Control Plane)과 데이터 플레인(Data Plane) 간의 연계 및 제어를 담당하는 개방형 표준 인터페이스
| --- | --- |
#오컨프스_흐파그보
2. 기계학습(Machine Learning) __ 5-33
| --- | --- | --- |
#지비강 #인회 KP Q몬

3. 네트워크 기능 가상화(NFV) __ 5-21
- 서버, 스토리지, 스위치 등 범용 하드웨어에 가상화 기술을 적용하여 네트워크 기능을 가상 기능으로 모듈화하여 스위치나 라우터 등 필요한 곳에 제공하는 기술

| --- | --- |
#Fun_In_Ma
4. 오버레이 네트워크(Overlay Network) __ 5-22
- 기존 네트워크 위에 별도의 노드들과 논리적 링크들을 구성하여 이루어진 가상 네트워크
| --- | --- |
#DOMB식
5. 광전송 장비 __ 5-26
- 네트워크의 스위칭 노드를 묶어 주는 시스템으로 광케이블을 이용하여 비교적 긴 거리의 데이터 전송에 이용

| --- | --- |
#SO SDC

6. 딥러닝(Deep Learning) __ 5-34
| --- | --- |
#DCR

7. 엣지 컴퓨팅(Edge Computing) __ 5-46
- 엣지(Edge)에 위치한 디바이스에 연산능력을 부여하여 데이터 처리 및 연산을 분산시키는 컴퓨팅 구조

8. SDDC(Software-Defined Data Center) __ 5-47
- 모든 하드웨어가 가상화되어 가상 자원의 풀(Pool)을 구성하고, 데이터 센터 전체를 운영하는 소프트웨어가 필요한 기능 및 규모에 따라 동적으로 자원을 할당, 관리하는 역할을 수행하는 데이터 센터

9. NoSQL의 유형 __ 5-58
| --- | --- |
#Key Col Do G

10) 보안 아키텍처 영역 __ 5-88
- 관리적 보안: 최상위 레벨에서 보안 목표, 보안 조직, 관계 법령 등 원칙 정의


- **물**리적 보안: 조직의 자산에 대해 물리적 위협 수단으로부터 보호하기 위한 수단

- **기**술적 보안: 보안 기술 요소를 식별 후 보안 목표를 정의하고 해당 기술 도입

#관물기

11) 데이터베이스 동시성(병행) 제어 기법 __ 5-62
| --- | --- |
#로투낙타다
12) 스택가드(Stack Guard) __ 20년 1, 2회 기출문제
82. 메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은? (2020년 제1, 2회차 필기시험, B형)


→ **스택가드(Stack Guard)**

13) tripwire __ 20년 1, 2회 기출문제
87. 크래커가 침입하여 백도어를 만들어 놓거나, 설정 파일을 변경했을 때 분석하는 도구는? (2020년 제1, 2회차 필기시험, B형)


→ **tripwire**

14) 백도어 탐지 방법 __ 20년 1, 2회 기출문제
83. 백도어 탐지 방법으로 틀린 것은? (2020년 제1, 2회차 필기시험, B형)


① 무결성 검사 ② **닫힌 포트 확인 → 열린 포트 확인**

③ 로그 분석 ④ SetUID 파일 검사

-**현재 동작중인 프로세스 및 열린 포트 확인**

- 해커가 접근을 위해 실행시켜둔 프로세스가 있는지, 열어둔 포트가 있는지 확인함

-**SetUID 파일 검사**

- SetUID 권한의 파일을 많이 사용하므로, SetUID 권한이 있는 파일들을 검사해봄

-**무결성 검사**

- 침입자에 의해 변경된 파일이 있는지 검사해봄

-**로그 분석**

- 침입자의 기록을 분석해 보면 누가, 어떠한 공격을 했는지 알 수 있음

-**바이러스 및 백도어 탐지 툴 사용**

- 백신 등의 바이러스 탐지 툴을 사용해 찾음
15) 소프트웨어 재사용 방법 __ 20년 3회 기출문제
| --- | --- |
16) 실무적으로 검증된 개발보안 방법론 __ 20년 3회 기출문제
| --- | --- |
17) CPM 네트워크 임계경로 __ 17년 3회 기출문제, 20년 3회 기출문제
79. **CPM 네트워크**가 다음과 같을 때 **임계경로의 소요기일**은?
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%205%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%80%E1%85%AA%E1%86%AB%20c3e23d19a6684999a35f934c69af5f4c/image4.gif](image4.gif)
① 10일 ② 12일
**③ 14일** ④ 16일
- 임계 경로 = **최장경로** 의미
→ 경로 1: 2일 + 2일 + 3일 + 3일 = 10일
→ **경로 2**: 2일 + 3일 + 5일 + 4일 = **14일**
→ 경로 3: 3일 + 5일 + 4일 = 12일
18) 보안 기능, 보안 약점 – 하드코드 된 암호화 키 사용 __ 20년 3회 기출문제
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%205%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%80%E1%85%AA%E1%86%AB%20c3e23d19a6684999a35f934c69af5f4c/image5.png](2. Area/99. 기타/img/정보처리기사/정보처리기사%20필기,%205과목%20정보시스템%20구축%20관%20c3e23d19a6684999a35f934c69af5f4c/image5.png)
- ‘하드코드 된 암호화 키’항목의 **위험**한 예 (행정안전부 / 한국인터넷진흥원)
![%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%E1%84%80%E1%85%B5%E1%84%89%E1%85%A1%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5,%205%E1%84%80%E1%85%AA%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%80%E1%85%AA%E1%86%AB%20c3e23d19a6684999a35f934c69af5f4c/image6.png](image6.png)
- ‘하드코드 된 암호화 키’항목의 **안전**한 예 (행정안전부 / 한국인터넷진흥원)
19) 요구사항 분석 자동화 도구 __ 20년 4회 기출문제
| --- | --- |
20) NS chart의 특징 __ 20년 4회 기출문제
NS(Nassi-Schneiderman) chart


- 논리의 기술에 중점을 둔 도형식 표현 방법
- 전문성이 있어야 그리기 쉬움 (그리기 어려움)
- 연속, 선택 및 다중 선택, 반복 등의 제어논리 구조로 표현함
- 임의의 제어 이동이 어려움 → goto구조가 어려움
- 그래픽 설계 도구임, 상자 도표라고도 함
- 프로그램으로 구현이 쉬움
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합함


21) 용어 __ 20년 4회 기출문제
| --- | --- |

# 실기 시험

# 기출문제


# 연관 문서